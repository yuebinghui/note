##### 11. 按递增次序输出带头结点的单链表和各结点的数据元素

下面的视频，执行了一轮while循环，在87 88行重置指针后就没再录屏了，可以自己画画

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-05 16.40.16.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

void min_delete(LinkList &L) {
    LNode *pre = L, *p = L->next, *q; // pre为最小结点的前驱结点的指针
    while (L->next != NULL) { // 循环到仅剩头结点
        while (p->next != NULL) { // 就是p指针指到最后一个结点就不执行下面的语句了
            // p的下一个结点的数据 和 pre的下一个结点的数据比较
            // 比p比pre还小，你p就是更小的，放入pre，标记最小结点的前驱
            if (p->next->data < pre->next->data) {
                pre = p; // 记住当前最小结点的前驱结点
            }
            p = p->next;
        }
        printf("pre->next->data=%d\n", pre->next->data); // 输出最小值结点的数据
        q = pre->next; // 删除值最小的结点，释放结点空间
        pre->next = q->next;
        free(q);

        // 重置pre 和 p的指针，循环执行上面代码
        pre = L;
        p = L->next;
    }
    free(L); // 释放头结点
}

int main() {
    int A1[] = {25, 10, 7, 15, 30};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
//    print(L2);

    min_delete(L1);
    // print(L1); // 这里不可以调用这个 链表L1已经在min_delete被释放，但在print(L1)语句中仍然尝试访问已经释放的内存。

//    print(L3);


    return 0;
}
```

##### 12. 将一个带头结点的单链表A 分解成两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变.

就是可以有多种情况，
比如A里为序号为偶，B里为序号为奇
比如A里为序号为奇，B里为序号为偶
比如A里为值为偶，B里为值为奇
比如A里为值为奇，B里为值为偶

序号就第一个结点，第二个结点
用i取余来判断，序号是奇数还是偶数，![image-20241007153424972](/Users/yuebinghui/Documents/program/github/note/images/image-20241007153424972.png)

用当前结点的值取余，判断是奇数还是偶数![image-20241007153602127](/Users/yuebinghui/Documents/program/github/note/images/image-20241007153602127.png)

