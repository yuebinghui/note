# çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤º-é“¾è¡¨

## ç»éªŒ1ï¼šæ³¨æ„p->next != null å’Œ p!=nullçš„åŒºåˆ«

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3, 44, 53, 4};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}

// ä»£ç è§£é‡Šè¯·çœ‹ä¸Šæ¡
void Delete_x(LinkList &L, ElemType x) {
    LNode *pre, *p, *q;
    p = L->next;

    while (p->next != NULL) {
        printf("p->next = %d\n", p->data);
        p = p->next;
    }

    p = L->next;
    while (p != NULL) {
        printf("p = %d\n", p->data);
        p = p->next;
    }

}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L, 4);
    print(L);
    return 0;
}
```



##### å¤´ç»“ç‚¹å’Œå¤´æŒ‡é’ˆçš„å…³ç³»

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20241004110258475.png" alt="image-20241004110258475" style="zoom:45%;" />

##### æ’å…¥èŠ‚ç‚¹æ“ä½œ

![image-20241004125543587](/Users/yuebinghui/Documents/program/github/note/images/image-20241004125543587.png)

![image-20241004125606015](/Users/yuebinghui/Documents/program/github/note/images/image-20241004125606015.png)

##### åˆ é™¤ç»“ç‚¹æ“ä½œ

![image-20241004130723638](/Users/yuebinghui/Documents/program/github/note/images/image-20241004130723638.png)

![image-20241004130739882](/Users/yuebinghui/Documents/program/github/note/images/image-20241004130739882.png)

##### é‡‡ç”¨å¤´æ’æ³•å»ºç«‹å•é“¾è¡¨

![image-20241004131156196](/Users/yuebinghui/Documents/program/github/note/images/image-20241004131156196.png)

##### é‡‡ç”¨å°¾å·´æ’æ³•å»ºç«‹å•é“¾è¡¨

![image-20241004131251253](/Users/yuebinghui/Documents/program/github/note/images/image-20241004131251253.png)

##### 1. ğŸŒŸğŸŒŸğŸŒŸ è®¾è®¡ä¸€ä¸ªé€’å½’ç®—æ³•ï¼Œåˆ é™¤ä¸å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨Lä¸­æ‰€æœ‰å€¼ä¸ºxçš„ç»“ç‚¹

![image-20241015160304301](/Users/yuebinghui/Documents/program/github/note/images/image-20241015160304301.png)

![image-20241015163455883](/Users/yuebinghui/Documents/program/github/note/images/image-20241015163455883.png)

1

![image-20241015163502374](/Users/yuebinghui/Documents/program/github/note/images/image-20241015163502374.png)

2

![image-20241015164149667](/Users/yuebinghui/Documents/program/github/note/images/image-20241015164149667.png)

3

![image-20241015164721927](/Users/yuebinghui/Documents/program/github/note/images/image-20241015164721927.png)

4

![image-20241015164953783](/Users/yuebinghui/Documents/program/github/note/images/image-20241015164953783.png)

5 

![image-20241015165511382](/Users/yuebinghui/Documents/program/github/note/images/image-20241015165511382.png)

é€’è¿›å»äº†ï¼ˆå…¥æ ˆäº†ï¼‰
ç°åœ¨è¦å‡ºæ ˆäº†

6 

![image-20241015165718414](/Users/yuebinghui/Documents/program/github/note/images/image-20241015165718414.png)

7

![image-20241015165954337](/Users/yuebinghui/Documents/program/github/note/images/image-20241015165954337.png)

8

![image-20241015170236253](/Users/yuebinghui/Documents/program/github/note/images/image-20241015170236253.png)

9 åˆ°mainå‡½æ•°äº†ï¼Œé€’å½’ç»“æŸäº†

![image-20241015170348280](/Users/yuebinghui/Documents/program/github/note/images/image-20241015170348280.png)

https://blog.csdn.net/ssjq123/article/details/108125936
https://blog.csdn.net/coolyuan/article/details/114951966

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L->next != NULL) {
//        L = L->next;
//        printf("%d\n", L->data);
//    }
//printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 2, 3, 4, 5, 6, 7};
//    int size = sizeof(A) / sizeof(int);
//
//    L = (LNode *) malloc(sizeof(LNode));
//    LNode *s, *r;
//    r = L;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        r->next = s;
//        r = s;
//    }
//}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}


void Delete_x(LinkList &L, ElemType x) {
    LNode *p; // pæŒ‡å‘å¾…åˆ é™¤ç»“ç‚¹
    if (L == NULL) { // é€’å½’å‡ºå£
        return;
    }

    if (L->data == x) { // è‹¥å½“å‰Lç»“ç‚¹æ•°æ®åŸŸä¸ºx
        p = L; // på­˜ä¸‹è¿™ä¸ªè¦åˆ é™¤ç»“ç‚¹çš„æŒ‡é’ˆ
        L = L->next; // è®©LæŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹
        free(p); // åˆ é™¤p
        Delete_x(L, x);
    } else { // è‹¥å½“å‰Lç»“ç‚¹æ•°æ®åŸŸ ä¸ ä¸ºxï¼Œç›´æ¥åç§»ä¸€ä½ç»“ç‚¹
        Delete_x(L->next, x);
    }
};


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L,4);
    print(L);
    return 0;
}
```

##### 2.è®¾Lä¸ºå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ï¼Œç¼–å†™ç®—æ³•ä»å°¾åˆ°å¤´åå‘è¾“å‡ºæ¯ä¸ªç»“ç‚¹çš„å€¼

é€’å½’çš„è¯å°±æ˜¯å› ä¸ºæˆ‘å»è°ƒç”¨ï¼Œé¦–å…ˆæˆ‘å»ï¼Œå‡å¦‚æ˜¯ã€‚è°ƒç”¨çš„æ—¶å€™å®ƒå°±12345ã€‚

![image-20241004152108798](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152108798.png)

é‚£ä¹ˆæˆ‘ã€‚ç¬¬ä¸€ä¸‹çš„æ—¶å€™å°±æŠŠä¸€æ”¾è¿›å»ï¼Œ
ç„¶åäºŒæ”¾è¿›å»
3
4
5
ç›´åˆ°æˆ‘æ”¾å®Œä¹‹åï¼Œç„¶åæˆ‘å¼€å§‹å»ç®—å®ƒçš„æ—¶å€™ï¼Œ

![image-20241004152119768](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152119768.png)

é‚£å°±æ˜¯54321ã€‚
åå‘è¾“å‡ºçš„æ—¶å€™ç”¨é€’å½’ï¼Œ

![image-20241004152135836](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152135836.png)

é‚£å°±æ˜¯ç›´æ¥æŠŠå®ƒï¼Œ
ä½ çœ‹å®ƒä¸æ–­çš„é€’å½’ï¼Œ
é‚£å°±æ˜¯æ”¾è¿›å»ã€‚ç„¶åã€‚
ç›´åˆ°å®ƒä¸ºç©ºï¼Œæˆ‘å°±å¼€å§‹è¾“å‡ºï¼Œ
é‚£è¾“å‡ºçš„æ—¶å€™å°±æ˜¯åå‘è¾“å‡ºçš„ã€‚

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}

//void print_reverse(LinkList L) {
//    if (L == NULL)return;
//    print_reverse(L->next);
//    printf("%d ", L->data);
//}


void print_reverse(LinkList L) {
//    if (L->next) { // æˆ–è€…æ˜¯è¿™æ ·
// ä½ æœ‰nextæˆ‘ä¸‹é¢æ‰å¯ä»¥æ‰§è¡ŒL->nextï¼Œä¸ç„¶å°±L->nextå·²ç»æ˜¯nulläº†ï¼Œå†è°ƒç”¨å°±ä¼šæœ‰é—®é¢˜
// æ¯”å¦‚æˆ‘1 2 3        3ä¸ªç»“ç‚¹ï¼Œè°ƒç”¨åˆ°3çš„æ—¶å€™ï¼Œ3çš„nextå°±å·²ç»æ˜¯Nulläº†ï¼Œå°±ä¸æ‰§è¡Œifé‡Œçš„ä»£ç äº†ï¼Œæ‰€ä»¥å‡½æ•°å°±ä¸ä¼šprint_reverse(NULL)
// å¦‚æœæ˜¯if(L!=NULL)é‚£ä¹ˆifé‡Œå°±ä¼šæ‰§è¡Œè¿™æ ·çš„ä»£ç print_reverse(NULL)ï¼Œä¸‹é¢çš„L->dataå°±ä¼šæœ‰é—®é¢˜äº†
    if (L->next != NULL) {
        print_reverse(L->next); // é€’å½’éå†æ¯ä¸ªç»“ç‚¹
    }
    printf("L->data=%d\n", L->data);
};

//void reverse_print(LinkList L) {
////    if (L->next) { // æˆ–è€…æ˜¯è¿™æ ·
//// ä½ æœ‰nextæˆ‘ä¸‹é¢æ‰å¯ä»¥æ‰§è¡ŒL->nextï¼Œä¸ç„¶å°±L->nextå·²ç»æ˜¯nulläº†ï¼Œå†è°ƒç”¨å°±ä¼šæœ‰é—®é¢˜
//// æ¯”å¦‚æˆ‘1 2 3 3ä¸ªç»“ç‚¹ï¼Œè°ƒç”¨åˆ°3çš„æ—¶å€™ï¼Œ3çš„nextå°±å·²ç»æ˜¯Nulläº†ï¼Œå°±ä¸æ‰§è¡Œifé‡Œçš„ä»£ç äº†ï¼Œæ‰€ä»¥å‡½æ•°å°±ä¸ä¼šprint_reverse(NULL)
//// å¦‚æœæ˜¯if(L!=NULL)é‚£ä¹ˆifé‡Œå°±ä¼šæ‰§è¡Œè¿™æ ·çš„ä»£ç print_reverse(NULL)ï¼Œä¸‹é¢çš„L->dataå°±ä¼šæœ‰é—®é¢˜äº†
//    if (L != NULL) {
//        reverse_print(L->next); // é€’å½’éå†æ¯ä¸ªç»“ç‚¹
//    }
//    if(L){
//        printf("L->data=%d\n", L->data);
//    }
//};


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);

    // å¦‚æœLæ˜¯ä¸ªç©ºæŒ‡é’ˆå°±ä¸æ‰“å°äº†
    if (L != NULL) {
        // ä¸éœ€è¦æ‰“å°å¤´ç»“ç‚¹çš„æ•°æ®åŸŸï¼Œå› ä¸ºå¤´ç»“ç‚¹çš„æ•°æ®åŸŸä¸å­˜å‚¨æ•°æ®
        print_reverse(L->next);
    }

    print(L);
    return 0;
}
```

##### 3.ğŸŒŸä»å•é“¾è¡¨ä¸­åˆ é™¤è‡ªç¬¬iä¸ªå…ƒç´ èµ·çš„å…±lenä¸ªå…ƒç´ ï¼ˆä¸å¸¦å¤´ç»“ç‚¹ï¼‰

ä¸å¸¦å¤´ç»“ç‚¹çš„è¯è¦åšç‰¹æ®Šå¤„ç†
å¦‚æœæ˜¯å¸¦å¤´ç»“ç‚¹ï¼Œé‚£ä¹ˆåªæœ‰elseé‡Œçš„è¯­å¥ï¼Œifé‡Œçš„è¯­å¥å°±æ²¡ç”¨äº†

<u>ä¸å¸¦å¤´ç»“ç‚¹çš„ç‰¹æ®Šå¤„ç†ï¼Œå°±æ˜¯åˆ©ç”¨iå’Œlenä¸¤ä¸ªæ¡ä»¶ï¼Œæ¥å†™äº†forå¾ªç¯ï¼Œå› ä¸ºå°±æ˜¯ä»ç¬¬ä¸€ä¸ªèµ·ï¼Œåˆ é™¤lenä¸ªï¼Œæ‰€ä»¥å°±å¯ä»¥å†™ä¸ªforå¾ªç¯</u>
<u>è®©å®ƒæ‰§è¡Œlenæ¬¡</u>
<u>ç„¶ååˆ©ç”¨ä¸€ä¸ªæŒ‡é’ˆpå’ŒLæ¥è¿›è¡Œåˆ é™¤</u>
<u>p=L</u>
<u>L=p->next</u>
<u>free(p)</u>
<u>è¿™æ ·å¾ªç¯ï¼Œä½ çœ‹è¿™ä¸ªå…ˆè®©pç­‰äºLï¼Œç„¶åè®©LæŒ‡å‘pçš„åä¸€é¡¹ï¼ŒæŠŠpé‡Šæ”¾è°ƒå</u>
<u>å¾ªç¯åˆæŠŠLèµ‹å€¼ç»™pï¼Œå­¦ä¸€å­¦</u>

ç‰¹æ®Šå¤„ç†çš„æ­¥éª¤ï¼Œåˆ é™¤iå¼€å§‹ï¼Œlenä¸ª iä¸º1ï¼Œlenä¸º3

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-04 16.59.26.mov"></video>

elseçš„æ­¥éª¤

<u>é¦–å…ˆå› ä¸ºè¦ç¡®å®šä»å“ªé‡Œå¼€å§‹åˆ é™¤ï¼Œæ‰€ä»¥å…ˆå†™ä¸ªå¾ªç¯æ‰¾åˆ°ç¬¬i-1ä¸ªç»“ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¦åˆ é™¤ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹</u>
<u>ç„¶ååˆ©ç”¨ä¸€ä¸ªpå’Œä¸€ä¸ªq</u>
<u>q=p->next</u>
<u>p->next=q->next</u>
<u>free(q)</u>
<u>ç„¶åä¹Ÿæ˜¯å¾ªç¯æ“ä½œ</u>

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-04 18.22.54.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L->next != NULL) {
//        L = L->next;
//        printf("%d\n", L->data);
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 2, 3};
//    int size = sizeof(A) / sizeof(int);
//
//    L = (LNode *) malloc(sizeof(LNode));
//    LNode *s, *r;
//    r = L;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        r->next = s;
//        r = s;
//    }
//}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

void Delete_i_len(LinkList &L, int i, int len) {
    LNode *p, *q;
    // æ— å¤´ç»“ç‚¹è¦ç‰¹æ®Šå¤„ç†ï¼Œç¬¬ä¸€ä¸ªç»“ç‚¹
    // å¦‚æœè¦åˆ é™¤çš„å…ƒç´ åŒºé—´ï¼Œèµ·å§‹ä½ç½®ä¸º1
    if (i == 1) {
        // ä»1å¼€å§‹ï¼Œåˆ é™¤lenä¸ªï¼Œé‚£ä¹ˆå°±éå†lenæ¬¡
        for (int j = 1; j <= len; ++j) {
            // qå­˜ä¸‹LæŒ‡å‘çš„ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œå› ä¸ºè¦åˆ é™¤å®ƒ
            q = L;
            // ç„¶åè®©LæŒ‡å‘qçš„ä¸‹ä¸€ä¸ªå…ƒç´ 
            L = q->next;
            // å†freeæ‰q
            free(q);
        }
    } else {
        // jç”¨æ¥è®°å½•å½“å‰æ˜¯ç¬¬å‡ ä¸ªç»“ç‚¹ï¼Œå› ä¸ºä¸å¸¦å¤´ç»“ç‚¹ï¼Œæ‰€ä»¥é»˜è®¤æ˜¯ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œå¦‚æœå¸¦å¤´ç»“ç‚¹ï¼Œé»˜è®¤ç¬¬0ä¸ªç»“ç‚¹
        int j = 1;
        // pæŒ‡å‘ç¬¬ä¸€ä¸ªç»“ç‚¹
        p = L;
        // æ‰¾åˆ°ç¬¬i-1ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯è¦åˆ é™¤å…ƒç´ çš„å‰é©±
        // å°äºi-1çš„æ—¶å€™çš„æ¡ä»¶éƒ½æ˜¯æ»¡è¶³çš„ï¼Œå½“é‡åˆ°j=i-1çš„æ—¶å€™ï¼Œå¾ªç¯å°±ä¼šåœä¸‹æ¥ï¼Œé‚£ä¹ˆæ­¤æ—¶jå°±æ˜¯ æˆ‘è¦åˆ é™¤å…ƒç´ çš„å‰é©±
        while (p != NULL && j < i - 1) {
            j++; // æœ‰å‡ ä¸ªç»“ç‚¹
            p = p->next; // æŒ‡é’ˆåç§»ä¸€ä¸ªç»“ç‚¹
        }
        if (!p) return; // å¦‚æœpä¸ºNULLè¯´æ˜é“¾è¡¨å·²ç»ä¸ºç©º
        // å¦‚æœå¯ä»¥æ‰§è¡Œåˆ°è¿™é‡Œè¯´æ˜på°±æ˜¯ æˆ‘è¦åˆ é™¤å…ƒç´ çš„å‰é©±
        // åˆ é™¤lenä¸ªï¼Œä¸‹é¢çš„ä»£ç æ‰§è¡Œlenæ¬¡
        for (int k = 1; k <= len; ++k) {
            // ç”¨qæŒ‡é’ˆå­˜ä¸‹pçš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œå› ä¸ºè¦åˆ é™¤å®ƒ
            q = p->next;
            // pæŒ‡å‘ è¦åˆ é™¤å…ƒç´ çš„ä¸‹ä¸€ä¸ªç»“ç‚¹
            p->next = q->next;
            // åˆ é™¤å…ƒç´ 
            free(q);
        }
    }
}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_i_len(L, 3, 3);
    print(L);
    return 0;
}
```

##### 4.ğŸŒŸåˆ é™¤ä¸å¸¦å¤´ç»“ç‚¹å•é“¾è¡¨ä¸­æ‰€æœ‰å€¼ä¸ºxçš„ç»“ç‚¹ï¼ˆéé€’å½’ï¼‰

æ„Ÿè§‰è¿™å¥—å†…å®¹æ˜¯åœ¨ä¸€ä¸ªéå†ä¸‹æ“ä½œï¼Œè®©på»éå†ï¼Œä¸ç®¡ä½ è¿›å…¥åˆ°å“ªä¸ªifæˆ–è€…elseé‡Œï¼Œæœ€åä¸€æ­¥éƒ½è¦è®©pçš„æŒ‡é’ˆåç§»ï¼Œæ¥è¿›è¡Œå¾ªç¯æ“ä½œ
<u>å¦‚æœä¸åˆ é™¤å°±æ˜¯å…‰åç§»ï¼Œå¦‚æœåˆ é™¤å°±æ˜¯åˆ äº†å†åç§»ï¼Œåæ­£på¾—åç§»</u>

**æ–¹æ³•äºŒä¸­ï¼Œä¸¤ç§åˆ é™¤çš„æ€è·¯å¯ä»¥å¥½å¥½çœ‹çœ‹**

![image-20241004200219468](/Users/yuebinghui/Documents/program/github/note/images/image-20241004200219468.png)

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-04 18.49.20.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L->next != NULL) {
//        L = L->next;
//        printf("%d\n", L->data);
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 2, 3};
//    int size = sizeof(A) / sizeof(int);
//
//    L = (LNode *) malloc(sizeof(LNode));
//    LNode *s, *r;
//    r = L;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        r->next = s;
//        r = s;
//    }
//}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}


void Delete_x(LinkList &L, ElemType x) {
    // æŒ‡å‘è¦åˆ é™¤ç»“ç‚¹çš„å‰é©±ç»“ç‚¹ï¼Œä¸ç„¶å°±å°±ç®—æ‰¾åˆ°äº†è¦åˆ é™¤çš„ç»“ç‚¹ï¼Œä¹Ÿæ— æ³•å°†å‰é©±ç»“ç‚¹çš„nextæŒ‡å‘è¦åˆ é™¤ç»“ç‚¹çš„ä¸‹ä¸ªç»“ç‚¹ï¼Œ
    // æ‰€ä»¥è¦ç”¨preæ¥æŒ‡å‘è¦åˆ é™¤ç»“ç‚¹çš„å‰é©±
    LNode *pre = NULL;
    // å·¥ä½œæŒ‡é’ˆï¼Œéå†é“¾è¡¨
    LNode *p = L;
    LNode *q;

    // éå†æ•´ä¸ªé“¾è¡¨ï¼Œç›´åˆ°NULL
    while (p != NULL) {
        // å¦‚æœæ­¤æ—¶çš„ç»“ç‚¹çš„æ•°æ®åŸŸæ˜¯xï¼Œå³è¦åˆ é™¤çš„ç»“ç‚¹
        if (p->data == x) {
            // åˆ¤æ–­preæ˜¯æ˜¯å¦æŒ‡å‘äº†ç»“ç‚¹ï¼Œå¦‚æœæ²¡æœ‰è¯´æ˜å·¥ä½œæŒ‡é’ˆpè¿˜æ²¡æœ‰åŠ¨è¿‡ï¼Œå³ç¬¬ä¸€ä¸ªç»“ç‚¹å°±æ˜¯xï¼Œè¦åˆ é™¤çš„ç»“ç‚¹
            if (pre == NULL) {
                // è®©LæŒ‡å‘pçš„åç»§
                L = p->next;
                // åˆ é™¤pï¼Œ
                free(p);
                // å†è®©pç­‰äºLï¼Œä¹Ÿå°±æ˜¯ç¬¬ä¸€ä¸ªç»“ç‚¹
                p = L;
            } else {
                // æ­¤æ—¶preç»“ç‚¹ä¸ä¸ºç©ºï¼Œå¹¶ä¸”å½“å‰pç»“ç‚¹å­˜çš„æ˜¯x
                // è®©qç­‰äºpï¼Œå­˜ä¸‹qæ¥ï¼Œä¸€ä¼šè¦freeæ‰
                q = p;
                // pæŒ‡å‘åä¸€ä¸ªç»“ç‚¹
                p = p->next;
                // å‰é©±ç»“ç‚¹ï¼ŒæŒ‡å‘è¦åˆ é™¤ç»“ç‚¹çš„åä¸€ä¸ªç»“ç‚¹
                pre->next = p;
                // åˆ é™¤è¦åˆ é™¤çš„ç»“ç‚¹
                free(q);
            }
        } else { // å¦‚æœå½“å‰ç»“ç‚¹ä¸æ˜¯è¦åˆ é™¤çš„ç»“ç‚¹å°±å¾€åéå†ï¼Œæ‰¾x
            // ä¸€å®šæ˜¯preå…ˆå­˜pçš„æŒ‡é’ˆï¼Œpå†èµ°ï¼Œå› ä¸ºpreè¦å­˜pçš„åœ°å€
            // pä¸å¯ä»¥å…ˆå˜ï¼Œå› ä¸ºpreè¦å­˜pçš„å‰é©±
            pre = p;
            // å­˜ä¸Špçš„åœ°å€åï¼Œpå¾€åç§»ä¸€ä¸ªç»“ç‚¹ï¼Œæ­¤æ—¶preå°±æ˜¯pçš„å‰é©±ç»“ç‚¹
            p = p->next;
        }
    }
}

// æ–¹æ³•äºŒï¼Œä¸¤ç§åˆ é™¤çš„æ–¹æ³•ï¼Œå¯ä»¥å¥½å¥½çœ‹çœ‹
void delete_x(LinkList &L, ElemType x) {
    LNode *p = L;
    LNode *pre = NULL;
    while (p != NULL) {
        if (p->data == x) {
            if (pre == NULL) {
                L = p->next;
                free(p);
                p = L;
            } else {
                pre->next = p->next;
                free(p);
                p = pre->next;
            }
        } else {
            pre = p;
            p = p->next;
        }
    }

}



int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L, 4);
    print(L);
    return 0;
}
```

##### 5.1 åœ¨å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨Lä¸­ï¼Œåˆ é™¤æ‰€æœ‰å€¼ä¸ºxçš„ç»“ç‚¹ï¼Œå¹¶é‡Šæ”¾å…¶ç©ºé—´ï¼Œå‡è®¾å€¼ä¸ºxçš„ç»“ç‚¹ä¸å”¯ä¸€ã€‚

![image-20241004200208484](/Users/yuebinghui/Documents/program/github/note/images/image-20241004200208484.png)

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-04 19.34.38.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3, 44, 53, 4};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}

// ä»£ç è§£é‡Šè¯·çœ‹ä¸Šæ¡
void Delete_x(LinkList &L, ElemType x) {
    LNode *pre, *p, *q;
    pre = L;
    p = L->next;

    while (p != NULL) {
        if (p->data == x) {
            q = p;
            p = p->next;
            pre->next = p;
            free(q);
        } else {
            pre = p;
            p = p->next;
        }
    }

}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L, 4);
    print(L);
    return 0;
}
```

##### 5.2. é‡‡ç”¨å°¾æ’æ³•å»ºç«‹å•é“¾è¡¨ï¼Œç”¨PæŒ‡é’ˆæ‰«æLçš„æ‰€æœ‰ç»“ç‚¹ï¼Œå½“å…¶å€¼ä¸ä¸ºxæ—¶ï¼Œå°†å…¶è¿æ¥åˆ°Lä¹‹åï¼Œå¦åˆ™å°†å…¶é‡Šæ”¾

![image-20241004201441645](/Users/yuebinghui/Documents/program/github/note/images/image-20241004201441645.png)

å°±ç›¸å½“äºåˆ†æˆäº†ä¸¤ä¸ªè¡¨

ç”¨pæ¥éå†æ•´ä¸ªé“¾è¡¨çš„æ‰€æœ‰ç»“ç‚¹ï¼ŒræŒ‡é’ˆæŒ‡å‘å¤´ç»“ç‚¹
å¦‚æœä½ ä¸ä¸ºxï¼Œåˆ™æ”¾åˆ°råï¼Œå°±æ˜¯æ’å…¥Lè¿™ä¸ªè¡¨é‡Œ
å¦‚æœä½ ä¸ºxï¼ŒæŠŠä½ é‡Šæ”¾

æœ€åä¸€å¥ä»£ç ä½ ç†è§£ä¸‹ï¼Œr->next =NULL çš„ä½œç”¨æ˜¯ä»€ä¹ˆ

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-04 20.27.44.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 4, 5, 6};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void Delete_x(LinkList &L, ElemType x) {
    LNode *r, *p, *q;
    r = L; // æŒ‡å‘å¤´ç»“ç‚¹ï¼Œä¸€ç›´æŒ‡å‘é“¾è¡¨çš„æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œå°¾æ’æ³•å¿…å¤‡
    p = L->next; // æŒ‡å‘é“¾è¡¨çš„ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œç”¨æ¥éå†æ•´ä¸ªé“¾è¡¨çš„å·¥ä½œæŒ‡é’ˆ
    while (p != NULL) { // éå†æ•´ä¸ªé“¾è¡¨ï¼Œç›´åˆ°ä¸ºNULL
        if (p->data == x) { // å¦‚æœå½“å‰ç»“ç‚¹æ˜¯è¦åˆ é™¤çš„ç»“ç‚¹
            q = p; // qå­˜ç€è¦åˆ é™¤ç»“ç‚¹çš„æŒ‡é’ˆ
            p = p->next; // pæŒ‡é’ˆåç§»ä¸€ä¸ªç»“ç‚¹
            free(q); // åˆ é™¤è¦åˆ é™¤çš„ç»“ç‚¹
        } else {
                // è¿™é‡Œçš„è¿™ç§å†™æ³•å°±ä¸éœ€è¦æœ€åä¸€å¥ä»£ç r->next=NULLäº†
//            q = p->next; //ä¸‹ä¸€è¡Œp->nextè¢«èµ‹å€¼åï¼Œp->nextåçš„ç»“ç‚¹å°±ä¸¢äº†ï¼Œæ‰€ä»¥æ‹¿qå­˜äº†ä¸‹
//            p->next = r->next;
//            r->next = p;
//            r = p;
//            p = q; // åç§»pæŒ‡é’ˆ
          
          
            r->next = p; // é“¾æ¥ä¸åˆ çš„ç»“ç‚¹
            r = p; // å°¾æ’æ³•å¿…å¤‡æŒ‡é’ˆï¼Œä¸€ç›´æŒ‡å‘è¡¨å°¾
            p = p->next; // pæŒ‡é’ˆåç§»ä¸€ä¸ªç»“ç‚¹
        }
    }
    r->next = NULL; // å¦‚æœæœ€åä¸€ä¸ªç»“ç‚¹æ­£å¥½æ˜¯xï¼Œé‚£ä¹ˆå°±ä¼šåˆ é™¤æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆr->nextæ‰€æŒ‡çš„ä½ç½®å°±éœ€è¦èµ‹å€¼ä¸ºNULL
}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L, 4);
    print(L);
    return 0;
}
```

##### 6. ç¼–å†™åœ¨å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨Lä¸­åˆ é™¤å”¯ä¸€ä¸€ä¸ªæœ€å°å€¼ç»“ç‚¹çš„é«˜æ•ˆç®—æ³•

åœ¨å¸¦å¤´èŠ‚ç‚¹çš„é“¾è¡¨é‡Œåˆ é™¤ä¸€ä¸ªå€¼æœ€å°çš„ã€‚
åˆ é™¤å€¼æœ€å°çš„è¯ï¼Œ
æˆ‘å°±è¦å»éå†æ•´ä¸ªè¡¨ã€‚
ç„¶åæ‰¾å‡ºå®ƒæœ€å°çš„ã€‚
æˆ‘è®©å½“å‰å°±æ˜¯æˆ‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå®ƒçš„å€¼ä¸ºæœ€å°ã€‚å®ƒçš„å€¼ä¸ºæœ€å°çš„è¯ï¼Œæˆ‘å»éå†åé¢ã€‚
åé¢æœ‰æ¯”å½“å‰å€¼æœ€å°çš„ï¼Œé‚£æˆ‘å°±è®©ä»–æ¢è¿‡æ¥ã€‚
æ²¡æœ‰ï¼Œé‚£æˆ‘å°±ç»§ç»­å¾€åèµ°å°±è¡Œäº†ã€‚

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-04 20.57.40.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {81, 4, 122, 12, 32};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void delete_min(LinkList &L) {
    LNode *pre, *p;
    pre = L; // preæŒ‡å‘å…¶å‰é©±
    p = L->next; // pä¸ºå·¥ä½œæŒ‡é’ˆ
    LNode *minPre, *minP; // ä¿å­˜æœ€å°å€¼åŠå…¶å‰é©±ç»“ç‚¹
    minPre = pre;
    minP = p;
    while (p != NULL) {
        if (p->data < minP->data) { // çœ‹å½“å‰çš„ç»“ç‚¹å’Œæˆ‘ä¿å­˜çš„æœ€å°ç»“ç‚¹ï¼Œå¦‚æœå½“å‰ç»“ç‚¹æ›´å°çš„è¯ï¼Œå°±æŠŠå½“å‰ç»“ç‚¹èµ‹å€¼ä¸ºæœ€å°å€¼ç»“ç‚¹
            minP = p;
            minPre = pre;
        }
        pre = p; // å­˜å‚¨å½“å‰ç»“ç‚¹çš„å‰é©±ç»“ç‚¹
        p = p->next; // åç§»ä¸€ä½ç»“ç‚¹
    }
    minPre->next = minP->next; // åˆ é™¤æœ€å°å€¼ç»“ç‚¹
    free(minP);
}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    delete_min(L);
    print(L);
    return 0;
}
```

##### 7.1 ğŸŒŸ ç¼–å†™ç®—æ³•å°†å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨å°±åœ°é€†ç½®

æ³¨æ„æœ‰æ—¶å€™å¯ä»¥å†™åˆ°å¾ªç¯é‡Œçš„æ“ä½œè¦æ”¾åˆ°å¾ªç¯é‡Œ
å³è¾¹çš„ä¸¤ä¸ªæ¡†æ¡†å’Œå·¦è¾¹çš„ä¸€ä¸ªæ¡†æ˜¯ç­‰ä»·çš„

å³è¾¹çš„æƒ…å†µï¼Œå½“qå·²ç»æŒ‡å‘äº†nullçš„æ—¶å€™ï¼Œè¿˜è¦æ‰§è¡Œä¸€æ¬¡q=q->next
ä½†æ˜¯å·¦è¾¹çš„æƒ…å†µï¼Œæ˜¯åªæœ‰på­˜åœ¨ï¼Œæ‰æŒ‡å‘è®©åç§»

![image-20241018190654371](/Users/yuebinghui/Documents/program/github/note/images/image-20241018190654371.png)

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-05 08.51.48.mov"></video>



ä¸Šé¢è§†é¢‘èµ°åˆ°äº†ç¬¬ä¸€ä¸ªwhileå¾ªç¯ç»“æŸ

ä¸‹é¢è¿™ä¸ªè§†é¢‘æ˜¯ç¬¬äºŒä¸ªå¾ªç¯ï¼Œèµ°äº†
r=p->next
p->next=L->next
ä¸‹ä¸€æ­¥åº”è¯¥æ˜¯L->next = p

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-05 08.39.13.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3, 4, 5, 6, 7};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void reverse(LinkList &L) {
    // Læ˜¯å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ï¼Œ
    // ç”¨å¤´æ’æ³•å®ç°é€†åºæ“ä½œ
    LNode *p, *r;
    p = L->next; // p æ˜¯å·¥ä½œæŒ‡é’ˆ ä»ç¬¬ä¸€ä¸ªç»“ç‚¹å¼€å§‹
    L->next = NULL; // é‡ç½®Lçš„å¤´ç»“ç‚¹çš„nextä¸ºNULL
    while (p != NULL) { // éå†æ•´ä¸ªé“¾è¡¨ç›´åˆ°NULL
        r = p->next; //æš‚å­˜pçš„åç»§
        p->next = L->next; // å°†pç»“ç‚¹æ’å…¥åˆ°å¤´ç»“ç‚¹ä¹‹å
        L->next = p;
        p = r; // 
    }
}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    reverse(L);
    print(L);
    return 0;
}
```

##### 7.2 ğŸŒŸä¾æ¬¡éå†çº¿æ€§è¡¨Lï¼Œå¹¶å°†ç»“ç‚¹æŒ‡é’ˆåè½¬

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-05 09.17.50.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3, 4, 5, 6, 7};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void reverse(LinkList &L) {
    LNode *p, *r, *pre;

    p = L->next; // pæŒ‡å‘å¤´ç»“ç‚¹åçš„ç¬¬ä¸€ä¸ªç»“ç‚¹
    r = p->next; // ræŒ‡å‘pçš„åç»§ç»“ç‚¹ æ³¨æ„è¿™ä¸€è¡Œä»£ç å’Œä¸‹ä¸€è¡Œä»£ç ä¸å¯ä»¥è°ƒæ¢é¡ºåºï¼Œä¸ç„¶å…ˆå°±æ°¸è¿œä¸æ‰§è¡Œwhileå¾ªç¯äº†
    p->next = NULL; // å°†ç¬¬ä¸€ä¸ªç»“ç‚¹çš„nexté‡ç½®ä¸ºNULLï¼Œå› ä¸ºé€†ç½®åï¼Œç¬¬ä¸€ä¸ªç»“ç‚¹æ˜¯å°¾èŠ‚ç‚¹

    while (r != NULL) { // rä¸ºç©ºï¼Œè¯´æ˜æ­¤æ—¶pæ˜¯æœ€åä¸€ä¸ªç»“ç‚¹
        pre = p; // å…ˆè®©preåˆ°pçš„ä½ç½®
        p = r; // è®©påç§»ä¸€ä½   
        r = r->next; //  ç„¶åå†è®©råç§»ä¸€ä½ï¼Œæ­¤æ—¶pre p r åˆ†åˆ«ä¾æ¬¡æŒ‰é¡ºåºæŒ‡ç€ä¸€ä¸ªç»“ï¼Œå¹¶ä¸”è¿™ä¸ªå¾ªç¯è¯­å¥å°±æ˜¯å¾ªç¯åšè¿™ä¸ªäº‹æƒ…
      // å¿…é¡»å…ˆåç§»r å†æ‰§è¡Œä¸‹é¢çš„ä»£ç ï¼Œä¸ç„¶å…ˆæ‰§è¡Œä¸‹é¢çš„ä»£ç åï¼Œå› ä¸ºpå’ŒræŒ‡å‘åŒä¸€ä¸ªç»“ç‚¹ï¼Œæ­¤æ—¶ä¸‹é¢å…ˆæ‰§è¡Œçš„è¯ï¼Œå°±ä¼šå¯¼è‡´r=r->nextä¸ä¼šå¾€åéå†ï¼Œè€Œæ˜¯å¾€å‰éå†
        p->next = pre; // è®©pç»“ç‚¹æŒ‡é’ˆæŒ‡å‘preç»“ç‚¹ï¼Œå³æŒ‡å‘å‰é©±ï¼Œè¿™æ ·å°±é€†ç½®äº†é“¾è¡¨
    }

    L->next = p; // æœ€åå½“rä¸ºç©ºçš„æ—¶å€™ï¼ŒpæŒ‡å‘æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œè®©å¤´ç»“ç‚¹æŒ‡å‘på°±å¥½äº†ï¼Œå°±é€†ç½®äº†
}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    reverse(L);
    print(L);
    return 0;
}
```

##### 8. ğŸŒŸæœ‰ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨Lï¼Œè®¾è®¡ä¸€ä¸ªç®—æ³•ä½¿å…¶ç®—æ³•é€’å¢æœ‰åº

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-05 10.18.00.mov"></video>

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-05 10.10.26.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {20, 30, 15, 40, 25};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void sort(LinkList &L) {
    // æœ¬ç®—æ³•é‡‡ç”¨ç›´æ¥æ’å…¥æ’åºç®—æ³•çš„æ€æƒ³ï¼Œå°†å•é“¾è¡¨Lçš„ç»“ç‚¹é‡æ’ï¼Œä½¿å…¶é€’å¢æœ‰åºæ’åˆ—
    LNode *p = L->next; // æŒ‡å‘ç¬¬ä¸€ä¸ªæœ‰æ•°æ®åŸŸçš„ç»“ç‚¹
    LNode *pre; // ç”¨æ¥æŒ‡å‘å¤´ç»“ç‚¹
    LNode *r = p->next; // æŒ‡å‘ç¬¬ä¸€ä¸ªæœ‰æ•°æ®åŸŸçš„ç»“ç‚¹çš„åç»§èŠ‚ç‚¹ ä»¥ä¿è¯ä¸æ–­é“¾

    p->next = NULL; // å› ä¸ºä¸€ä¸ªç»“ç‚¹å¿…å®šæœ‰åºï¼Œè¿™ä¸ªæ˜¯å½“è¿™ä¸ªé“¾è¡¨åªæœ‰ä¸€ä¸ªæ•°æ®ç»“ç‚¹çš„æƒ…å†µ

    // å¦‚æœåªæœ‰ä¸€ä¸ªç»“ç‚¹çš„é“¾è¡¨çš„è¯ï¼Œå¿…ç„¶æœ‰åºï¼Œå¤§äº1ä¸ªç»“ç‚¹çš„é“¾è¡¨çš„è¯ï¼Œå°±è®©påç§»ä¸€ä½
    p = r;

    while (p != NULL) {
        r = p->next; // ä¿å­˜pçš„åç»§ç»“ç‚¹æŒ‡é’ˆ
        pre = L; // æŒ‡å‘å½“å‰æœ‰åºé“¾è¡¨çš„å¤´ç»“ç‚¹ï¼Œä½œä¸ºéå†çš„å·¥ä½œç»“ç‚¹
        // çœ‹æœ‰åºé“¾è¡¨æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œ
        // å¦‚æœæœ‰ä¸‹ä¸ªç»“ç‚¹ï¼Œå°±çœ‹ä¸‹ä¸ªç»“ç‚¹çš„å€¼æ˜¯å¦å°äºå½“å‰çš„pç»“ç‚¹
        while (pre->next != NULL && pre->next->data < p->data) {
            // å¦‚æœæœ‰å¹¶ä¸”å°äºï¼Œé‚£å°±åç§»ä¸€ä½
            // ç›´åˆ°ä¸å°äºæˆ–è€…è¯´éå†å®Œæ•´ä¸ªæœ‰åºé“¾è¡¨
            pre = pre->next;
        }
        // å› ä¸ºèµ°åˆ°è¿™é‡Œçš„pç»“ç‚¹è‚¯å®šæ˜¯å¤§äºpreç»“ç‚¹çš„ï¼Œæ‰€ä»¥è¦æ’åˆ°preå

        // å°†å½“å‰çš„pç»“ç‚¹ï¼Œæ’å…¥åˆ°preçš„åé¢
        p->next = pre->next;
        pre->next = p;

        p = r;// å†æ¬¡è®©pæŒ‡å‘åä¸€ä¸ªç»“ç‚¹ï¼Œå¾ªç¯è¿™ä¸ªæ“ä½œ
    }
}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    sort(L);
    print(L);
    return 0;
}
```

##### 9. è®¾åœ¨ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„æ•°æ®æ— åºï¼Œè¯•ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œåˆ é™¤è¡¨ä¸­æ‰€æœ‰ä»‹äºç»™å®šçš„ä¸¤ä¸ªå€¼ï¼ˆä½œä¸ºå‡½æ•°å‚æ•°ç»™å‡ºï¼‰ä¹‹é—´çš„å…ƒç´ 

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-05 13.56.18.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {25, 10, 7, 15, 30};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void delete_range(LinkList &L, ElemType min, ElemType max) {
    LNode *p = L->next; // æŒ‡å‘ç¬¬ä¸€ä¸ªæœ‰æ•°æ®åŸŸçš„ç»“ç‚¹
    LNode *pre = L; // æŒ‡å‘pçš„å‰é©±
    while (p != NULL) { // éå†æ•´ä¸ªé“¾è¡¨
        if (p->data > min && p->data < max) { // çœ‹æ˜¯å¦åœ¨è¦åˆ é™¤çš„åŒºé—´å†…ï¼Œå¼€åŒºé—´
            pre->next = p->next; // å¦‚æœåœ¨å°±åˆ é™¤è¿™ä¸ªpç»“ç‚¹
            free(p);
            p = pre->next; // è®©påç§»åˆ°preæŒ‡å‘çš„ç»“ç‚¹
        } else {
            // åç§»på’ŒpreæŒ‡é’ˆ
            pre = p;
            p = p->next;
        }
    }

}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    delete_range(L, 8, 17);
    print(L);
    return 0;
}
```

##### 10. ç»™å®šä¸¤ä¸ªå•é“¾è¡¨ï¼Œæ‰¾å‡ºä¸¤ä¸ªé“¾è¡¨çš„å…¬å…±èŠ‚ç‚¹

å…¬å…±ç»“ç‚¹æŒ‡çš„æ˜¯æŒ‡é’ˆåŸŸå’Œæ•°æ®åŸŸéƒ½ä¸€æ ·çš„ç»“ç‚¹

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-05 15.10.55.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}
//
//void no_head_TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void delete_range(LinkList &L, ElemType min, ElemType max) {
    LNode *p = L->next; // æŒ‡å‘ç¬¬ä¸€ä¸ªæœ‰æ•°æ®åŸŸçš„ç»“ç‚¹
    LNode *pre = L; // æŒ‡å‘pçš„å‰é©±
    while (p != NULL) { // éå†æ•´ä¸ªé“¾è¡¨
        if (p->data > min && p->data < max) { // çœ‹æ˜¯å¦åœ¨è¦åˆ é™¤çš„åŒºé—´å†…ï¼Œå¼€åŒºé—´
            pre->next = p->next; // å¦‚æœåœ¨å°±åˆ é™¤è¿™ä¸ªpç»“ç‚¹
            free(p);
            p = pre->next; // è®©påç§»åˆ°preæŒ‡å‘çš„ç»“ç‚¹
        } else {
            // åç§»på’ŒpreæŒ‡é’ˆ
            pre = p;
            p = p->next;
        }
    }

}

void tail_insert(LinkList &L, LinkList addL) {
    LNode *p = L;
    while (p->next != NULL) {
        p = p->next;
    }
    p->next = addL->next;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

LinkList search_common(LinkList L1, LinkList L2) {
    int len1 = Length(L1), len2 = Length(L2), dist; // è®¡ç®—ä¸¤ä¸ªé“¾è¡¨çš„è¡¨é•¿
    LinkList longList, shortList;

    if (len1 > len2) { // çœ‹å“ªä¸ªé•¿å°±ç»™å“ªä¸ªè¡¨èµ‹å€¼ longList
        longList = L1->next;
        shortList = L2->next;
        dist = len1 - len2;
    } else {
        longList = L2->next;
        shortList = L1->next;
        dist = len2 - len1;

    }
    // æŠŠé•¿çš„è¡¨ï¼Œç§»åŠ¨åˆ°å’ŒçŸ­çš„è¡¨å¼€å¤´ä¸€è‡´çš„ä½ç½®
    // è¿™æ ·ä¸‹é¢å°±å¯ä»¥ï¼ŒåŒæ—¶ç§»åŠ¨é•¿çš„å’ŒçŸ­çš„è¡¨çš„æŒ‡é’ˆæ¥çœ‹çœ‹æ˜¯å¦æ˜¯åŒä¸€ä¸ª
    while (dist--) {
        longList = longList->next;
    }

    while (longList != NULL) {
        if (longList == shortList) { //æ‰¾ ç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹
            return longList;
        } else { // å¦‚æœä¸æ˜¯å°±ç»§ç»­æ‰¾
            longList = longList->next;
            shortList = shortList->next;
        }
    }
    return NULL;
}


int main() {
    int A1[] = {1, 2};
    LinkList L1;
    TailInsertList(L1, A1, 2);

    int A2[] = {11, 22, 33};
    LinkList L2;
    TailInsertList(L2, A2, 3);

    int A3[] = {40, 50, 60};
    LinkList L3;
    TailInsertList(L3, A3, 3);

    tail_insert(L1, L3);
    tail_insert(L2, L3);


    print(L1);
    print(L2);
//    print(L3);

    LinkList L4 = search_common(L1, L2);

    no_head_print(L4);

//    printf("length l1 =%d\n", Length(L1));
//    delete_range(L, 8, 17);
//    print(L);
    return 0;
}
```



