<u>设k为执行的次数</u>

来看一下这道题。他问的是时间复杂度。我们最容易想到的做法就是。求出<u>sun加加这条指令执行的次数。执行的次数</u>知道了，时间复杂度也能够得到。它是一个两层循环，两层循环，我们先拆外层的循环。

外层的循环I是从一开始的，那I的取值会有哪些？我们列出来。它每次都是字乘以2 一直乘到最后的。要保证I小于n。
所以I应该是一二。四八等等，一直到二的k次方，它要保证I小于n，所以二的k次方应该是小于n的。<u>这就是外层的取值。</u>

那对于每一个外层的i，j有多少种可能的取值呢？<u>j是从零开始，j小于I。那就是零到i- 1。而j是j加加的，</u>
<u>所以总共会有I个取值。</u>
那对于每一个I都有I个取值，
我们只需要把所有的I相加即可。
I=1的时候加加执行一次
I=2的时候上加加执行两次
I=4的时候上加加执行四次。
所以就是把它们加起来。一直加到二的k次方。

这个应该是很好计算的，就是等比数列。它们求出来应该是二的k+1次方减一。这里我们得到的是k。题目中要求的是和n有关。
<u>注意一下二的k次方是小于n的。</u>
<u>所以二的k+1次方减一应该小于2n。</u>

根据时间复杂度的定义。执行的次数是零到2n之间。根据时间复杂度的定义，那我们就能够得到它的时间复杂度应该是on的。所以这道题就应该选b。

那对于所有的这一类的题，我们最基本的方法都是这样做。求出循环内这条指令执行的次数。从外到内，一层一层拆开循环，先拆外层的循环。看外层的循环有哪些取值。也就是这里的I，然后对于外层循环的取值，求出内层循环可能执行的次数。一定要注意的是。他们不一定都是I加加和j加加的。那本题选择b。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191405926.png" alt="image-20240914191405926" style="zoom:50%;" />

## 循环的时间复杂度总结

指数爆炸(<a href="/Users/yuebinghui/Documents/program/github/note/笔记/数学/周洋鑫/06.1零基础核心考点精讲5-2.md#指数爆炸">指数爆炸</>)

<a id="指数爆炸">指数爆炸</a>

### 每一层循环变量都是++

那接下来给大家介绍一下循环的时间复杂度总结。我把它分为两个类型，第一个类型比较简单，它的特点是每一层循环的变量都是I加加j加加k加加。这样的它可能出两层循环，三层循环，
四层循环都没有关系。只要都是I加加的，而且。这种时候我们可以不需要求出指令执行的次数，可以通过一些技巧直接得到答案。对于这一类问题，我们可以求出I的取值范围。j的取值范围k的取值范围。比如说，对于第一层循环I的取值范围应该是零到n- 1，所以应该是n。j的取值范围也是零到n- 1，应该是n。k的取值范围也是零到n- 1。它也是n。
我们要求的是时间复杂度，而不是具体的执行次数，只需要求出一个大概的范围。把这三个相乘即可。这是很简单的，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191630413.png" alt="image-20240914191630413" style="zoom:50%;" />

而第二种有一些小的区别，它们的区别在什么地方呢？第二种。j是受到I的取值影响的k，又受到j的取值影响零，这样的话，第一层应该是零到n- 1。第二层应该是零到i- 1，第三层应该是零到j- 1。如果按照这样做的话，
我们得到的答案应该是n×I×j。我们可以通过放缩法来进行一个计算。因为I的范围是零到n- 1的，我们取一个最大的值取一个n。把n带入进去。然后j我们也用n代入进去，所以它的答案也是n×n×n也就是n的立方。那对于这一类的问题，我们只要看到它是I加加j加加k加加，然后我们把它的范围看一下。这里j和k的范围虽然都和I和j有关，但是I和j都是小于n的。所以我们放缩的话，都可以把它放缩成n，那就直接每一层都是n，然后相乘即可。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191850617.png" alt="image-20240914191850617" style="zoom:50%;" />

对于第一种类型的两种，虽然它们有一些细节上的不同，但是我们可以发现它的时间复杂度是一样的。我们看到第二种的时候可以直接完全按照第一种的时间复杂度来计算，这就是类型一类型一的话，我们不需要完全求出。每一条指令的具体执行次数，我们要记住的是，它求的是时间复杂度。这样的话，考试就能给我们省下大量的时间，不只是在选择题中，还可以在自己的。是还可以在自己算法的时间复杂度，
估计中。来进行计算。



而第二种类型有一个特点是。它不是一个单纯的I加加和j加加，它是有一些别的变化。它可以是I=I×2，也可以是I=I×I等，等我们要根据具体的题目来讨论I的取值。或者它在第二层j不是j加加可以改成j=j×2等等，我们要根据具体的题目具体分析。而对应的做法就是我们先拆开最外层的讨论，最外层有哪些取值？比如说这里I是一二。四八等等。一直到二的k次方。
而如果这里改成I=I×3呢，那就变成了一三。九，27等等。二，三的k次方。具体的题目要具体的去分析，而不是和类型一一样，可以套一个什么样的东西。一定要注意它的变化，到底是I=I×2还是I加加还是什么什么？这可以有助于我们区分它的类型。这就是两种情况的总结类型，一是我们可以套一个公式，把每一层的最大便利次数相乘即可。
而类型二，我们需要从外到内，一层一层拆开它，一般不会超过两层循环，因为这样计算起来会很麻烦。我们需要做的就是判断清楚它的边界条件，比如说这里I小于n，这里j小于I。然后讨论它每一次循环的过程中，到底是I=I×2，还是I=I加？加一分清楚这些东西，然后再具体的去计算。这就是循环的时间复杂度总结问题。那具体讲解到此结束。