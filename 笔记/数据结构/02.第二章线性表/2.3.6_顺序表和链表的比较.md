各位同学大家好，在这个小节中，我们会对顺序表和链表相关的特性做一个对比，也算是对这个章节的内容做一个总结，那我们之前说过，当我们在聊起一个数据结构的时候，我们应该关注数据结构的三要素。也就是逻辑结构，物理结构，还有数据的运算，所以这个小节的复习我们依然会按照这样的一个思路来对相关的内容分别进行一个回忆。那最后我们还需要探讨在什么时候，我们应该使用顺序表，什么时候又应该使用链表好，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925182336218.png)

首先来看数据元素的第一个要素逻辑结构。其实，
不管是顺序表还是链表，它们在逻辑上看，其实都是线性结构的。也就是说，它们都属于线性表。各个数据元素之间有这样的一对一的关系好，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925182457863.png)

再来看第二个方面，存储结构顺序表是采用了这样顺序存储的方式，实现了这个线性表。那由于采用了顺序存储，并且各个数据元素的大小是相等的，因此我们只需要知道这个顺序表的起始地址，那么我们就可以立即找到第二个元素存放的位置。也就是说，顺序表拥有随机存取的特性，
另一个方面，顺序表当中的各个节点只需要存储数据元素，本身不需要存储其他的融余信息。因此，顺序表的存储密度也会更高。另一个方面，顺序存储的这种呃存储结构要求系统给它分配一整片的连续的存储空间。所以在给顺序表分配空间的时候会比较不方便，并且如果我们想要改变顺序表的容量，也会很不方便。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925182552849.png)

而如果我们采用链表，也就是链式存储的方式来实现这种线性结构的话，那么由于各个节点可以离散的存放在不同的空间当中，所以我们每次要添加一个节点的时候，只需要用MA loc函数。
动态的申请一小片的空间就可以了，同时由于各个节点的存储空间不要求连续，因此改变容量也会方便一些，那链式存储带来的问题是当我们要找到第二个节点的时候，我们只能从第一个。节点表头的这个节点开始依次往后寻找，所以链式存储是不可随机存取的。另外，由于各个节点当中除了存储数据元素之外，还需要花费一定的空间来存储这个指针。所以它的存储密度也会更低一些。那这就是顺序表和链表在存储结构方面的不同点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925182710863.png)

好，接下来再来看数据结构的第三个要素，也就是基本操作或者说基本运算，
我们用之前提到的这种思路来依次回忆。对于任何一个数据结构的基本操作，最重要的无非就是这样的几种。创销增删改查。首先，你得知道如何初始化，也就是如何创建一个数据结构，还需要知道如何销毁一个数据结构，那如何销毁这个问题。其实，在考研当中考察的并不多，但是我们实际写代码的时候。销毁数据结构相关的基本操作肯定也是十分重要的，那在之前的课程内容当中，我们着重强调的是如何创建，
如何初始化，然后如何增加一个元素，如何删除一个元素和如何查找一个元素。如何更改一个数据元素，其实很简单，只要你能查到，你想要更改的那个数据元素，那么要更改这个数据元素的值，无非就是一个赋值操作，所以增删改查的改，我们之前一直都没有聊。那销毁操作，我们之前强调的也不是特别多，一会儿我们会快速的带过一下，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925183030693.png)

好接下来我们按照这样的思路来依次回忆，
首先来看一下，当我们创建，也就是当我们初始化一个顺序表。或者初始化一个链表的时候，需要做的事情有什么不同？由于顺序表要求给它分配的是这样的一整片的连续空间。所以，当我们在初始化一个顺序表的时候，我们就需要给这个顺序表预分配大片的连续空间。那如果刚开始给它分配的空间太小，那我们之后想要拓展这个顺序表的长度会很不容易，而如果我们刚开始给它分配的空间过大的话，那么又会有大量的空间是。长时间处于空闲的状态，也就是会导致内存资源的利用率不高，
浪费内存这样的一个现象。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925183217856.png)

而对于链表来说，当我们在初始化，也就是当我们在创建一个链表的时候，其实只需要声明一个头指针，并且分配一个。头结点所需要的空间就可以了，当然我们也可以让这个链表没有头结点，那无论是有头结点还是没有头结点，对于一个链表来说，当它之后想要拓展这个链表的容量的时候，其实很方便的。每次需要拓展的时候，只需要用my lock再申请一小片新的空间，然后再用指针的方式把它连到这个链表里面就可以了。
所以对于存储容量的弹性或者说灵活性肯定是链表会更胜一筹，如果我们的顺序表是采用静态分配的方式实现的话，那么我们顺序表的这个容量就是不可更改的。而即便顺序表采用动态分配的方式来实现，虽然它的容量可以更改，但是更改它的容量也需要移动大量的元素，所以时间代价也会很高。因此，从顺序表和链表的创建，这个基本操作出发，我们可以联想到的是关于存储空间的灵活性方面的问题。在这个方面，显然链表是更胜一筹的。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925183443914.png)

好，接下来要回忆的是，
销毁操作，先来看链表。其实我们在聊链表的基本操作的时候，我们是不是聊过如何删除链表当中的某一个节点？那如果要销毁一个链表的话，那无非就是把链表当中的各个节点都依次的删除，所以对链表的销毁操作，它的核心其实就是一个free函数。你可以写一个循环，然后依次扫描各个节点，把各个节点都给free掉，这样的话就可以把链表占用的这些节点空间都依次回收。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925183542213.png)

那对于顺序表来说，如果你觉得它之后没用了，需要销毁，
那首先你需要把它length值改为零，也就是表示这个顺序表当前已经变成了一个空表。那这一步操作只是在逻辑上把这个顺序表把它标记为了一个空表，但是顺序表它所占用的这片存储空间应该怎么回收呢？分两种情况，如果说你的顺序表是用静态分配的方式实现的话，那么也就意味着你的顺序表所占用的这片存储空间是你通过啊，声明一个静态数组的方式。来请求系统分配的，那在这种情况下，这片存储空间的回收是由系统自动进行的，当你定义的这个静态数组，它的生命周期结束之后，系统会自动的把这片空间给回收。也就是说，
如果你采用的是静态分配的方式，那么对于空间回收的问题，你是不需要管的，你只需要把lens的值改为零就可以了。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925183804871.png)

那如果你采用的是动态分配的方式，也就是说你的这个动态数组是用m look函数申请的一片空间。那在这种情况下，你就需要手动的把这片空间给free掉，由mellow函数申请的内存空间是属于内存当中的堆区。在堆区的内存空间不会由系统自动的回收，也就说在你实际写代码的时候啊，你的程序里边MA lock和free这两个函数肯定是成对出现的。对于链表也是一样，任何一个节点，我们都是用malloc函数来申请的，
所以当我们销毁这个链表的时候，也相应的需要对每一个节点执行free操作。那什么叫内存中的堆区？什么叫内存中的占区？这些我们现在暂时不展开，在这儿大家只需要记住这样一个结论，你用my lock申请的空间肯定需要你手动的free。而如果你用声明一个数组或者声明一个变量，这样的方式申请的内存空间会由系统自动的帮你完成回收工作，你不需要管。好，这是顺序表和链表的销毁操作，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925184135622.png)

那接下来我们需要回忆的是增删改查对吧？那按照顺序，我们首先来看增加或者说插入一个数据元素和删除一个数据元素。
那插入和删除这两个操作，它们之间的联系比较紧密，所以把它们放在一起来回忆，首先来回忆一下顺序表的插入和删除，需要做的是什么事？那这就需要联系到它的存储特性，

那由于顺序存储，这样的存储结构要求各个数据元素在内存里边是相邻的，并且是有序的。所以当我们在插入和删除一个数据元素的时候，都需要把我们此次插入的这个位置之后的那些元素都给后移或者前移，如果插入一个元素的话，那么就需要后移，如果删除一个元素。元素的话就需要前移，

而相比之下，对于链表的插入和删除就会更简单一些，我们只需要修改相应的指针就可以。不需要像顺序表那样大量的移动元素的存储位置，

对于顺序表来说，插入和删除这两个操作的最坏时间复杂度和平均时间复杂度都是on这个数量级。这个时间开销主要是来自于移动元素所需要的时间开销，

那链表的插入和删除它的时间复杂度也是on，不过链表的这个时间开销主要是来自于查找目标元素。就是你需要从第一个元素开始，依次往后寻找，直到找到你想要插入的那个位置，或者找到你想要删除的那个数据结点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925184732404.png)

那从这个角度来看，虽然说啊，
顺序表和链表的插入删除它的时间复杂度都是on这个数量级，但是考虑到有的时候我们的这个数据元素，它可能很大。比如说一个数据元素，它就占1M个字节，那么也许你移动这么多的数据，你就需要用十毫秒左右的时间。那如果要移动n个数据元素的话，那所花的这个时间代价其实还是很高的，而对于链表来说，通过一个节点找到下一个节点，这样的时间开销很显然要比这种移动大量的数据所带来的时间。开销要更短很多，比如说假设每往后找一个节点，只需要花一微秒的时间，
那么即便往后找n个节点，所需要花费的时间很显然也远小于。移动元素所带来的时间开销，所以虽然说从大o表示法这样的角度来看，顺序表和链表的插入删除它们的时间复杂度都是on这样的一个数量级。但是当我们结合考虑一些现实因素的时候，不难发现，其实对于插入一个数据元素或者删除一个数据元素这样的基本操作来说，链表的效率。肯定要比顺序表要高得多

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925185010715.png)

好，那这是增删这两个基本操作，接下来看的是查找操作，那我们在学习这个章节的时候查找操作，我们探讨过按位查找和按值查找。对于顺序表来说，
你想要找到某一个位序的元素，所存放的位置只需要o1的时间，复杂度，也就是说它具有随机存取的特性。

而链表只能从第一个元素开始，依次往后查找，所以它的按位查找时间复杂度是on这些数量级，

那对于按值查找这些操作来说，如果顺序表当中各个数据元素的排列。本来就是无序的，那么我们就只能从第一个元素开始，依次往后对比，所以时间复杂度是on这个数量级，而如果说这个顺序表中的元素，它是有序的。
那我们就可以用一些查找算法，比如说像折半查找这样的算法，可以在log n这样的时间复杂度内就可以找到目标元素。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925185146612.png)

那对于链表来说，无论它里面的这些数据元素是有序还是无序，当我们在进行按值查找的时候，都只能从第一个元素开始，依次往后遍历。所以，无论数据元素，它有序还是无序啊，在链表当中按值查找，肯定都是on这样的时间复杂度。所以对于查找相关的操作肯定顺序表的效率会高很多，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925185312993.png)

好，
那最后根据顺序表和链表各自不同的特性，我们就可以知道什么时候应该使用顺序表，什么时候应该使用链表。如果在你的应用场景当中，你的线性表表长难以估计，并且经常会使用插入和删除这样的基本操作的话，那很显然使用链表会让你更开心一些。比如你要开发一个小程序，这个小程序是要让奶茶店实现排队取号或者叫号，这样的功能。那你是不是很难估计你的这个店里边到底会有多少顾客来取号，同时当有一个新顾客取号的时候，你就需要增加一个数据元素。当一个顾客取到餐之后，你就需要删除一个数据元素，
所以在这种应用场景下，使用链表肯定是很合适的。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925185408256.png)

那相反，如果你的应用场景当中，你的线性表的表长是可预估的，比较稳定的，并且查询操作会比较多，那你用顺序表的方式来实现，肯定会效率更高。比如说让你开发一个小程序，用于实现课堂上呃学生点名，这样的事情，那我们知道每一个班级的学生基本上就是固定的。在一个学期之内，基本上一个班里边有几个学生，
这个事情是可以预估的，基本不会改变的。而你要实现课堂点名这样的功能的话，那很显然就是需要搜索或者说需要查询这个表里边各个数据元素嘛。那在这种情况下，你用顺序表来实现，肯定会有更好的效率。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925185503088.png)

好的，那这个小节中我们用数据元素的三要素作为我们总体的思路地图，对顺序表和链表相关的内容进行了一个回顾和对比。当大家在考试的时候，遇到一些开放性的问题，其实也可以用这样的思路来让自己的这个答题逻辑更加清晰。现在有很多自主命题的学校都喜欢考察这种简答题，并且分值还不低，
所以如果你在考卷当中遇到一个题目，一个简答题，它占六分。那你答题的时候，这个逻辑的清晰度其实就很重要了，就比如说你可以像我们刚才说的那种，你可以先探讨一下逻辑结构。这个方面来看是怎么样的，然后存储结构方面来看是怎么样的，然后最后再探讨一些比较重要的呃，基本操作。它的实现效率又分别是什么样的？最终再得出结论，到底是顺序表好还是链表好？那在这个地方，
想给大家强调的就是这种框架性的思维。我们很多理科生其实很怕遇到这种开放式的问题，都不知道从哪儿答起。但是如果你的脑子里边有这样的一个。思路的导航地图，那么当你在面对这种开放式的问题的时候，你的答题思路就会比别人更清晰很多，你的分数肯定也会比你的对手更好。也不是说所有的这些东西都需要答上去，但是至少你可以根据这样的思路来回忆，来分析，然后你自己再来决定到底要把哪些内容给答上去。你的思路是清晰的，那除了答题有用之外，这种框架性的思维其实也有助于大家自己回忆复习。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240925185715249.png)

好的，那第二章的学习到此结束，希望大家不要急着进入第三章的学习，先把我们的课后习题都给做一做。一定要把基础打牢好的，那么以上就是这个小节的全部内容。