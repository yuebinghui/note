各位同学大家好，在这个小节中我们会学习循环链表，其实就是在单链表和双链表的基础上加一个小小的改进，然后就变成了。相对应的循环单链表和循环双链表，所以这个小节的内容其实十分简单，看一个图就明白了，之前我们学习的单链表，它最后一个节点的next指针是。是指向null，但是循环单链表当中最后一个结点的next指针是指回了这个头结点，那这个很好理解。



那我们需要注意的是，在我们初始化一个循环单链表的时候，我们需要把头结点的next指针指向头结点它自己。那相应的，
如果要判断它是否为空的话，你只需要检查它的头结点的next指针是否，是指向它自己就可以了。相比之下，我们之前学习的普通的单链表，当它为空的时候，头结点的next指针是指向空的，也就指向null。那刚才也说了，如果这个循环单链表不为空的话，就需要把最后一个结点的next指针指向头结点。那相应的，如果你要判断某一个结点p，它是否是循环单链表的表尾结点的话，你只需要看一下这个p结点的下一个结点是否是头结点？
所以当大家写代码遍历这个循环单链表的时候，判断这个扫描指针p是否到达表尾的条件和普通的单链表，也是有一些不一样。相信这些都不难理解，那之前我们提到过，对于一个普通的单链表，如果说给你一个结点p，那么其实你只能知道这个结点p后续的这些结点。对于它前面的这些结点是什么情况，那你是不可知的，除非你也能获得头结点的指针，但是对于循环单链表来说，只要给你一个结点p，那你肯定可以找到。整个循环单链表当中的任意一个结点。
那这种特性还是有一些作用的，比如之前我们说过，如果现在要让你实现一个功能，让你删除节点p，那删除这个节点之后肯定需要修改它的前驱节点的。next指针，但是对于这种普通的单链表，你只知道结点p的指针，你肯定找不到它的前驱节点。而对于循环单链表来说，你可以顺着这条链依次往后找，然后直到找到此次要删除的结点p，它的前驱节点，然后修改它前驱节点的next指针。这样的话就可以完成删除结点p的工作。
所以可以循环遍历各个节点，这个特性还是有一些作用的好，那之前我们在讲单链表的时候呃，大家应该有体会，很多时候我们对链表的操作都是在链表的头部或者链表的尾部。比如说我们之前提到的用头插法，建立链表或者用尾插法，建立链表好，那如果这个单链表它是普通的单链表，也就是最后一个结点它。它的next指针是指向none的话，此时如果我们只知道这个链表的头结点的话，那么要从头结点开始，找到最后一个表尾的结点，我们只能写一个循环，
依次往后扫描。直到找到最后一个结点，所以找到最后一个结点的时间复杂度是on这个数量级，而对于循环单链表来说，如果我们让这个单链表的指针l。不是指向头结点，而是指向尾部的这个结点，那么从这个尾结点出发，找到头结点，只需要o1的复杂度，因为只要往后找一个结点就可以了。而由于l这个指针是指向尾部的，所以当我们需要对链表的尾部进行操作的时候，也可以在o1的时间复杂度内就直接找到我们要操作的那个位置。而不需要像刚才说的这样，
从头往后依次循环遍历。所以如果在你的应用场景当中，需要经常对表头或者表尾进行操作的话，那么当你使用循环单链表的时候，你可以让你的这个呃单链表的指针l。让它指向最表尾的这个元素，当然如果你要这么做的话，当你在表尾插入和删除一个元素的时候，就需要修改这个指针l的指向。那这儿就不再展开好，那接下来要看的是循环双链表，其实循环双链表也很简单，表尾结点的next指针，它会指向这个头结点。然后头结点的prior指针，
它又会指向尾结点，也就是说所有的这些next指针，它其实是形成了一个闭环，一个循环。而所有的这些prior指针，它也形成了另外一个方向的闭环循环，那这就是循环双链表。那当我们在初始化一个空的循环双链表的时候，我们需要让这个头结点的前指针和后指针都指向头结点自己。而普通的双链表，它们都是指向n对吧？所以循环双链表的判空也有一点点区别，就是判断此刻这个头结点的next指针是。是否是指向了它自身？如果满足这个条件的话，
那么说明此时这个循环双链表，它是一个空表，就return一个true。而对于循环双链表，它的最后一个结点的next指针是指向了头结点，所以当我们在判断一个结点p它是不是循环双链表表尾结点的时候。啊，判断的条件应该是这个结点的next指针是否指向了头结点，如果满足的话，那么说明这个结点它就是尾部的结点。那按照这个逻辑，当循环双链表为空表的时候，呃，这个头结点它的next指针也是指向了头结点本身。所以这个头结点，
它既是第一个结点，也是最后一个结点，我们这儿的逻辑依然是正确的，好，接下来看一下循环双链表和普通的双链表，它们在实现基本操作的时候有哪些区别？那之前我们提到过课本当中给了这样的一小段代码，这段代码实现了在结点p之后插入一个结点s。如果用这小段代码处理这种普通的双链表的话，当p结点，它刚好是表尾结点的时候。第二句代码的执行会出现错误，因为p结点它没有后继结点，所以我们就无法修改所谓的它的后继结点的前向指针。但如果我们用的是循环双链表的话，
那这个逻辑其实就是正确的。因为即便p结点，它是表尾的最后一个结点，但是它的next指针依然是非空的，这个指针指向了头结点。当我们插入一个新结点的时候，把这个头结点的prior也就是前向指针，让它指向这个新的结点，其实是没有问题的。这小段代码大家可以自己捋一捋。那对双链表的删除也是一样的，我们之前也提到过课本当中给的这小段代码，第二句其实是有一点点问题的，如果说我们此次要删除的结点q，它刚好是最后一个结点的话。
那么和刚才一样q结点没有它的后继结点，所以在执行第二句代码的时候就会出现一个空指针的错误。而如果使用的是循环双链表的话，第一句代码首先会把p结点的next指针指向q结点的next，也就是指向这个头结点的位置。接下来第二句，它会把q结点的next也就是这个头结点，它的prior指针前向指针指向p结点。也就是变成这样。最后第三句，再把q结点给释放掉，所以如果采用循环双链表的话，那课本当中给的这一小段代码逻辑就是没有问题的。好的，那这个小节的内容很简单，
所谓循环单链表，其实就是把单链表当中最后一个元素的next指针指向头节点。所以，当循环单链表为空的时候，就有点像是你单手抱住了空虚的自己。而对于循环双链表来说，当它为空的时候，头结点的后向指针和前向指针都是指向了它自己。就像你用双手抱住了空虚的自己，而对于普通双链表来说，当表为空的时候，它的前向指针和后向指针都是指向null的，所以。所以就有点像是这个样子。那到这儿我们就学完了，
所有的用指针实现的链表，不管是对单链表，双链表，还是这儿提到的循环链表，大家在写这些链表的具体代码的时候都需要关注这样的几个方面。首先是怎么判断呃一个表，它是否为空，你知道一个空表的状态，你是不是就可以知道这个表应该怎么初始化？另外，还可以思考怎么判断一个结点p，它是表尾的结点还是表头的结点。当你知道这个条件怎么判断之后，你是不是就可以知道你怎么写前向便利和后向便利了？因为所有的这些链表它都不具备随机访问的特性，
所以当你要寻找其中的某一个节点的时候，核心肯定都是要实现一个便利的逻辑。也就是一个while循环而while循环，停在什么地方，其实无非就是停在表头或者停在表尾，然后最后大家再尝试插入或者删除一个结点的时候。可以考虑，如果你此次插入或者删除的这个节点，它在表头需不需要特殊的处理，在表中应该怎么处理，在表尾的时候又是否需要特殊的处理？当你考虑到所有的这三种情况的时候，你基本上就可以覆盖那些比较容易出错的边界条件了，所以这是所有的链表都值得关注的一些代码的问题。好的，
那以上就是这个小节的全部内容。