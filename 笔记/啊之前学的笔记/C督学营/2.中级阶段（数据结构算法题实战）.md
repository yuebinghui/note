

## 顺序表

### 初始化

### 插入

### 删除

### 查找

```c++
#include <stdio.h>

#define MaxSize 10
typedef int ElemType;
typedef struct {
    ElemType data[MaxSize];
    int length;
} SqList;


void InitList(SqList &L) {
    L.length = 0;
}


// 顺序表 插入非法L.length就+1
// 插入倒叙往后移 j = L.length; j >= i; j--

// 顺序表 删除非法L.length
// 删除正序往前移 j = i; j < L.length; ++j
bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) { // i>L.length是因为你比如空数组，你i可以是1，表明插入第一个位置，但是你i不可以是2，这样就跨了一个位置相当于1是空的
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }

    for (int j = L.length; j >= i; j--) { // 注意插入是把元素往后移动
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

bool DeleteList(SqList &L, int i, ElemType &e) {
    if (i < 1 || i > L.length) { // 删除的位置不合法
        return false;
    }
    e = L.data[i - 1];

    for (int j = i; j < L.length; ++j) {
        L.data[j - 1] = L.data[j];
    }
    L.length--;
    return true;
}

int LocateElem(SqList L, ElemType e) {
    int i;
    for (i = 0; i < L.length; ++i) {
        if (L.data[i] == e) {
            return i + 1;
        }
    }
    return 0;
}

int main() {
    SqList L;
    InitList(L);

    for (int i = 1; i <= 5; ++i) {
        InsertList(L, i, i * 10);
    }

    int del = 0;
    DeleteList(L, 1, del);

    printf("%d", LocateElem(L, 20));
    return 0;
}
```

## 链表

##### 头插法

只可以从前往后遍历，单链表的起始位置头节点是位置0  ，0是头节点，头节点是不可以被删除的

L是链表的头指针，往第i个位置，插入元素不会改变L，所以不管插到第几个位置L头指针是不会变的，所以插入和删除不需要通过引用的方式

头指针是L，头节点是第一次用malloc创建的结构体节点

头部插入简单版

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;
//LNode*是结构体指针，和LinkList完全等价的

void ListHeadInsert(LinkList &L) {
  // malloc那里申请地址申请的是结构体大小的地址，所以填入LNode，而不是LNode\*或者LinkList
    L = (LNode *) malloc(sizeof(LNode)); // 头节点
    L->next = NULL;
    int x;
    LNode *s;//用来指向申请的新结点
    scanf("%d", &x); // ❓为什么这里需要加这个

    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;//s的next指向原本链表的第一个结点
        L->next = s;//头结点的next，指向新结点
        scanf("%d", &x);
    }

}

void PrintList(LinkList L) {
    L = L->next;
    while (L != NULL) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n");
}
//头插法来新建链表
int main() {
    LinkList L; //L是链表头指针，是结构体指针类型
    ListHeadInsert(L);//输入数据可以为3 4 5 6 7 9999,头插法新建链表
    PrintList(L);//链表打印
    return 0;
}
```

![image-20230822210832944](/Users/yuebinghui/Documents/program/github/note/images/image-20230822210832944.png)

##### 尾插法

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void ListHeadInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
//    L->next = NULL; // ⚠️这个好像可有可无
    int x;
    scanf("%d", &x);
    LNode *s, *r = L; // s是用来指向申请的新节点，r始终指向链表的尾部
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode)); // 为新节点申请空间
        s->data = x;
        r->next = s; // 给尾节点的next属性赋值 新节点地址
        r = s;//r指向新的尾部
        scanf("%d", &x);
    }
    r->next = NULL; // 让尾节点的next为NULL
}

void PrintList(LinkList L) {
    L = L->next;
    while (L != NULL) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n");
}

int main() {
    LinkList L;
    ListHeadInsert(L);
    PrintList(L);
    return 0;
}
```

![image-20230823165306926](/Users/yuebinghui/Documents/program/github/note/images/image-20230823165306926.png)

###### 按值查找 LocateElem

###### 按位查找 GetElem

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void ListHeadInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
//    L->next = NULL; // ⚠️这个好像可有可无
    int x;
    scanf("%d", &x);
    LNode *s, *r = L; // s是用来指向申请的新节点，r始终指向链表的尾部
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode)); // 为新节点申请空间
        s->data = x;
        r->next = s; // 给尾节点的next属性赋值 新节点地址
        r = s;//r指向新的尾部
        scanf("%d", &x);
    }
    r->next = NULL; // 让尾节点的next为NULL
}

void PrintList(LinkList L) {
    L = L->next;
    while (L != NULL) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n");
}

// 按位查找
LNode *GetElem(LinkList L, int SearchPos) {
    if (SearchPos < 0) {
        return NULL;
    }
    int i = 0;
    while (L && i < SearchPos) {
        L = L->next;
        i++;
    }
    return L;
}

// 按值查找
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}

int main() {
    LinkList L;
    ListHeadInsert(L);
    PrintList(L);
    LNode *p = GetElem(L, 2);
    p = LocateElem(L, 999);
    if (p != NULL) {
        printf("%d", p->data);
    }
    return 0;
}
```

###### 插入单个元素操作 ListHeadInsert

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void ListHeadInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
//    L->next = NULL; // ⚠️这个好像可有可无
    int x;
    scanf("%d", &x);
    LNode *s, *r = L; // s是用来指向申请的新节点，r始终指向链表的尾部
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode)); // 为新节点申请空间
        s->data = x;
        r->next = s; // 给尾节点的next属性赋值 新节点地址
        r = s;//r指向新的尾部
        scanf("%d", &x);
    }
    r->next = NULL; // 让尾节点的next为NULL
}

void PrintList(LinkList L) {
    L = L->next;
    while (L != NULL) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n");
}

// 按位查找
LNode *GetElem(LinkList L, int SearchPos) {
    if (SearchPos < 0) {
        return NULL;
    }
    int i = 0;
    while (L && i < SearchPos) {
        L = L->next;
        i++;
    }
    return L;
}


// 按值查找
LNode *LocateElem(LinkList L, int element) {
    while (L) { // 和L !== NULL一致的，寓意就是只要为真就一直循环
        if (L->data == element) {
            return L;
        }
        L = L->next;
    }
    return NULL;
}
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}

// 链表中插入元素
bool ListFrontInsert(LinkList &L, int pos, int InsertVal) {
    LNode *p = GetElem(L, pos - 1);
    // 容错
    if (p == NULL) {
        return false;
    }
    LNode *q;
    q = (LNode *) malloc(sizeof(LNode));
    q->data = InsertVal;
    q->next = p->next;
    p->next = q;
    return true;
}

int main() {
    LinkList L;
    ListHeadInsert(L);
//    LNode *p = GetElem(L, 2);
//    p = LocateElem(L, 999);
//    if (p != NULL) {
//        printf("%d", p->data);
//    }
    ListFrontInsert(L, 4, 99);
    PrintList(L);
    return 0;
}
```

###### 删除元素操作 ListDelete

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

LNode *GetElem(LinkList L, int SearchPos);

void ListHeadFrontInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    L->next = NULL;

    int x;
    scanf("%d", &x);

    LNode *s;
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;
        L->next = s;
        scanf("%d", &x);
    }
}

void ListHeadTailInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    L->next = NULL;

    LNode *s, *r = L;
    int x;
    scanf("%d", &x);

    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL;
}

void PrintList(LinkList L) {
    L = L->next;
    while (L) {
        printf("%d", L->data);
        L = L->next;
        if (L) {
            printf(" ");
        }
    }
    printf("\n");
}

// 删除第i个位置的元素
// 删除时L是不会变得，所以不需要加引用
bool ListDelete(LinkList L, int i) {
    LNode *p = GetElem(L, i - 1); // 拿到要删除的前一个节点
    if (NULL == p) { // 容错
        return false;
    }
//    LNode *q = GetElem(L, i);
    LNode *q = p->next; // 这个和👆那句话等同，但还是这句好，这样就可以直接拿到下一个节点了
     if (!q) {
        return false;
    }
    p->next = q->next;
    free(q);
    return true;
}

LNode *GetElem(LinkList L, int SearchPos) {
    if (SearchPos < 0) {
        return NULL;
    }
    int i = 0;
    while (L && i < SearchPos) {
        L = L->next;
        i++;
    }
    return L;
}

LNode *LocateElem(LinkList L, int element) {
    while (L) {
        if (L->data == element) {
            return L;
        }
        L = L->next;
    }
    return NULL;
}
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}

int main() {
    LinkList L;
//    ListHeadFrontInsert(L);
    ListHeadTailInsert(L);
    int p;
    ListDelete(L, 2);
//    LNode *p = LocateElem(L, 99);
//    LNode *p = GetElem(L, 4);

//    printf("%d\n", p);
    PrintList(L);
    return 0;

}
```

##### 链表真题

![image-20230825080530827](/Users/yuebinghui/Documents/program/github/note/images/image-20230825080530827.png)

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void ListTailInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    L->next = NULL;
    int x;
    scanf("%d", &x);
    LNode *s, *r = L;
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL;
}

void PrintList(LinkList L) {
    L = L->next;
    while (L) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n"); 
}

// 找链表中间节点，并设置好L2链表
void findMiddleNode(LinkList L, LinkList &L2) { // L这里不需要引用是因为不需要改变L
    L2 = (LNode *) malloc(sizeof(LNode));
    LNode *ppre, *pcur;
    ppre = pcur = L->next;

    while (pcur) {
        pcur = pcur->next;
        if (NULL == pcur) { // 为了防止pcur为NULL，运行NULL->next程序崩溃
            break;
        }
        pcur = pcur->next;
        if (NULL == pcur) {
            break;
        }
        // 为了使得偶数个，比如a1~a6中，指向a3而不是a4节点，加了上面的判断
        // 因为虽然此时pcur已经为NULL了，但是下面的一行代码还是会执行，所以上面break掉了
        ppre = ppre->next;
    };
    L2->next = ppre->next; // 这里放入ppre会有问题，只有一个值，放入ppre->next才又全部的值
    // 应该可能是因为如果放ppre相当于放了一个节点，而放ppre->next，相当于放了指针，然后就串起来了
  // 放都都是结点，是不过下面这行ppre->next=NULL把后面的next给切断了，所以你只有一个结点
  // 正常你就是要拿ppre->next里面的指针结点呢
    ppre->next = NULL;
}

void reverse(LinkList L2) {
    LNode *r, *s, *t;
    r = L2->next; // 指向第一个指针
    if (NULL == r) { // 判断第一个是否为空，空返回NULL
        return;
    }
    s = r->next;
    if (NULL == s) { // 判断第二个是否为空，空返回NULL
        return;
    }
    t = s->next;
    while (t) {
        s->next = r;

        r = s;
        s = t;
        t = t->next;
    }
    s->next = r;
    L2->next->next = NULL;
    L2->next = s;
}

void merge(LinkList L, LinkList L2) {
    LNode *pcur, *p, *q;
    pcur = L->next; // 这相当于重组后的新链表的指针
    p = pcur->next; // 指向L第二个节点
    q = L2->next;// 指向L1第一个节点

    while (NULL != q && NULL != p) {
        pcur->next = q;//首先把L2里的第一项插到了新链表的第二个位置
        q = q->next; // 然后把L2的q指针后移

        pcur = pcur->next;//把新链表的指针指向新插入的那个节点,pcur永远指向最后一个节点

        pcur->next = p;// 把新插入的节点和L的第二个节点连起来
        p = p->next;// 然后把L的p指针后移

        pcur = pcur->next;//把新链表的指针指向新插入的那个节点,pcur永远指向最后一个节点

    }
    if (NULL != q) {
        pcur->next = q;
    }
    if (NULL != p) {
        pcur->next = p;
    }
    free(L2);
}

int main() {
    LinkList L;
    ListTailInsert(L);
    PrintList(L);
    printf("--------------- ListTailInsert 👆\n");
    LinkList L2 = NULL;
    findMiddleNode(L, L2);
    PrintList(L);
    PrintList(L2);
    printf("--------------- findMiddleNode 👆\n");
    reverse(L2);
    PrintList(L);
    PrintList(L2);
    printf("--------------- reverse 👆\n");
    merge(L, L2);
    PrintList(L);

    return 0;
}
```

![image-20230825080522605](/Users/yuebinghui/Documents/program/github/note/images/image-20230825080522605.png)

![image-20230825145943579](/Users/yuebinghui/Documents/program/github/note/images/image-20230825145943579.png)

![image-20230825145948516](/Users/yuebinghui/Documents/program/github/note/images/image-20230825145948516.png)

![image-20230825153755790](/Users/yuebinghui/Documents/program/github/note/images/image-20230825153755790.png)

![image-20230825153412501](/Users/yuebinghui/Documents/program/github/note/images/image-20230825153412501.png)

<video src="/Users/yuebinghui/Documents/picture/屏幕录制2023-08-25 15.28.09.mov"></video>

第10秒那里是错的，不需要跳到5的上面，而是 直接到了6的上面

到15秒那里走完了一次循环，然后就是循环往复直到循环结束  

## 栈

我们可以用数组实现栈,也可以用链表实现栈,如果用单链表实现栈，实现方法是链表的头插法，入栈时从链表头部插入，出栈时从链表头部删除

```c++
/*
    栈：后进先出/先进后出
    栈顶
    入栈：从栈顶添加一个元素
    出栈：从栈顶删除一个元素
    栈是一个结构体

    s.top = MaxSize-1 和数组索引一致
    栈为空s.top=-1
 */

// 链栈几乎不考

#include <stdio.h>

#define MaxSize 50
#define ElemType int

typedef struct {
    ElemType data[MaxSize];
    int top;
} SqStack;

// InitStack 初始化栈
void InitStack(SqStack &S) {
    S.top = -1;//初始化栈，就是S.top=-1,让栈为空
}

// StackEmpty 栈是否为空
bool StackEmpty(SqStack S) {
    if (-1 == S.top) {
        return true;
    } else {
        return false;
    }
}

// Push 压栈
bool Push(SqStack &S, ElemType x) {
    //判断栈是否满了
    if (S.top == MaxSize - 1) {
        return false;
    }
    S.data[++S.top] = x;//等价于S.top=S.top+1;   S.data[S.top]=x;
    return true;
}

//获取栈顶元素
bool GetTop(SqStack S, ElemType &m) {
    if (StackEmpty(S)) {
        return false;
    }
    m = S.data[S.top];//拿栈顶元素
    return true;
}

// Pop 弹栈
bool Pop(SqStack &S, ElemType &m) {
    if (StackEmpty(S)) {
        return false;
    }
    m = S.data[S.top--];//出栈 后减减等价于 先m=S.data[S.top];S.top=S.top-1;
    return true;
}


int main() {
    SqStack S;
    InitStack(S);
    bool flag;
    flag = StackEmpty(S);
    if (flag) {
        printf("stack is empty\n");
    }
    Push(S, 3);//入栈元素3
    Push(S, 4);//入栈元素4
    Push(S, 5);
    ElemType m;
    flag = GetTop(S, m);//获取栈顶元素
    if (flag) {
        printf("get top %d\n", m);
    }
    flag = Pop(S, m);//弹出栈顶元素
    if (flag) {
        printf("pop element %d\n", m);
    }
    // 虽然结果都是5,但是栈是根据top来的，而不是根据数组里的数据
    return 0;

}
```

## 队列 Queue

存储MaxSize - 1 个元素

受限的线性表

入队：插入元素

出队：删除元素

队头：Front

队尾：Rear

FIFO

先进先出

#### 循环队列

入队一个元素rear+1，出队一个元素front+1

关键字：重复使用

循环队列：循环队列MaxSize是5，但是只可以存4个元素

![image-20231120173445918](/Users/yuebinghui/Documents/program/github/note/images/image-20231120173445918.png)

##### 数组实现

```c++
#include <stdio.h>

#define MaxSize 5
typedef int ElemType;
typedef struct {
    ElemType data[MaxSize];
    int front, rear;
} SqQueue;

void InitQueue(SqQueue &S) {
    S.front = S.rear = 0;
}

bool QueueEmpty(SqQueue S) {
    return S.front == S.rear;
}

bool DeQueue(SqQueue &S, int &DeleteVal) {
    // 如果两个头尾标记相等认为空了，false掉
    if (QueueEmpty(S)) {
        return false;
    }
    // ⚠️ 从头开始出队
    DeleteVal = S.data[S.front]; // 出队当出到这里S.front =3时，说明出完了
    // 执行下面就是4了，然后就进不了这个函数了，因为头尾标记相等了
    S.front = (S.front + 1) % MaxSize;
    return true;
}

bool EnQueue(SqQueue &S, ElemType val) {
    //⚠️ 模运算是高于加减的，所以需要加括号
    // 当走到第4个的时候，再次调用，(4+1)%MaxSize == 0 然后就false掉了，所以只可以加四个
    if ((S.rear + 1) % MaxSize == S.front) {
        return false;
    }
    // 像数组一样，从0开始添加元素
    S.data[S.rear] = val;
    S.rear = (S.rear + 1) % MaxSize;
    return true;
}


int main() {
    SqQueue S;
    InitQueue(S);
    bool ret1 = QueueEmpty(S);
    EnQueue(S, 1);
    EnQueue(S, 2);
    EnQueue(S, 3);
    EnQueue(S, 4);
    bool ret2 = EnQueue(S, 5);
    int val;
    DeQueue(S, val);
    DeQueue(S, val);
    DeQueue(S, val);
    DeQueue(S, val);


    return 0;
}
```

#### 链式队列

```c++
#include <stdio.h>
#include <stdlib.h>

// 用链表实现队列
typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode;

typedef struct {
    LNode *front, *rear; //队头 队尾
} LQueue;

void InitQueue(LQueue &L) {
    L.front = L.rear = (LNode *) malloc(sizeof(LNode));
    L.front->next = NULL;
}

// 入队
void EnQueue(LQueue &L, ElemType val) {
    LNode *p = (LNode *) malloc(sizeof(LNode));
    p->data = val;
    p->next = NULL; // 要让next为NULL
    L.rear->next = p; //尾指针的next指向新申请的空间，因为从尾部入队
    L.rear = p; // rear指向最新的尾部
}

bool DeQueue(LQueue &L, int &DeleteVal) {
    // 只剩下一个表头了就不删了
    if (L.front == L.rear) { // 队列为空
        return false;
    }
    LNode *p = L.front->next; // 拿到第一个节点，存入p
    DeleteVal = p->data; // 获取要出队的元素值
    L.front->next = p->next; // 让p断链
    if (p == L.rear) { // 判断链表里是否只剩下最后一个节点了 因为L.rear始终是指向最后一个节点的 如果为真，说明只有一个了
        L.rear = L.front;
    }
    free(p);
    return true;
}


int main() {
    LQueue L;
    InitQueue(L);
    EnQueue(L, 1);
    EnQueue(L, 2);
    EnQueue(L, 3);
    EnQueue(L, 4);
    EnQueue(L, 5);

    int val;
    DeQueue(L, val);
    DeQueue(L, val);
    DeQueue(L, val);
    DeQueue(L, val);
    return 0;
}
```

##### 链式循环队列真题

![image-20230827171445027](/Users/yuebinghui/Documents/program/github/note/images/image-20230827171445027.png)

<video src="/Users/yuebinghui/Documents/picture/循环队列链表的真题.mov"></video>

```c++
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

void CircleLinkQueue(LinkList &front, LinkList &rear) {
    front = (LinkList) malloc(sizeof(LNode));
    rear = front;
    rear->next = front;
}

void EnQueue(LinkList front, LinkList &rear, ElemType InsertVal) {
    LNode *p;
    if (front == rear->next) { // 满了，需要申请新空间
        rear->data = InsertVal;
        p = (LNode *) malloc(sizeof(LNode));
        rear->next = p;
        p->next = front;
        rear = p;
    } else {
        rear->data = InsertVal;
        rear = rear->next;
    }
}

bool DeQueue(LinkList &front, LinkList rear, ElemType &DeleteVal) {
    if (front == rear) {
        return false;
    }
    DeleteVal = front->data;
    front = front->next;
    return true;
}

int main() {
    LinkList front, rear;
    CircleLinkQueue(front, rear);

    EnQueue(front, rear, 11);
    EnQueue(front, rear, 22);
    EnQueue(front, rear, 33);
    EnQueue(front, rear, 44);
    EnQueue(front, rear, 55);

    int val;
    DeQueue(front, rear, val);
    DeQueue(front, rear, val);
    DeQueue(front, rear, val);
    DeQueue(front, rear, val);
    bool a = DeQueue(front, rear, val);
    bool b = DeQueue(front, rear, val);


    return 0;
}
```

## 树

#### 二叉树🌟🌟

##### 二叉树的链式存储

![image-20230828075514074](/Users/yuebinghui/Documents/program/github/note/images/image-20230828075514074.png)

![image-20230828075525620](/Users/yuebinghui/Documents/program/github/note/images/image-20230828075525620.png)

![image-20230828075532898](/Users/yuebinghui/Documents/program/github/note/images/image-20230828075532898.png)

##### 二叉树层次建树实战

<video src="/Users/yuebinghui/Documents/picture/二叉树层次建树.mov"></video>



![image-20230829162048247](/Users/yuebinghui/Documents/program/github/note/images/image-20230829162048247.png)

##### 前序遍历（深度优先遍历）

##### 中序遍历

##### 后序遍历

<video src="/Users/yuebinghui/Documents/picture/前序后续中序遍历.mov"></video>

![image-20230829172928686](/Users/yuebinghui/Documents/program/github/note/images/image-20230829172928686.png)

```c++
// function.h 定义结构体，头文件

#ifndef UNTITLED_FUNCTION_H
#define UNTITLED_FUNCTION_H

#endif //UNTITLED_FUNCTION_H

#include <stdio.h>
#include <stdlib.h>

typedef char BiTElemType;
typedef struct BiTNode {
    BiTElemType c;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

typedef struct LQueueNode {
    BiTree p;
    struct LQueueNode *next;
} LQueueNode, *LQueue;


```

```c++
// main.c
#include "function.h"

// 前序遍历
void PreOrder(BiTree t) {
    if (NULL != t) {
        printf("%c", t->c);
        PreOrder(t->lchild);
        PreOrder(t->rchild);
    }
}

// 中序遍历
void InOrder(BiTree t) {
    if (NULL != t) {
        InOrder(t->lchild);
        printf("%c", t->c);
        InOrder(t->rchild);
    }
}

// 后序遍历
void PostOrder(BiTree t) {
    if (NULL != t) {
        PostOrder(t->lchild);
        PostOrder(t->rchild);
        printf("%c", t->c);
    }
}

int main() {
    BiTree pnew;//用来指向新申请的树结点
    BiTree tree = NULL;//tree是指向树根的，代表树
    char c;
    LQueue phead = NULL, ptail = NULL, listpnew = NULL, pcur;
    while (scanf("%c", &c)) {
        if (c == '\n') {
            break;//读取到换行就结束
        }
        //calloc申请的空间大小是两个参数直接相乘，并对空间进行初始化，赋值为0
        pnew = (BiTree) calloc(1, sizeof(BiTNode));
        pnew->c = c;
        listpnew = (LQueue) calloc(1, sizeof(LQueueNode));//给队列结点申请空间
        listpnew->p = pnew;
        //如果是树的第一个结点
        if (NULL == tree) {
            tree = pnew;//tree指向树的根结点
            phead = listpnew;//第一个结点即是队列头，也是队列尾
            ptail = listpnew;
            pcur = listpnew;//pcur要指向要进入树的父亲元素
        } else {
            //让元素先入队列
            ptail->next = listpnew;
            ptail = listpnew;
            //接下来把结点放入树中
            if (NULL == pcur->p->lchild) {
                pcur->p->lchild = pnew;//pcur->p左孩子为空，就放入左孩子
            } else if (NULL == pcur->p->rchild) {
                pcur->p->rchild = pnew;//pcur->p右孩子为空，就放入右孩子
                pcur = pcur->next;//当前结点左右孩子都有了，pcur就指向下一个
            }
        }
    }

    //abcdefghij
    // 前序遍历
    PreOrder(tree);
    printf("---------\n");
    // 中序遍历
    InOrder(tree);
    printf("---------\n");
    // 后序遍历
    PostOrder(tree);
    printf("---------\n");
    return 0;
}

```

##### 层次遍历（广度优先遍历）

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231121175044068.png)

```c++
// 头文件
#ifndef INC_1_TREE_FUNCTION_H
#define INC_1_TREE_FUNCTION_H
#include <stdio.h>
#include <stdlib.h>

typedef char BiElemType;
typedef struct BiTNode{
    BiElemType c;//c就是书籍上的data
    struct BiTNode *lchild;
    struct BiTNode *rchild;
}BiTNode,*BiTree;

//tag结构体是辅助队列使用的
typedef struct tag{
    BiTree p;//树的某一个结点的地址值
    struct tag *pnext;
}tag_t,*ptag_t;

//队列的结构体 ！！！这里队列的结构体和tag结构体都是队列，其实可以并用的
typedef BiTree ElemType;
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{
    LinkNode *front,*rear;//链表头 链表尾,也可以称为队头，队尾
}LinkQueue;//先进先出
void InitQueue(LinkQueue &Q);
bool IsEmpty(LinkQueue Q);
void EnQueue(LinkQueue &Q,ElemType x);
bool DeQueue(LinkQueue &Q,ElemType &x);

#endif //INC_1_TREE_FUNCTION_H

```

```c++
//
// queue.cpp 文件 队列
//
#include "function.h"

//队列的初始化，使用的是带头结点的链表来实现的
void InitQueue(LinkQueue &Q)
{
    Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
    Q.front->next=NULL;
}
//判断队列是否为空
bool IsEmpty(LinkQueue Q)
{
    return Q.rear==Q.front;
}
//入队
void EnQueue(LinkQueue &Q,ElemType x)
{
    LinkNode *pnew=(LinkNode*)malloc(sizeof(LinkNode));
    pnew->data=x;
    pnew->next=NULL;//要让next为NULL
    Q.rear->next=pnew;//尾指针的next指向pnew，因为从尾部入队
    Q.rear=pnew;//rear要指向新的尾部
}
//出队
bool DeQueue(LinkQueue &Q,ElemType &x)
{
    if(Q.rear==Q.front)//队列为空
    {
        return false;
    }
    LinkNode* q=Q.front->next;//拿到第一个结点，存入q
    x=q->data;//获取要出队的元素值
    Q.front->next=q->next;//让一个结点断链
    if(Q.rear==q)//链表只剩余一个结点时，被删除后，要改变rear
    {
        Q.rear=Q.front;
    }
    free(q);
    return true;
}

```

```c++
#include "function.h"

//前序遍历，也叫先序遍历，也是深度优先遍历
void PreOrder(BiTree p)
{
    if(p!=NULL)
    {
        printf("%c", p->c);
        PreOrder(p->lchild);//打印左子树
        PreOrder(p->rchild);//打印右子树
    }
}
//中序遍历
void InOrder(BiTree p)
{
    if(p!=NULL)
    {
        InOrder(p->lchild);//打印左子树
        printf("%c", p->c);
        InOrder(p->rchild);//打印右子树
    }
}
//后序遍历
void PostOrder(BiTree p)
{
    if(p!=NULL)
    {
        PostOrder(p->lchild);//打印左子树
        PostOrder(p->rchild);//打印右子树
        printf("%c", p->c);
    }
}

//层序遍历
//层次遍历,层序遍历，广度优先遍历
void LevelOrder(BiTree T)
{
    LinkQueue Q;
    InitQueue(Q);
    BiTree p;//存储出队的结点
    EnQueue(Q,T);//把根入队
    while(!IsEmpty(Q))
    {
        DeQueue(Q,p);
        putchar(p->c);//等价于printf("%c",c);
        if(p->lchild)
        {
            EnQueue(Q,p->lchild);//左孩子不为空，就入队左孩子
        }
        if(p->rchild)
        {
            EnQueue(Q,p->rchild);//右孩子不为空，就入队右孩子
        }
    }
}

int main() {
    BiTree pnew;//用来指向新申请的树结点
    BiTree tree=NULL;//tree是指向树根的，代表树
    char c;
    ptag_t phead=NULL,ptail=NULL,listpnew=NULL,pcur;
    //abcdefghij
    while(scanf("%c",&c))
    {
        if(c=='\n')
        {
            break;//读取到换行就结束
        }
        //calloc申请的空间大小是两个参数直接相乘，并对空间进行初始化，赋值为0
        pnew= (BiTree)calloc(1,sizeof(BiTNode));
        pnew->c=c;
        listpnew= (ptag_t)calloc(1,sizeof(tag_t));//给队列结点申请空间
        listpnew->p=pnew;
        //如果是树的第一个结点
        if(NULL==tree)
        {
            tree=pnew;//tree指向树的根结点
            phead=listpnew;//第一个结点即是队列头，也是队列尾
            ptail=listpnew;
            pcur=listpnew;//pcur要指向要进入树的父亲元素
        }else{
            //让元素先入队列
            ptail->pnext=listpnew;
            ptail=listpnew;
            //接下来把结点放入树中
            if(NULL==pcur->p->lchild)
            {
                pcur->p->lchild=pnew;//pcur->p左孩子为空，就放入左孩子
            }else if(NULL==pcur->p->rchild)
            {
                pcur->p->rchild=pnew;//pcur->p右孩子为空，就放入右孩子
                pcur=pcur->pnext;//当前结点左右孩子都有了，pcur就指向下一个
            }
        }
    }
    printf("--------PreOrder----------\n");//也叫先序遍历，先打印当前结点，打印左孩子，打印右孩子
    PreOrder(tree);
    printf("\n--------InOrder------------\n");//先打印左孩子，打印父亲，打印右孩子
    InOrder(tree);
    printf("\n--------PostOrder------------\n");//先打印左孩子，打印右孩子，最后打印父亲
    PostOrder(tree);
    printf("\n--------LevelOrder------------\n");
    LevelOrder(tree);
    return 0;
}

```

##### 先序遍历真题 2014年

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231121173729500.png)

###### 代码

```c++
// function.h
// Created by yuebinghui on 2023/11/21.
//

#ifndef UNTITLED2_FUNCTION_H
#define UNTITLED2_FUNCTION_H

#endif //UNTITLED2_FUNCTION_H

#include <stdio.h>
#include <stdlib.h>

typedef int BiTElemType;
typedef struct BiTNode {
    BiTElemType c;
    BiTNode *lchild;
    BiTNode *rchild;
} BiTNode, *BiTree;

typedef struct LinkQueueNode {
    BiTree p;
    LinkQueueNode *next;
} LinkQueueNode;
```

```c++
// main.cpp
#include "function.h"

int PreOrder(BiTree T, int deep) {
    // 静态变量，类似于全局变量   只会初始化一次
    // 递归好难。。。。
    static int wpl = 0;
    if (T) {
//        printf("%c", T->c);
        if (T->lchild == NULL && T->rchild == NULL) {
            // 判断是否是叶子结点，叶子结点才计算wpl值
            wpl = wpl + T->c * deep;
        }
        PreOrder(T->lchild, deep + 1);
        PreOrder(T->rchild, deep + 1);
    }
    return wpl;
}


int main() {

    BiTree tree = NULL;
    BiTree treeNew;

    LinkQueueNode *front = NULL, *rear = NULL, *newQueueNode, *cur;


    char c;
    while (scanf("%c", &c)) {
        if (c == '\n') {
            break;;
        }

        treeNew = (BiTree) calloc(1, sizeof(BiTNode));
        treeNew->c = c;

        newQueueNode = (LinkQueueNode *) calloc(1, sizeof(LinkQueueNode));
        newQueueNode->p = treeNew;


        if (NULL == tree) {
            tree = treeNew;
            front = newQueueNode;
            rear = newQueueNode;
            cur = newQueueNode;
        } else {
            rear->next = newQueueNode;
            rear = newQueueNode;

            if (cur->p->lchild == NULL) {
                cur->p->lchild = treeNew;
            } else if (cur->p->rchild == NULL) {
                cur->p->rchild = treeNew;
                cur = cur->next;
            }
        }


        printf("%c\n", c);
    }

    int wpl = PreOrder(tree, 0);
    printf("%d\n", wpl);
// abcdefghij
    return 0;
}
```

## 查找

#### 顺序查找

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123142859693.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef int ElemType;
typedef struct {
    ElemType *data;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int Len) {
    // 申请空间要看申请什么的空间，这里刚刚放 SSTable,你给int 类型的data赋值结构体干鸡毛
    ST.data = (ElemType *) malloc(sizeof(ElemType) * ST.TableLen);
    ST.TableLen = Len + 1;
    srand(time(NULL));
    for (int i = 1; i < ST.TableLen; i++) {
        ST.data[i] = rand() % 100;
    }
}

void PrintSSTable(SSTable ST) {
    for (int i = 1; i < ST.TableLen; i++) {
        printf("%3d", ST.data[i]);
    }
    printf("\n");
}

ElemType SearchPos(SSTable ST, int key) {
    ST.data[0] = key;
    int i;
    for (i = ST.TableLen - 1; key != ST.data[i]; --i);
    return i;
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);
    PrintSSTable(ST);
    int key;
    scanf("%d", &key);
    int pos = SearchPos(ST, key);
    printf("%d", pos);
}
```

#### 折半查找 / 二分查找

动画

https://www.cs.usfca.edu/~galles/visualization/Search.html

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123143127843.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123143415899.png)

![image-20230901155811294](/Users/yuebinghui/Documents/program/github/note/images/image-20230901155811294.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
typedef int ElemType;
typedef struct {
    ElemType* elem;//整型指针
    int TableLen;//存储动态数组里边元素的个数
}SSTable;

//init进行了随机数生成，折半查找我们没有使用哨兵
void ST_Init(SSTable& ST, int len)
{
    ST.TableLen = len;
    ST.elem = (ElemType*)malloc(sizeof(ElemType) * ST.TableLen);
    int i;
    srand(time(NULL));//随机数生成
    for (i = 0; i < ST.TableLen; i++)
    {
        ST.elem[i] = rand() % 100;
    }
}
void ST_print(SSTable ST)
{
    for (int i = 0; i < ST.TableLen; i++)
    {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}
//实现二分查找
int BinarySearch(SSTable L, ElemType key)
{
    int low=0;
    int high=L.TableLen-1;
    int mid;
    while(low<=high)//low<=high，可以让mid既能取到low，也能取到high
    {
        mid=(low+high)/2;
        if(key>L.elem[mid])//如果目标值大于中位数
        {
            low=mid+1;
        } else if(key<L.elem[mid])
        {
            high=mid-1;
        }else{
            return mid;
        }
    }
    return -1;
}
//函数名中存储的是函数的入口地址，也是一个指针，是函数指针类型
//left指针和right指针是指向数组中的任意两个元素
//qsort规定如果left指针指向的值大于right指针指向的值，返回正值，小于，返回负值，相等返回0
int compare(const void *left, const void *right)
{
    return *(int*)left-*(int*)right;
    //return *(ElemType*)right - *(ElemType*)left;//从大到小排序
}
//二分查找
int main() {
    SSTable ST;
    ST_Init(ST,10);//初始化，随机10个元素
    ST_print(ST);
    qsort(ST.elem,ST.TableLen,sizeof(ElemType),compare);//排序
    ST_print(ST);
    ElemType key;
    printf("please input search key:\n");
    scanf("%d",&key);
    int pos=BinarySearch(ST,key);
    if(pos!=-1)
    {
        printf("find key %d\n",pos);
    }else{
        printf("not find\n");
    }
    return 0;
}
```

#### 二叉排序树（二叉查找数）

动画

https://www.cs.usfca.edu/~galles/visualization/BST.html

![](/Users/yuebinghui/Documents/program/github/note/images/image-20230901160833093.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123151003365.png)

```c++
#include <stdio.h>
#include <stdlib.h>


typedef int KeyType;
typedef struct BSTNode{
   KeyType key;
   struct BSTNode *lchild,*rchild;
}BSTNode,*BiTree;

// 王道书上的递归写法，代码简单，但是理解有难度
int BST_Insert1(BiTree &T,KeyType k)
{
    if(NULL==T)
    {  //为新节点申请空间，第一个结点作为树根，后面递归再进入的不是树根，是为叶子结点
        T=(BiTree)malloc(sizeof(BSTNode));
        T->key=k;
        T->lchild=T->rchild=NULL;
        return 1;//代表插入成功
    }
    else if(k==T->key)
        return 0;//发现相同元素，就不插入
    else if(k<T->key)//如果要插入的结点，小于当前结点
        //函数调用结束后，左孩子和原来的父亲会关联起来，巧妙利用了引用机制
        return BST_Insert1(T->lchild,k);
    else
        return BST_Insert1(T->rchild,k);
}

//54,20,66,40,28,79,58
//非递归的创建二叉查找树
int BST_Insert(BiTree& T,KeyType k)
{
    BiTree TreeNew= (BiTree)calloc(1,sizeof(BSTNode));//新结点申请空间
    TreeNew->key=k;//把值放入
    if(NULL==T)//树为空，新结点作为树的根
    {
        T=TreeNew;
        return 1;
    }
    BiTree p=T,parent;//p用来查找树
    while(p)
    {
        parent=p;//parent用来存p的父亲
        if(k>p->key)
        {
            p=p->rchild;
        }else if(k<p->key)
        {
            p=p->lchild;
        }else{
            return 0;//相等的元素不可以放入查找树，考研不会考相等元素放入问题
        }
    }
    //接下来要判断放到父亲的左边还是右边
    if(k>parent->key)//放到父亲右边
    {
        parent->rchild=TreeNew;
    }else{//放到父亲左边
        parent->lchild=TreeNew;
    }
    return 1;
}
//树中不放
void Creat_BST(BiTree& T,KeyType* str,int len)
{
    int i;
    for(i=0;i<len;i++)
    {
        BST_Insert(T,str[i]);//把某一个结点放入二叉查找树
    }
}

void InOrder(BiTree T)
{
    if(T!=NULL)
    {
        InOrder(T->lchild);
        printf("%3d",T->key);
        InOrder(T->rchild);
    }
}

BiTree BST_Search(BiTree T,KeyType k,BiTree &parent)
{
    parent=NULL;
    while(T!=NULL&&k!=T->key)
    {
        parent=T;
        if(k>T->key)
        {
            T=T->rchild;
        }else{
            T=T->lchild;
        }
    }
    return T;
}



//二叉排序树新建，中序遍历，查找
int main() {
    BiTree T=NULL;//树根
    KeyType str[7]={54,20,66,40,28,79,58};//将要进入二叉排序树的元素值
    Creat_BST(T,str,7);
    InOrder(T);//中序遍历二叉查找树是由小到大的
    printf("\n");
    BiTree search,parent;
    search=BST_Search(T,40,parent);
    if(search)
    {
        printf("find key %d\n",search->key);
    }else{
        printf("not find\n");
    }
    return 0;
}
```

#### 二叉排序树删除

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123155808350.png)

```c++
#include <stdio.h>
#include <stdlib.h>


typedef int KeyType;
typedef struct BSTNode{
   KeyType key;
   struct BSTNode *lchild,*rchild;
}BSTNode,*BiTree;

// 王道书上的递归写法，代码简单，但是理解有难度
int BST_Insert1(BiTree &T,KeyType k)
{
    if(NULL==T)
    {  //为新节点申请空间，第一个结点作为树根，后面递归再进入的不是树根，是为叶子结点
        T=(BiTree)malloc(sizeof(BSTNode));
        T->key=k;
        T->lchild=T->rchild=NULL;
        return 1;//代表插入成功
    }
    else if(k==T->key)
        return 0;//发现相同元素，就不插入
    else if(k<T->key)//如果要插入的结点，小于当前结点
        //函数调用结束后，左孩子和原来的父亲会关联起来，巧妙利用了引用机制
        return BST_Insert1(T->lchild,k);
    else
        return BST_Insert1(T->rchild,k);
}

//54,20,66,40,28,79,58
//非递归的创建二叉查找树
int BST_Insert(BiTree& T,KeyType k)
{
    BiTree TreeNew= (BiTree)calloc(1,sizeof(BSTNode));//新结点申请空间
    TreeNew->key=k;//把值放入
    if(NULL==T)//树为空，新结点作为树的根
    {
        T=TreeNew;
        return 1;
    }
    BiTree p=T,parent;//p用来查找树
    while(p)
    {
        parent=p;//parent用来存p的父亲
        if(k>p->key)
        {
            p=p->rchild;
        }else if(k<p->key)
        {
            p=p->lchild;
        }else{
            return 0;//相等的元素不可以放入查找树，考研不会考相等元素放入问题
        }
    }
    //接下来要判断放到父亲的左边还是右边
    if(k>parent->key)//放到父亲右边
    {
        parent->rchild=TreeNew;
    }else{//放到父亲左边
        parent->lchild=TreeNew;
    }
    return 1;
}
//树中不放
void Creat_BST(BiTree& T,KeyType* str,int len)
{
    int i;
    for(i=0;i<len;i++)
    {
        BST_Insert(T,str[i]);//把某一个结点放入二叉查找树
    }
}

void InOrder(BiTree T)
{
    if(T!=NULL)
    {
        InOrder(T->lchild);
        printf("%3d",T->key);
        InOrder(T->rchild);
    }
}

BiTree BST_Search(BiTree T,KeyType k,BiTree &parent)
{
    parent=NULL;
    while(T!=NULL&&k!=T->key)
    {
        parent=T;
        if(k>T->key)
        {
            T=T->rchild;
        }else{
            T=T->lchild;
        }
    }
    return T;
}

//这个书上没有二叉排序树删除代码--考大题没那么高
void DeleteNode(BiTree &root,KeyType x)
{
    if(NULL==root)
    {
        return;
    }
    if(root->key>x)//当前结点大于要删除的结点，往左子树找
    {
        DeleteNode(root->lchild,x);
    }else if(root->key<x)//当前结点小于要删除的结点，往右子树找
    {
        DeleteNode(root->rchild,x);
    }else{//找到了要删除的结点
        if(root->lchild==NULL)//左子树为空，右子树直接顶上去
        {
            BiTree tempNode=root;
            root=root->rchild;
            free(tempNode);
        }else if(root->rchild==NULL)//右子树为空，左子树直接顶上去
        {
            BiTree tempNode=root;
            root=root->lchild;
            free(tempNode);
        }else{//两边都不为空
            //一般的删除策略是左子树的最大数据 或 右子树的最小数据
            // 代替要删除的节点(这里采用查找左子树最大数据来代替，最大数据是左子树的最右结点)
            BiTree tempNode=root->lchild;
            while(tempNode->rchild!=NULL)
            {
                tempNode=tempNode->rchild;
            }
            root->key=tempNode->key;//把tempNode对应的值替换到要删除的值的位置上
            DeleteNode(root->lchild,tempNode->key);//在左子树中找到tempNode的值，把其删除
        }
    }
}

//二叉排序树新建，中序遍历，查找
int main() {
    BiTree T=NULL;//树根
    KeyType str[7]={54,20,66,40,28,79,58};//将要进入二叉排序树的元素值
    Creat_BST(T,str,7);
    InOrder(T);//中序遍历二叉查找树是由小到大的
    printf("\n");
    BiTree search,parent;
    search=BST_Search(T,40,parent);
    if(search)
    {
        printf("find key %d\n",search->key);
    }else{
        printf("not find\n");
    }
    DeleteNode(T,40);//删除某个结点
    InOrder(T);
    printf("\n");
    return 0;
}
```

## 排序

## 交换排序

### 冒泡排序

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123163507500.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}

void Swap(ElemType &a, ElemType &b) {
    int temp = a;
    a = b;
    b = temp;
}

// 64 94 95 79 69 84 18 22 12 78
// 12 64 94 95 79 69 84 18 22 78 外层完成一次循环后，最小值到了最前面
void BubbleSort(int arr[], int len) {
    bool flag;
    for (int i = 0; i < len - 1; ++i) { // i最多访问到8
        flag = false; //元素是否发生交换的标志
        for (int j = len - 1; j > i; j--) {
//            if (arr[j - 1] > arr[j]) { // 把最小的元素放在了前面
            if (arr[j - 1] < arr[j]) { // 把最大的元素放在了前面
                Swap(arr[j - 1], arr[j]);
                flag = true; // 如果这轮for循环没有进入这个if说明全部有序
            }
        }
        if (!flag) { 
            return;// 这里直接结束，return 掉
        }
    }
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    int arr[10] = {0, 22, 55, 33, 77, 44, 88, 99, 66, 11};

    Print(ST);

//    memcpy(ST.elem, arr, sizeof(arr));
    BubbleSort(ST.elem, 10);

//    ST.elem
    Print(ST);

    return 0;
}
```

### 快速排序 🌟

快速排序 partition 函数执行过程

<video src="/Users/yuebinghui/Documents/笔记/数据结构 ❓表示不会的/屏幕录制2023-11-27 13.18.45.mov"></video>

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231126113624693.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}


// pivot
// partition
int partition(ElemType *A, int low, int high) {
    ElemType pivot = A[low]; // 拿最左边的作为分隔值，并且存储下来
    while (low < high) {
        while (low < high && pivot <= A[high]) { // 从后往前遍历找到一个比分隔值小的
            high--;
        }
        A[low] = A[high]; // 把比分隔值小的放到A[low]位置上
        while (low < high && pivot >= A[low]) { // // 从前往后遍历找到一个比分隔值大的
            low++;
        }
        A[high] = A[low]; // 把比分隔值大的放到A[high]位置上，因为刚才A[high]元素已经放到了A[low]位置上
    }
    A[low] = pivot; // 把分隔值放到最后low的位置，如果左边或者右边有元素，刚好左边都比它小，右边都比它大
    return low; // 返回分隔值位置所在的下标
}


// ElemType *A 与 ElemType A[]是等价的 都是一个内存地址
//void QuickSort(ElemType *A, int low, int high) {
void QuickSort(ElemType A[], int low, int high) {
    if (low < high) {
        ElemType pivotIndex = partition(A, low, high); //pivotIndex 用来存分隔值的位置
        QuickSort(A, low, pivotIndex - 1); // 前一半继续递归排好
        QuickSort(A, pivotIndex + 1, high);
    }
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    int arr[10] = { 22, 55, 33, 77, 44, 88, 99, 66, 11};

    Print(ST);

//    memcpy(ST.elem, arr, sizeof(arr));

//    ST.elem
    QuickSort(ST.elem, 0, 9); //注意这个位置是n-1，也就是9，因为函数里取了high的位置，即数组的最后一位
    Print(ST);

    return 0;
}
```

## 插入排序

### 直接插入排序

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}

void InsertSort(ElemType *A, int n) {
// 从1开始 1~n也是执行了n-1次
    for (int i = 1; i < n; ++i) {
        // 只有后面的一个元素比前面的一个元素小，才进入内层循环，因为每一次遍历都是将带排序的元素插入到已经排好序的位置
        if (A[i] < A[i - 1]) {
            // 将第i个元素暂存到temp，即待插入的元素
            int j, temp = A[i];
// 判断i前面那个元素，如果i前面的那个或那些元素比temp大，那么就把他们依次后移
            for (j = i - 1; j >= 0 && A[j] > temp; j--) {
                A[j + 1] = A[j];
            }
            // 最后把temp元素插入到属于它的合适位置
            A[j + 1] = temp;
        }
    }
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    int arr[10] = {22, 55, 33, 77, 44, 88, 99, 66, 11};

//    Print(ST);

    memcpy(ST.elem, arr, sizeof(arr));

//    ST.elem
    InsertSort(ST.elem, 10);

    Print(ST);

    return 0;
}
```

### 折半插入排序

### 希尔排序

## 选择排序

### 简单选择排序

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231127150443296.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}

void Swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

void SelectSort(ElemType *A, int n) {
    int min, i, j;

    for (i = 0; i < n - 1; i++) { //如果n是10，最多 0～8
        min = i;  //认为第i个位置最小
        for (j = i + 1; j < n; j++) { // //如果n是10，最多9
            if (A[j] < A[min]) {
                min = j;
            }
        }
// 遍历完毕，如果找到最小的值的位置后，交换，这样最小值就被放到了第i个位置，即最前面
        if (i != min) {
            Swap(A[i], A[min]);
        }
    }
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    int arr[10] = {0, 22, 55, 33, 77, 44, 88, 99, 66, 11};

//    Print(ST);

    memcpy(ST.elem, arr, sizeof(arr));

//    ST.elem
    SelectSort(ST.elem, 10);

    Print(ST);

    return 0;
}
```

### 堆排序

C语言督学营里老师的代码，课本的代码在笔记里

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}

void Swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

void AdjustDown1(ElemType A[], int k, int len) {
    int dad = k; // 父亲的下标
    int son = k * 2 + 1; // 左孩子的下标

    while (son < len) { // 假如son已经是9了，9<10所以可以进这个循环 因为下标为9的元素需要和和父元素比较
        if (son + 1 < len && A[son] < A[son + 1]) { // 因为一共下标只到9不能son++了，所以加了son + 1 < len 不让进入这个判断，
            // 针对只有左孩子的情况
            son++;
        }
        if (A[son] > A[dad]) { // 如果孩子比父亲大就交换
            Swap(A[son], A[dad]); // 只换了值，但是索引没换
            dad = son; // 然后再把儿子当作父亲，看看它的儿子需要不需要交换
            son = dad * 2 + 1;
        } else { // 不需要直接跳出循环
            break;
        }

    }
}

void HeapSort1(ElemType A[], int len) {
    int i;
    // 这个就是把堆调整为大根堆
    for (i = len / 2 - 1; i >= 0; i--) {
        AdjustDown1(A, i, len); // 堆 需要调整元素的父结点 数组长度
    }
    // 👆已经把元素调整为了大根堆

    Swap(A[0], A[len - 1]); // 第一位和数组的最后一位进行交换

    for (int j = len - 1; j > 1; j--) { // len-1 = 9 j>1 可以执行到2 9~2执行了8次 9个元素交换8次有序，挺合理把 j--每次数组长度-1
        AdjustDown1(A, 0, j);// 将调整剩余元素为大根堆 0传入的是需要调整元素的下标，即父结点下标   j是数组现有的长度
        Swap(A[0], A[j - 1]); // 下标为0的元素值 和 下标为长度-1的即最后一个元素互换位置
    }
}


int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    Print(ST);
    int arr[10] = {3, 87, 2, 93, 78, 56, 61, 38, 12, 40};
    memcpy(ST.elem, arr, sizeof(arr));
// HeapSort(ST.elem, 9); 王道书上0号元素没有参与排序 就是数据是从1开始存的

    HeapSort1(ST.elem, 10); // 数组十个里都存了元素

//    ST.elem
    Print(ST);

    return 0;
}
```

## 归并排序

归并排序是外部排序

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231129151019334.png)

看不懂❓

```c++
#include <stdio.h>

#define N 7
typedef int ElemType;

void Print(ElemType A[]) {
    for (int i = 0; i < N; ++i) {
        printf("%3d", A[i]);
    };
    printf("\n");
}

void Merge(ElemType A[], int low, int mid, int high) {
    static ElemType B[N];
    int i, j, k;
    for (i = low; i <= high; i++) {
        B[i] = A[i];
    }
    k = low;
    for (i = low, j = mid + 1; i <= mid && j <= high;) {
        if (B[i] < A[j]) {
            A[k++] = B[i++];
        } else {
            A[k++] = B[j++];
        }
    }
    while (i <= mid) {
        A[k++] = B[i++];
    }
    while (j <= high) {
        A[k++] = B[j++];
    }
}

void MergeSort(ElemType A[], int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid); // 排序好前一半
        MergeSort(A, mid + 1, high); // 排序好后一半
        Merge(A, low, mid, high); //合并
    }
}

// 归并排序
int main() {
    ElemType A[N] = {49, 38, 65, 97, 76, 13, 27}; // 数组7个元素
    MergeSort(A, 0, 6);
    Print(A);
    return 0;
}
```