概念也要看看，不过后面看把，要记忆的

学姐有王道电子书，可以要下

学习一个题目，最好要会画出它的手动过程，这样你记忆代码逻辑根号记忆

记住length是顺序表当前有多少个元素 maxsize是顺序表可以放多少个元素

第二章所有的代码都要掌握，会写

# 线性表

## 线性表的顺序表示-顺序表

###### 顺序表的初始化和插入

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    return true;
}

// i是位序 从1开始
// 数组下标从0开始
// 比如MaxSize 是10
// 比如要插入的i是3

bool InsertList(SqList &L, int i, ElemType e) {
    // 这里小于1是因为位序从1开始，不能比1小
    /*
        i > L.length+1 是因为比如我数组有5个元素，L.length为5，我索引是 0 1 2 3 4
        比如插入一个100，位序是8，那么如果没有 i > L.length+1 这个条件，就会把100插入到索引为7的位置
        值   1 2 3 4 5 空 空 100 空 空
        索引 0 1 2 3 4 5  6  7   8  9
        就会造成这样的空隙
        所以当一共有5个元素，此时索引是0~4，
        那么你位序最多插入的就是<=L.length的位置，即1 2 3 4 5
        也就是位序大于5就会产生空隙了，就不能插入
     */
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    // 我数组已经满了，就不插入元素了
    if (L.length >= MaxSize) {
        return false;
    }
    // j=L.length 就是第一次执行的时候，先把索引为L.length的位置里放入索引为L.length-1的元素
    for (int j = L.length; j >= i; j--) {
        // 就是把前一个元素数据放到后一个元素里
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    // 插入一个元素后length++
    L.length++;
    return true;
}

int main() {
    SqList L;
    InitList(L);


    return 0;
}
```

###### 将两个有序顺序表合并为一个新的有序顺序表，并由函数值返回结果

就是函数返回类型那里，除了常见的int float bool 还可以返回自己自定义的struct结构类型数据

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927141858410.png" alt="image-20240927141858410" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// 将两个有序顺序表合并为一个新的有序顺序表，并由函数值返回结果
bool Merge(SqList A, SqList B, SqList &C) {
    // 两个表相加的长度不可以大于 C的最大长度，放不下
    if (A.length + B.length > C.maxSize) {                        gt
        return false;
    }
    // i是A的索引 j是B的索引 k是C的索引
    int i = 0, j = 0, k = 0;

    // 1️⃣遍历A 和 B，从0到length，就是遍历整个A或者B 哪个表Length短就先遍历完
    while (i < A.length && j < B.length) {
        // 拿A和B的第一个元素去作比较，哪个小哪个先放入C
        if (A.data[i] <= B.data[j]) {
            // 先把A的第i个元素放到C的k的索引上，然后k++ i++
            C.data[k++] = A.data[i++];
        } else {
            // 先把B的第j个元素放到C的k的索引上，然后k++ j++
            C.data[k++] = B.data[j++];
        }
    }

    /*
     检查看A是否没有遍历完成，没有的话，就把A剩下的数据，都依次放到C中
     下面的两个while循环只会执行其中一个，因为1️⃣处那里的条件就是以A或者B其中一个遍历完成为结束条件的
     */
    while (i < A.length) {
        C.data[k++] = A.data[i++];
    }
    // 检查看B是否没有遍历完成，没有的话，就把B剩下的数据，都依次放到C中
    while (j < B.length) {
        C.data[k++] = B.data[j++];
    }
    // 最后把k赋值给C的length
    C.length = k;
    return true;
}

int main() {
    SqList A;
    InitList(A);

    SqList B;
    InitList(B);

    SqList C;
    InitList(C);

    for (int i = 1, j = 1, k = 1; i <= 10; ++i) {
        if (i % 2 == 1) {
            InsertList(A, j++, i);
        } else {
            InsertList(B, k++, i);
        }
    }

//    print(A);

//    print(B);

    Merge(A, B, C);
    print(C);


    return 0;
}
```



不懂就自己画图理解

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927144014418.png" alt="image-20240927144014418" style="zoom:30%;" />



## 线性表的链式表示-链表