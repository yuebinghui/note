# 线性表的链式表示-链表

## 经验1：注意p->next != null 和 p!=null的区别

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3, 44, 53, 4};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}

// 代码解释请看上条
void Delete_x(LinkList &L, ElemType x) {
    LNode *pre, *p, *q;
    p = L->next;

    while (p->next != NULL) {
        printf("p->next = %d\n", p->data);
        p = p->next;
    }

    p = L->next;
    while (p != NULL) {
        printf("p = %d\n", p->data);
        p = p->next;
    }

}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L, 4);
    print(L);
    return 0;
}
```



##### 头结点和头指针的关系

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20241004110258475.png" alt="image-20241004110258475" style="zoom:45%;" />

##### 插入节点操作

![image-20241004125543587](/Users/yuebinghui/Documents/program/github/note/images/image-20241004125543587.png)

![image-20241004125606015](/Users/yuebinghui/Documents/program/github/note/images/image-20241004125606015.png)

##### 删除结点操作

![image-20241004130723638](/Users/yuebinghui/Documents/program/github/note/images/image-20241004130723638.png)

![image-20241004130739882](/Users/yuebinghui/Documents/program/github/note/images/image-20241004130739882.png)

##### 采用头插法建立单链表

![image-20241004131156196](/Users/yuebinghui/Documents/program/github/note/images/image-20241004131156196.png)

##### 采用尾巴插法建立单链表

![image-20241004131251253](/Users/yuebinghui/Documents/program/github/note/images/image-20241004131251253.png)

##### 1. 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点

![image-20241004150657842](/Users/yuebinghui/Documents/program/github/note/images/image-20241004150657842.png)

![image-20241004150735371](/Users/yuebinghui/Documents/program/github/note/images/image-20241004150735371.png)

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20241004151203928.png" alt="image-20241004151203928" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
//void print(LinkList L) {
//    while (L->next != NULL) {
//        L = L->next;
//        printf("%d\n", L->data);
//    }
//printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 2, 3, 4, 5, 6, 7};
//    int size = sizeof(A) / sizeof(int);
//
//    L = (LNode *) malloc(sizeof(LNode));
//    LNode *s, *r;
//    r = L;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        r->next = s;
//        r = s;
//    }
//}

// 不带头结点的链表建立
void print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}


void Delete_x(LinkList &L, ElemType x) {
    LNode *p; // p指向待删除结点
    if (L == NULL) { // 递归出口
        return;
    }

    if (L->data == x) { // 若当前L结点数据域为x
        p = L; // p存下这个要删除结点的指针
        L = L->next; // 让L指向下一个结点
        free(p); // 删除p
        Delete_x(L, x);
    } else { // 若当前L结点数据域 不 为x，直接后移一位结点
        Delete_x(L->next, x);
    }
};


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L,4);
    print(L);
    return 0;
}
```

##### 2.设L为带头结点的单链表，编写算法从尾到头反向输出每个结点的值

递归的话就是因为我去调用，首先我去，假如是。调用的时候它就12345。

![image-20241004152108798](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152108798.png)

那么我。第一下的时候就把一放进去，
然后二放进去
3
4
5
直到我放完之后，然后我开始去算它的时候，

![image-20241004152119768](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152119768.png)

那就是54321。
反向输出的时候用递归，

![image-20241004152135836](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152135836.png)

那就是直接把它，
你看它不断的递归，
那就是放进去。然后。
直到它为空，我就开始输出，
那输出的时候就是反向输出的。

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }
}

// 不带头结点的链表建立
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void print_reverse(LinkList L) {
//    if (L->next) { // 或者是这样
// 你有next我下面才可以执行L->next，不然就L->next已经是null了，再调用就会有问题
// 比如我1 2 3 3个结点，调用到3的时候，3的next就已经是Null了，就不执行if里的代码了，所以函数就不会print_reverse(NULL)
// 如果是if(L!=NULL)那么if里就会执行这样的代码print_reverse(NULL)，下面的L->data就会有问题了
    if (L->next != NULL) {
        print_reverse(L->next); // 递归遍历每个结点
    }
    printf("L->data=%d\n", L->data);
};


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);

    // 如果L是个空指针就不打印了
    if (L != NULL) {
        // 不需要打印头结点的数据域，因为头结点的数据域不存储数据
        print_reverse(L->next);
    }

    print(L);
    return 0;
}
```

##### 3.从单链表中删除自第i个元素起的共len个元素（不带头结点）

不带头结点的话要做特殊处理
如果是带头结点，那么只有else里的语句，if里的语句就没用了



特殊处理的步骤，删除i开始，len个 i为1，len为3

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-04 16.59.26.mov"></video>

else的步骤

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-04 18.22.54.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
//void print(LinkList L) {
//    while (L->next != NULL) {
//        L = L->next;
//        printf("%d\n", L->data);
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 2, 3};
//    int size = sizeof(A) / sizeof(int);
//
//    L = (LNode *) malloc(sizeof(LNode));
//    LNode *s, *r;
//    r = L;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        r->next = s;
//        r = s;
//    }
//}

// 不带头结点的链表建立
void print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

void Delete_i_len(LinkList &L, int i, int len) {
    LNode *p, *q;
    // 无头结点要特殊处理，第一个结点
    // 如果要删除的元素区间，起始位置为1
    if (i == 1) {
        // 从1开始，删除len个，那么就遍历len次
        for (int j = 1; j <= len; ++j) {
            // q存下L指向的第一个结点，因为要删除它
            q = L;
            // 然后让L指向q的下一个元素
            L = q->next;
            // 再free掉q
            free(q);
        }
    } else {
        // j用来记录当前是第几个结点，因为不带头结点，所以默认是第一个结点，如果带头结点，默认第0个结点
        int j = 1;
        // p指向第一个结点
        p = L;
        // 找到第i-1个元素，也就是要删除元素的前驱
        // 小于i-1的时候的条件都是满足的，当遇到j=i-1的时候，循环就会停下来，那么此时j就是 我要删除元素的前驱
        while (p != NULL && j < i - 1) {
            j++; // 有几个结点
            p = p->next; // 指针后移一个结点
        }
        if (!p) return; // 如果p为NULL说明链表已经为空
        // 如果可以执行到这里说明p就是 我要删除元素的前驱
        // 删除len个，下面的代码执行len次
        for (int k = 1; k <= len; ++k) {
            // 用q指针存下p的下一个结点，因为要删除它
            q = p->next;
            // p指向 要删除元素的下一个结点
            p->next = q->next;
            // 删除元素
            free(q);
        }
    }
}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_i_len(L, 3, 3);
    print(L);
    return 0;
}
```

##### 4.删除不带头结点单链表中所有值为x的结点（非递归）

![image-20241004200219468](/Users/yuebinghui/Documents/program/github/note/images/image-20241004200219468.png)

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-04 18.49.20.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
//void print(LinkList L) {
//    while (L->next != NULL) {
//        L = L->next;
//        printf("%d\n", L->data);
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 2, 3};
//    int size = sizeof(A) / sizeof(int);
//
//    L = (LNode *) malloc(sizeof(LNode));
//    LNode *s, *r;
//    r = L;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        r->next = s;
//        r = s;
//    }
//}

// 不带头结点的链表建立
void print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}


void Delete_x(LinkList &L, ElemType x) {
    // 指向要删除结点的前驱结点，不然就就算找到了要删除的结点，也无法将前驱结点的next指向要删除结点的下个结点，
    // 所以要用pre来指向要删除结点的前驱
    LNode *pre = NULL;
    // 工作指针，遍历链表
    LNode *p = L;
    LNode *q;

    // 遍历整个链表，直到NULL
    while (p != NULL) {
        // 如果此时的结点的数据域是x，即要删除的结点
        if (p->data == x) {
            // 判断pre是是否指向了结点，如果没有说明工作指针p还没有动过，即第一个结点就是x，要删除的结点
            if (pre == NULL) {
                // 让L指向p的后继
                L->next = p->next;
                // 删除p，
                free(p);
                // 再让p等于L，也就是第一个结点
                p = L;
            } else {
                // 此时pre结点不为空，并且当前p结点存的是x
                // 让q等于p，存下q来，一会要free掉
                q = p;
                // p指向后一个结点
                p = p->next;
                // 前驱结点，指向要删除结点的后一个结点
                pre->next = p;
                // 删除要删除的结点
                free(q);
            }
        } else { // 如果当前结点不是要删除的结点就往后遍历，找x
            // 一定是pre先存p的指针，p再走，因为pre要存p的地址
            // p不可以先变，因为pre要存p的前驱
            pre = p;
            // 存上p的地址后，p往后移一个结点，此时pre就是p的前驱结点
            p = p->next;
        }
    }
}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L, 4);
    print(L);
    return 0;
}
```

##### 5. 在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一。

![image-20241004200208484](/Users/yuebinghui/Documents/program/github/note/images/image-20241004200208484.png)

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-04 19.34.38.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3, 44, 53, 4};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3, 3, 4, 5,};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}

// 代码解释请看上条
void Delete_x(LinkList &L, ElemType x) {
    LNode *pre, *p, *q;
    pre = L;
    p = L->next;

    while (p != NULL) {
        if (p->data == x) {
            q = p;
            p = p->next;
            pre->next = p;
            free(q);
        } else {
            pre = p;
            p = p->next;
        }
    }

}


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L, 4);
    print(L);
    return 0;
}
```

##### 6. 采用尾插法建立单链表，用P指针扫描L的所有结点，当其值不为x时，将其连接到L之后，否则将其释放

![image-20241004201441645](/Users/yuebinghui/Documents/program/github/note/images/image-20241004201441645.png)

就相当于分成了两个表

用p来遍历整个链表的所有结点，r指针指向头结点
如果你不为x，则放到r后，就是插入L这个表里
如果你为x，把你释放