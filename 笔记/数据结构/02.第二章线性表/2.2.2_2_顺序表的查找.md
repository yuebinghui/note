各位同学大家好，在这一小节中我们会学习顺序表的查找操作怎么实现？那分为两种查找，一种是按位查找，一种是按值查找，我们会分别介绍怎么用代码实现，并且会分析这个代码的时间复杂度。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920190808034.png" alt="image-20240920190808034" style="zoom:50%;" />

## 顺序表的按位查找

好，那首先来看按位查找怎么实现对一个线性表进行按位查找，就是要从这个线性表l当中取得第i个元素。那如果这个线性表是用顺序表的方式实现，并且是用静态分配，这样的方式实现的话，那么所有的数据元素就是存放在data这个数组当中，那在这种情况下想要获得第i个数据元素其实非常简单，唯一需要注意的是。
第i个元素啊，它对应的数组下标应该是i- 1，因为这个位序是从一开始的，而数组下标是从零开始的。那这个元素的返回值和你的数据元素的类型是相同的，当然如果想让你的代码健壮性更强一些的话，在这个地方是不是还可以判断一下这个I的值？是否合法好，那这个也很简单，就不再展开

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920190912401.png" alt="image-20240920190912401" style="zoom:50%;" />

好接下来看一下，如果我们采用动态分配方式来实现顺序表的话，那么data这个变量，它其实是一个指针。这个指针指向了顺序表当中的第一个数据元素，那存储这个顺序表所需要的内存空间是用malloc函数申请的一整片的连续空间。
虽然data这个变量它是一个指针，但是同样可以用这种数组下标的方式访问相应的元素。这有可能是跨考的同学，不知道的点好，那我们来分析一下计算机在背后，它做了一些什么？你的这个data变量，它其实是一个指针。指针指向了malloc函数给它分配的一整片连续内存空间的起始地址，也就指向了这个地址。那我们假设现在这个指针，它所指向的地址是2000。然后在这个图当中，我们假设这样的一小格代表一个字节的大小，也就是1b的大小，
那如果说你的一个数据元素，也就是你的elemtype需要占六个字节的话。那么你用L点data 0这样的方式取得的值，其实就是从data这个指针所指向的这个地址。再往后六个字节的内容，你在这儿给它return了一个data 0，其实就是给它返回了这六个字节的内容，而这六个字节当中对应的内容刚好就是你的第一个。一个数据元素

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920191450283.png" alt="image-20240920191450283" style="zoom:50%;" />

好，那同理如果你的代码里写的是data 1的话，那data 1所对应的数据就应该是从二零零六这个地址开始，往后的六个字节。也就是你的第二个数据元素，那再往后的话也是一样的，就不再列举好，
那在这个地方，我们所定义的data指针，它所指向的数据类型就是element type这种类型。所以如果你按这种数组下标的方式来写代码的话，那其实计算机在背后会根据你的这个指针所指向的数据类型，它所占用的空间大小。来给你计算每一个数组下标，它应该对应的是哪几个字节的数据？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920191641695.png" alt="image-20240920191641695" style="zoom:50%;" />

好，那如果说我们定义另外的一个指针，这个指针它所指向的地址也是这儿也是2000。不过我们把这个指针它的呃类型规定为指向int型，而一个int型的变量是占四个字节。那么，你用类似的这种呃指针加上数组下标的方式来取得数据的话p0，
它所对应的数据就应该是从2000这个位置开始。往后的四个字节，这四个字节的内容是p0，再往后的四个字节是p1。再往后的四个字节是p2，以此类推，所以这是跨考的同学要理解的一个点，<u>用某一个类型的指针加上数组下标的这种方式来访问数据的话。那么，系统在背后为你取数据的时候，每一次取几个字节，其实和你的这个指针所指向的类型有关。</u>

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920191847451.png" alt="image-20240920191847451" style="zoom:50%;" />

因此，这也就能解释，为什么我们在之前的课里边给大家强调过，如果你用malloc函数申请一片连续的内存空间。那么，malloc函数返回的这个指针，你需要把它强制转换为和你的这个数据类型相对应的同类型的指针。因为虽然指针指向的都是同一个地址，但是如果你的这个指针所指向的数据类型，你给它定义错了，那么在访问你的数据元素的时候也会出现问题。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920192226892.png" alt="image-20240920192226892" style="zoom:50%;" />

### 时间复杂度

好的，那么既然顺序表按位查找这个操作，它只需要这样的一个return语句都没有任何的循环，也没有递归调用。所以按位查找这样的操作，它时间复杂度就应该是o1，那这也是我们之前提到过的顺序表。
随机存取的特性能够实现随机存取的基础就在于顺序表当中所有的数据元素在内存里边都是连续存放的，并且这些数据元素的数据类型相同。也就是说，每一个数据元素所占的内存空间是一样大的，所以我们只需要知道一个顺序表的起始地址。然后再知道每一个数据元素的大小，就可以立即找到第i个元素，它存放的位置。好的，那这是按位查找，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920192435597.png" alt="image-20240920192435597" style="zoom:50%;" />

## 顺序表的按值查找

接下来来看按值查找，按值查找操作就是要找到这个线性表l当中。有没有哪个数据元素和我们传入的这个参数e是相等的，如果能找到这样的数据元素的话，那么就要返回这个数据元素的存放位置。
好，那这个基本操作的实现也很简单，我们在这儿传入一个参数e。然后这个地方执行一个for循环，从这个顺序表最开始的那个元素开始依次往后检索。依次判断这个顺序表当中的各个数据元素和我们传入的这个数据元素e是否相等。如果相等的话，那么返回这个数据元素的位序，由于这个地方我们返回的是位序变量I指的是数组下标。所以我们在返回的时候需要用数组下标加一好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920192657047.png" alt="image-20240920192657047" style="zoom:50%;" />

那来看一个实际的例子啊，我们定义了这样的一个顺序表，这个顺序表当中数据元素的数据类型是int类型。并且这个顺序表已经初始化，而且插入了六个数据元素，
也就插入了六个int型的变量，那由于这个顺序表存放的是int型的变量。所以我们要对比啊，两个int型的变量，只需要用这样的一个运算符来进行比较就可以了。除了int型变量之外，像char double float等等这些基本数据类型都可以直接用判断相等的这个运算符来进行比较。

好，那现在假设有人调用了你这个函数，他想找的是在这个线性表l当中有没有等于九的数据元素？那首先会执行这个for循环，刚开始I是等于零的，并且lens的值等于六，那第一个数据元素，它的值和九是不相等的，
也就是这个if条件不满足。所以会进行I加加的操作。I的值由零变为一，然后进行第二轮的循环，第二轮循环扫描的就是这个数据元素和九依然不相等。因此I的值会变为二，然后进行第三轮的循环，第三轮循环就找到了和这个参数相等的数据元素，因此会返回这个数据元素的位序，也就是三。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193205791.png" alt="image-20240920193205791" style="zoom:50%;" />

好的，那接下来要思考的问题是，如果说我们的这个顺序表当中，它所存放的数据元素类型是一个更复杂的结构类型的话。那么，
两个结构类型的比较是否也可以用这种等于等于这个运算符呢？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193432115.png" alt="image-20240920193432115" style="zoom:50%;" />

答案是不能，我们在这儿定义了一个叫做customer的结构类型，然后写了一个简单的函数，声明了a和b这样的两个变量，这两个变量都是customer这种类型。并且我们故意把这两个customer里边的呃字段值都设为一，然后在这儿写一个if语句，我们想尝试用等于等于这样的运算符判断。a和b这两个结构类型的数据是否相等，但是会发现这个IDE提示我们说你的这个运算符它是。不可以用于比较两个customer类型的变量的。所以如果用这样的运算符来比较两个结构类型的变量的话，那别说是让这段代码运行了，你的这段代码连编译都编译不了。
所以如果要对比两个结构体的话，那么你必须自己写代码来分别的对比这个结构体里边的各个分量是否相等。如果这些分量都相等的话，那么就可以认为这个结构体是相等的，当然你也可以实现一个基本操作用来判断你所定义的两个结构体是否相等。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193600523.png" alt="image-20240920193600523" style="zoom:50%;" />

好，总之在C语言当中，你是不可以直接用，等于等于这个运算符来判断两个结构类型是否相等的。而如果使用C加加的话，你可以尝试重载这个运算符，为了照顾到跨考的同学，这儿就不再展开。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193751674.png" alt="image-20240920193751674" style="zoom:50%;" />

那给大家的建议是呃，在你们考研初试当中，
如果说这个学校，他说他考的科目就叫数据结构。那你在判断两个数据元素是否相等的时候，可以直接使用，等于等于这个运算符，不管你的这个数据元素到底是基本数据类型还是结构类型？因为数据结构这门课，它更多的是考察你对数据结构还有数据结构相关的算法的一个理解，并不会过分严格的要求你的这个代码。是否严格遵照某一种编程语言的规则？但是如果你报考的那个学校，它考的科目里边，它告诉你是考C语言程序设计。那么，这个学校在改卷的时候，
也许他就会比较在意你的这个C语言语法是否够严格？当然了，这个具体问题具体分析，大家最好还是看一下相关的历年真题，它题目里边是否要求你的C语言语法啊，要足够的标准。那这个地方给大家一个小小的提醒

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193849609.png" alt="image-20240920193849609" style="zoom:50%;" />

### 时间复杂度

#### 最好

#### 最坏

#### 平均

好，那接下来分析一下，按值查找这个操作的时间复杂度要算时间复杂度的话，我们需要关注的是最深层循环的。这个语句的执行次数也就是循环了几次，这个循环次数和问题规模n之间的关系是什么？那我们这儿的问题规模n。指的是线性表的表长好，那时间复杂度分为最好最坏和平均三种情况，
最好的情况肯定是如果你要找到这个值，刚好和表头元素的值相同的话。那这个循环是不是就只需要执行一次，所以最好时间复杂度应该是o1常数阶的，

那由于我们检索这些数据元素是从头到尾一个一个往后检索的。所以如果你要查找的这个值，它是最后一个数据元素的话，那么循环的次数就需要循环n次。需要把n个数据元素全部扫描一遍，才可以找到目标，所以最坏时间复杂度应该是on，

而平均时间复杂度，我们可以先假设呃，你要找的这个目标元素出现在任何一个位置的概率都相同。那总共有n个元素，
也就是说出现在任何一个位置的概率都是n分之一，而如果这个目标元素在第一位的话，那么循环只需要循环一次，在第二位的话，循环两次，以此类推，如果在第n位，那就循环n次。因此，平均来看，这个平均所需要的循环次数就应该是这个循环的次数乘以这种情况发生的概率，然后相乘相加。最终得到的结果应该是二分之n加一，因此平均时间复杂度应该是大on

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920194257875.png" alt="image-20240920194257875" style="zoom:50%;" />

好的，那这个小节的内容很简单，
我们学习了按位查找和按值查找。那由于顺序表当中的各个元素都是连续存放的，所以如果想要找到顺序表第I个元素的话，只需要o1的时间就可以立即找到。也就说，顺序表具有随机存取的特性，而如果是按值查找的话，那么我们需要从第一个元素开始依次往后检索。当然，如果这个顺序表当中的数据元素，它是按照某一种顺序，比如说从大到小或者从小到大的排列的。那对于数据元素有序的这种顺序表的查找，其实会有很多更高效的算法，那这个我们会在之后查找那个章节。
来学习其他的更高效的查找算法，但是如果顺序表当中的数据元素，它们本身存放就是没有任何规律的，那就只能从第一个元素依次开始往后寻找。平均来看，找到目标元素，时间复杂度应该是on那<u>再次强调跨考的同学需要注意位序和数组下标的关系。</u>

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920194820436.png" alt="image-20240920194820436" style="zoom:50%;" />

另外，还需要注意怎么判断两个结构体，也就是struct数据类型，它们是否相等。好了，那以上就是这小节的全部内容。