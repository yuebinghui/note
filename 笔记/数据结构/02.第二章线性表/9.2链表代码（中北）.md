# 线性表的链式表示-链表

##### 头结点和头指针的关系

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20241004110258475.png" alt="image-20241004110258475" style="zoom:45%;" />

##### 插入节点操作

![image-20241004125543587](/Users/yuebinghui/Documents/program/github/note/images/image-20241004125543587.png)

![image-20241004125606015](/Users/yuebinghui/Documents/program/github/note/images/image-20241004125606015.png)

##### 删除结点操作

![image-20241004130723638](/Users/yuebinghui/Documents/program/github/note/images/image-20241004130723638.png)

![image-20241004130739882](/Users/yuebinghui/Documents/program/github/note/images/image-20241004130739882.png)

##### 采用头插法建立单链表

![image-20241004131156196](/Users/yuebinghui/Documents/program/github/note/images/image-20241004131156196.png)

##### 采用尾巴插法建立单链表

![image-20241004131251253](/Users/yuebinghui/Documents/program/github/note/images/image-20241004131251253.png)

##### 1. 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点

![image-20241004150657842](/Users/yuebinghui/Documents/program/github/note/images/image-20241004150657842.png)

![image-20241004150735371](/Users/yuebinghui/Documents/program/github/note/images/image-20241004150735371.png)

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20241004151203928.png" alt="image-20241004151203928" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
//void print(LinkList L) {
//    while (L->next != NULL) {
//        L = L->next;
//        printf("%d\n", L->data);
//    }
//printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 2, 3, 4, 5, 6, 7};
//    int size = sizeof(A) / sizeof(int);
//
//    L = (LNode *) malloc(sizeof(LNode));
//    LNode *s, *r;
//    r = L;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        r->next = s;
//        r = s;
//    }
//}

// 不带头结点的链表建立
void print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}


void Delete_x(LinkList &L, ElemType x) {
    LNode *p; // p指向待删除结点
    if (L == NULL) { // 递归出口
        return;
    }

    if (L->data == x) { // 若当前L结点数据域为x
        p = L; // p存下这个要删除结点的指针
        L = L->next; // 让L指向下一个结点
        free(p); // 删除p
        Delete_x(L, x);
    } else { // 若当前L结点数据域 不 为x，直接后移一位结点
        Delete_x(L->next, x);
    }
};


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L,4);
    print(L);
    return 0;
}
```

##### 2.设L为带头结点的单链表，编写算法从尾到头反向输出每个结点的值


递归的话就是因为我去调用，首先我去，假如是。调用的时候它就12345。

那么我。第一下的时候就把一放进去，
然后二放进去
3
4
5
直到我放完之后，然后我开始去算它的时候，

那就是54321。
反向输出的时候用递归，



那就是直接把它，
你看它不断的递归，
那就是放进去。然后。
直到它为空，我就开始输出，
那输出的时候就是反向输出的。