各位同学大家好，在这个小节中我们会学习单链表的两种建立方法，分别是尾插法和头插法。那概括来说，这一小节要探讨的问题就是，如果给你很多个数据元素，也就很多个Elemtype，那么让你把它们存到一个单链表里，你应该怎么处理呢？其实很简单，第一步肯定是要从无到有，先创建一个单链表，对吧？也就是说先初始化一个单链表，然后接下来每一次取一个数据元素，然后把这个数据元素插到表尾的位置，
或者每一次都。插到表头的位置，所以这两种方法就分别对应所谓的尾插法和头插法。那这个小节我们探讨的是带头节点的单链表哦，不好意思，这个地方打错了，应该是取一个数据元素，你看学了数据结构这门课之后，万一以后你遇不到合适的对象。你还可以取一个数据元素是吧？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923190251897.png" alt="image-20240923190251897" style="zoom:50%;" />

## 尾插法建立单链表

好，那首先我们要探讨的是尾插法，第一步是不是要先初始化一个单链表，怎么初始化一个带头节点的单链表啊？这个相关的操作我们已经在单链表的定义，那个小节当中有过。详细的介绍这儿就不再赘述好，那现在已经有了一个单链表，接下来我们每一次取一个数据元素，插到这个单链表的尾部。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923190528210.png" alt="image-20240923190528210" style="zoom:50%;" />

那这个操作我们是不是可以用之前已经实现的按位序插入这个基本操作来实现，那由于我们每一次都是要把数据元素插入到这个单链表的表尾。所以我们可以设置一个变量叫length，用这个变量来记录单链表的当前长度。然后再写一个while循环，每次取出一个数据元素e，然后调用按位序插入这个基本操作，每一次都把这个数据元素e插入。插入到第lens+1个位置。像下面这个例子length+1应该等于四，
所以应该就是插入到这个位置，也就是表尾的位置，而每一次插入一个新的元素之后，都会导致单链表的长度length+1。那是不是这样的方式就可以实现用尾插法，建立一个单链表？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923191205923.png" alt="image-20240923191205923" style="zoom:50%;" />

不过如果用这种方式实现的话，那么当你每一次要在表尾的位置插入一个元素的时候，它都会用这个循环从表头的位置开始，依次往后遍历。直到找到最后一个结点，按照这个逻辑，当我们要插入第一个元素的时候，也就是只有一个头结点的时候，这个while循环可以直接跳过，
也就是循环次数是零次。而当我们要插入第二个元素的时候，while循环需要循环一次，要插入第三个元素的时候，需要循环两次好，以此类推。所以如果我们要插入n个元素的话，那么当插入第n个元素的时候，总共需要循环n- 1次。因此，循环的次数总共就应该是零+1+2，一直加加加到n- 1算。算出来应该是o的n方，这样的一个时间复杂度。这个时间复杂度还是很高的，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923191458565.png" alt="image-20240923191458565" style="zoom:50%;" />

那其实我们根本没有必要每一次都从头开始往后寻找，那其实我们是不是可以设置一个指针，让这个指针指向表尾的最后一个数据结点？然后当我们要在尾部插入一个新的数据元素的时候，是不是只需要对r这个节点做一个后插操作就可以了？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923191717202.png" alt="image-20240923191717202" style="zoom:50%;" />

如何实现后插操作？我们之前也具体聊过，就是这个函数。对表尾的这个结点执行后插操作就是这个样子。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923191750395.png" alt="image-20240923191750395" style="zoom:50%;" />

那当后插操作完成之后，是不是还需要把这个表尾指针往后移，就指向新的这个表尾元素，这样的话，你再插入下一个数据的时候，是不是还是对r进行后插操作就可以了？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923191844681.png" alt="image-20240923191844681" style="zoom:50%;" />

好，那来看一下我们课本里给的代码。在这个代码里边，首先声明了一个局部变量x。然后用malloc申请了一个头节点，也就说它这里边其实做了初始化一个单链表的操作。只不过我们自己初始化一个单链表的时候，会把这个头结点的指针先把它设为null。但是它这个地方没有做这样的操作，因为头结点的这个指针会在后面被修改好，那继续往后在这儿声明了两个指针。s和r这两个指针都是指向了头节点，然后这个地方调用了scanf，也就是让用户从键盘里面输入一个整数。这个整数x就是此次要插入单链表当中的数据元素。
也就说我们这儿的Elemtype，也就是数据元素类型，它就是整型的变量好，那假设此次输入的整数是十，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923192329982.png" alt="image-20240923192329982" style="zoom:50%;" />

那接下来while循环，它首先会检查x的值。是否不等于九九九？它这儿设置了一个这样的数字，其实就是取一个比较特殊的值当用户，输入九九九的时候，认为这个单链表的建立已经结束。所以你不要觉得奇怪，这儿为什么选九九九？其实就是随便挑选的一个比较特殊的数字，你要愿意的话也可以改成其他的数字好，
那由于此时x的值是十，它不等于这个特殊的值。因此，会开始执行循环里边的这些代码，后面这两句会申请一个新的结点，然后让s这个指针指向新结点，并且把新结点的这个数值设为x，也就是此次输入的这个数字。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923192529488.png" alt="image-20240923192529488" style="zoom:50%;" />

接下来把r结点的next指针指向s这个结点，也就是这样子，最后再让r指针指向s这个结点。接下来就可以输入下一个数据元素，那假设我们此次输入的数字是16，那由于16不等于这个特殊的数值。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923192743384.png" alt="image-20240923192743384" style="zoom:50%;" />

所以这个循环的条件满足，
因此接下来还会申请一个新的节点，并且把这个新的数据元素放到这个节点当中。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923192900937.png" alt="image-20240923192900937" style="zoom:50%;" />

再往后让r结点的next指针指向s之后，再让r指针指向s这个结点，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923192927506.png" alt="image-20240923192927506" style="zoom:50%;" />

接下来又可以输入再下一个数字好，那由于这次输入的数字依然不等于九九九。所以还会进行一次循环，那处理的过程和刚才是一样的，总之r这个指针永远要让它指向表尾的那个数据结点。然后每一次取得一个新的数据元素的时候，都把这个新的数据元素存到一个新的结点当中，并且把它连到表尾结点之后。好，那接下来如果用户输入的是九九九，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923192957174.png" alt="image-20240923192957174" style="zoom:50%;" />

那么这个循环条件不满足，
于是就可以跳过这个循环，然后执行这一句。让r结点的next指向none。最后再给调用者返回这个头指针，也就是返回这个单链表，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923193122346.png" alt="image-20240923193122346" style="zoom:50%;" />

所以在我们学习了之前的那些基本操作之后，这个代码的实现应该就很简单了。在前面这个地方，无非就是做了一个初始化空表，然后在这个while循环里，其实就是做了一个指定节点的后插操作。虽然和我们实现的后插操作有那么一丢丢区别，但是最起码后插操作的实现思想就可以直接迁移到这个地方。唯一需要注意的就是这个r指针，我们要保证这个指针它永远是指向最后一个结点的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923193236979.png" alt="image-20240923193236979" style="zoom:50%;" />

显然，如果要插入n个结点的话，那么这个循环的次数也是n次，所以这个算法它的时间复杂度应该是on这个数量级。那同学们可以暂停思考一下，如果不带头结点的单链表，它的尾插法实现会有什么不同呢？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923193259018.png" alt="image-20240923193259018" style="zoom:50%;" />

## 头插法建立单链表

好，接下来我们再来看第二种方法头插法。顾名思义，就是说我每一次取得一个新的数据元素的时候，我都把它插入到这个单链表的表头这个位置。就是这个样子。那其实实现这个算法的核心是不是和刚才一样，它也是一个对指定结点的后插操作？
每插入一个数据元素，其实就是对这个头结点执行一次后插操作嘛，所以用头插法，建立单链表也很简单，就是先初始化一个单链表。然后循环里边每一次取一个数据元素，然后每取得一个数据元素之后都调用一次，我们这儿实现的后插操作每一次都是对头节点进行后插操作。插入新的数据元素e，可以看一下课本里边给的这段代码，这里边它每次取得数据元素，依然是用这个scan f。也就是让用户用键盘输入一个整数，作为此次要插入的新的数据元素，那你看这两句是不是实现了对单链表的初始化？
然后while循环里边这个部分的代码，其实就是实现了一个后插操作嘛，只不过它每一次执行后插操作的指定节点都是指定了头节点。这两段代码本质上没有任何区别诶，那同学们可能会注意到在头插法里边，当它在初始化头结点的时候，它把头结点的next指针指向了n。但是尾插法里面没有好，那大家可以暂停思考一下，如果我们像尾插法那样把这一句代码给它去掉呢？会发生什么情况？首先，前面这句代码会申请一个新的结点，那如果我们不执行这句代码的话，那是不是头结点的这个指针有可能指向内存当中的某一片神秘的区域啊？
因为之前和大家强调过，其实这种动态分配申请的这片内存空间里面，它以前可能是会有脏数据的。你不知道以前这个数据是什么，所以说如果你不把它初始化的话，那么这个指针它有可能是指向某一个你不可知的地方的。好呢，再往后执行的话，申请一个新的结点s，这个s节点的data域把它设成x，再往后的话s节点的next指针指向了l节点的next指针这个地方。也就是指向了这片地方，然后头节点再指向这个新的节点，也就是这样子好，那如果还有别的新的节点陆续插入的话，
是不是情况是类似的？最后一个结点的next指针，它最终肯定都会指向这个，我们都不知道是什么地方的地方。所以这个地方我们必须初始化。其实，不管是在头插法的代码里边，还是尾插法的代码里边，我给大家的建议是，以后如果你要初始化一个单链表的话，那大家最好是养成这种。写代码的好习惯，反正初始化的时候，你把这句加上，肯定不会错，
但如果你习惯不好，忘了写这一句的话，那之后可能会出现一些你预料不到的问题。所以即便是在刚才我们介绍的尾插法的实现里边，其实大家最好还是形成这种习惯，把这句加上加上总不会错嘛。那这种好习惯，大家最好是在平时做题的时候就刻意的去培养好，那回到这个处理逻辑本身，如果按照我们刚才的那个输入顺序，也就先输入十，再输入16。再输入27，最后输入九九九的话，那么按照头插法的这种规则，
我们最终形成的这个单链表就应该是二七十六十。刚好是这些输入元素的逆序。其实头插法的这种性质是十分重要的，大家做课后习题的时候就会发现，其实在很多题目当中都会用得到这种单链表的逆制，这样的操作。那像这段代码当中，我们是用scan f取得一个一个的数据元素，那如果现在给你一个单链表l，让你把这个单链表逆置的话，其实核心的代码逻辑是不变的。只不过你取数据元素的时候，并不是用scan f的方式取得的，而是可以用一个指针循环着扫描，按顺序从这个l当中依次取得这个数据元素，
对吧？然后当你取出一个数据元素之后，又用头插法，把它插入到另一个新的链表当中，那你用这种方式建立的新链表是不是就相当于把这个以前的老链表给逆置了？当然，你也可以每一次从这个链表当中取下一个结点，然后把这个取下的结点又重新插回到这个头结点之后。这样的话，你就不需要建立一个新的链表，而是把l这个链表原地逆置。所以当大家在做题或者考试的时候，呃，看到这种需要把链表拟制的问题，你就可以尝试用头插法的这种方式。
来实现它。好，那同样的大家也需要暂停思考一下，如果不带头结点的话，那么怎么实现这个单链表的头插法？并且建议跨考的基础不好的同学一定要动手写一写。好的，那这个小节我们介绍了用头插法和尾插法来建立单链表，不管是哪种方法，其实实现的核心都是我们之前已经聊过的。初始化操作和指定节点的后插操作，这两个基本操作。只不过，在实现尾插法的时候，需要设置一个呃指向表尾节点的指针。
那通过这个小节的学习，大家应该更能够体会到为什么我们一直在强调说基本操作很重要。虽然说考试的时候几乎不可能直接考察，你就是某一种基本操作怎么实现，但是你只要掌握了这些基本操作的实现精髓之后，其实这些思想可以迁移。可以用于实现其他的更复杂的一些算法和操作，所以为什么我们在学习一个数据结构的时候非要探讨它的逻辑结构，物理结构，还有基本操作，也就是数据的运算呢？相信通过这个小节，大家应该会有一些更感性的体会。好，那最后再次强调头插法，
这种策略可以用于链表的拟制，这个考点是很重要的，经常考察。那大家可以不要急着往后学习，可以暂停一下，看一下给你一个单链表l，然后你怎么实现逆制？好的，那以上就是这个小节的全部内容。