

# çº¿æ€§è¡¨

## çº¿æ€§è¡¨çš„é¡ºåºè¡¨ç¤º-é¡ºåºè¡¨

###### é¡ºåºè¡¨çš„åˆå§‹åŒ–å’Œæ’å…¥

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    return true;
}

// iæ˜¯ä½åº ä»1å¼€å§‹
// æ•°ç»„ä¸‹æ ‡ä»0å¼€å§‹
// æ¯”å¦‚MaxSize æ˜¯10
// æ¯”å¦‚è¦æ’å…¥çš„iæ˜¯3

bool InsertList(SqList &L, int i, ElemType e) {
    // è¿™é‡Œå°äº1æ˜¯å› ä¸ºä½åºä»1å¼€å§‹ï¼Œä¸èƒ½æ¯”1å°
    /*
        i > L.length+1 æ˜¯å› ä¸ºæ¯”å¦‚æˆ‘æ•°ç»„æœ‰5ä¸ªå…ƒç´ ï¼ŒL.lengthä¸º5ï¼Œæˆ‘ç´¢å¼•æ˜¯ 0 1 2 3 4
        æ¯”å¦‚æ’å…¥ä¸€ä¸ª100ï¼Œä½åºæ˜¯8ï¼Œé‚£ä¹ˆå¦‚æœæ²¡æœ‰ i > L.length+1 è¿™ä¸ªæ¡ä»¶ï¼Œå°±ä¼šæŠŠ100æ’å…¥åˆ°ç´¢å¼•ä¸º7çš„ä½ç½®
        å€¼   1 2 3 4 5 ç©º ç©º 100 ç©º ç©º
        ç´¢å¼• 0 1 2 3 4 5  6  7   8  9
        å°±ä¼šé€ æˆè¿™æ ·çš„ç©ºéš™
        æ‰€ä»¥å½“ä¸€å…±æœ‰5ä¸ªå…ƒç´ ï¼Œæ­¤æ—¶ç´¢å¼•æ˜¯0~4ï¼Œ
        é‚£ä¹ˆä½ ä½åºæœ€å¤šæ’å…¥çš„å°±æ˜¯<=L.lengthçš„ä½ç½®ï¼Œå³1 2 3 4 5
        ä¹Ÿå°±æ˜¯ä½åºå¤§äº5å°±ä¼šäº§ç”Ÿç©ºéš™äº†ï¼Œå°±ä¸èƒ½æ’å…¥
     */
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    // æˆ‘æ•°ç»„å·²ç»æ»¡äº†ï¼Œå°±ä¸æ’å…¥å…ƒç´ äº†
    if (L.length >= MaxSize) {
        return false;
    }
    // j=L.length å°±æ˜¯ç¬¬ä¸€æ¬¡æ‰§è¡Œçš„æ—¶å€™ï¼Œå…ˆæŠŠç´¢å¼•ä¸ºL.lengthçš„ä½ç½®é‡Œæ”¾å…¥ç´¢å¼•ä¸ºL.length-1çš„å…ƒç´ 
    for (int j = L.length; j >= i; j--) {
        // å°±æ˜¯æŠŠå‰ä¸€ä¸ªå…ƒç´ æ•°æ®æ”¾åˆ°åä¸€ä¸ªå…ƒç´ é‡Œ
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    // æ’å…¥ä¸€ä¸ªå…ƒç´ ålength++
    L.length++;
    return true;
}

int main() {
    SqList L;
    InitList(L);


    return 0;
}
```

###### 1. å°†ä¸¤ä¸ªæœ‰åºé¡ºåºè¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„æœ‰åºé¡ºåºè¡¨ï¼Œå¹¶ç”±å‡½æ•°å€¼è¿”å›ç»“æœ

å°±æ˜¯å‡½æ•°è¿”å›ç±»å‹é‚£é‡Œï¼Œé™¤äº†å¸¸è§çš„int float bool è¿˜å¯ä»¥è¿”å›è‡ªå·±è‡ªå®šä¹‰çš„structç»“æ„ç±»å‹æ•°æ®

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240927141858410.png)

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// å°†ä¸¤ä¸ªæœ‰åºé¡ºåºè¡¨åˆå¹¶ä¸ºä¸€ä¸ªæ–°çš„æœ‰åºé¡ºåºè¡¨ï¼Œå¹¶ç”±å‡½æ•°å€¼è¿”å›ç»“æœ
bool Merge(SqList L1, SqList L2, SqList &L3) {
    // ä¸¤ä¸ªè¡¨ç›¸åŠ çš„é•¿åº¦ä¸å¯ä»¥å¤§äº L3çš„æœ€å¤§é•¿åº¦ï¼Œæ”¾ä¸ä¸‹
    if (L1.length + L2.length > L3.maxSize) {                        
        return false;
    }
    // iæ˜¯L1çš„ç´¢å¼• jæ˜¯L2çš„ç´¢å¼• kæ˜¯L3çš„ç´¢å¼•
    int i = 0, j = 0, k = 0;

    // 1ï¸âƒ£éå†L1 å’Œ L2ï¼Œä»0åˆ°lengthï¼Œå°±æ˜¯éå†æ•´ä¸ªL1æˆ–è€…L2 å“ªä¸ªè¡¨LengthçŸ­å°±å…ˆéå†å®Œ
    while (i < L1.length && j < L2.length) {
        // æ‹¿L1å’ŒL2çš„ç¬¬ä¸€ä¸ªå…ƒç´ å»ä½œæ¯”è¾ƒï¼Œå“ªä¸ªå°å“ªä¸ªå…ˆæ”¾å…¥L3
        if (L1.data[i] <= L2.data[j]) {
            // å…ˆæŠŠL1çš„ç¬¬iä¸ªå…ƒç´ æ”¾åˆ°L3çš„kçš„ç´¢å¼•ä¸Šï¼Œç„¶åk++ i++
            L3.data[k++] = L1.data[i++];
        } else {
            // å…ˆæŠŠL2çš„ç¬¬jä¸ªå…ƒç´ æ”¾åˆ°L3çš„kçš„ç´¢å¼•ä¸Šï¼Œç„¶åk++ j++
            L3.data[k++] = L2.data[j++];
        }
    }

    /*
     æ£€æŸ¥çœ‹L1æ˜¯å¦æ²¡æœ‰éå†å®Œæˆï¼Œæ²¡æœ‰çš„è¯ï¼Œå°±æŠŠL1å‰©ä¸‹çš„æ•°æ®ï¼Œéƒ½ä¾æ¬¡æ”¾åˆ°L3ä¸­
     ä¸‹é¢çš„ä¸¤ä¸ªwhileå¾ªç¯åªä¼šæ‰§è¡Œå…¶ä¸­ä¸€ä¸ªï¼Œå› ä¸º1ï¸âƒ£å¤„é‚£é‡Œçš„æ¡ä»¶å°±æ˜¯ä»¥L1æˆ–è€…L2å…¶ä¸­ä¸€ä¸ªéå†å®Œæˆä¸ºç»“æŸæ¡ä»¶çš„
     */
    while (i < L1.length) {
        L3.data[k++] = L1.data[i++];
    }
    // æ£€æŸ¥çœ‹L2æ˜¯å¦æ²¡æœ‰éå†å®Œæˆï¼Œæ²¡æœ‰çš„è¯ï¼Œå°±æŠŠL2å‰©ä¸‹çš„æ•°æ®ï¼Œéƒ½ä¾æ¬¡æ”¾åˆ°L3ä¸­
    while (j < L2.length) {
        L3.data[k++] = L2.data[j++];
    }
    // æœ€åæŠŠkèµ‹å€¼ç»™L3çš„length
    L3.length = k;
    return true;
}

int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1, j = 1, k = 1; i <= 10; ++i) {
        if (i % 2 == 1) {
            InsertList(L1, j++, i);
        } else {
            InsertList(L2, k++, i);
        }
    }

//    print(L1);

//    print(L2);

    Merge(L1, L2, L3);
    print(L3);


    return 0;
}
```

å»ºç«‹3ä¸ªç´¢å¼•,i j k éå†ä¸¤ä¸ªL1 L2 é¡ºåºè¡¨ï¼Œéå†è¿‡ç¨‹ä¸­i å’Œ j ä¸¤ä¸ªå…ƒç´ çš„æ¯é¡¹å…ƒç´ ä½œæ¯”è¾ƒï¼Œå¦‚æœå“ªä¸ªå°å“ªä¸ªå…ˆæ”¾å…¥åˆ°L3ä¸­ï¼Œå†æŠŠi æˆ–è€… j çš„ç´¢å¼•åç§»ï¼Œkä¹Ÿåç§»ï¼Œå½“iæˆ–è€…jçš„æŸä¸ªé¡ºåºè¡¨éå†å®Œæˆçš„æ—¶å€™ï¼Œè¯´æ˜å·²ç»iæˆ–è€…jçš„æŸä¸€ä¸ªé¡ºåºè¡¨ä¸­çš„å…ƒç´ å·²ç»å…¨éƒ¨æ”¾å…¥åˆ°L3ä¸­ï¼Œå‰©ä¸‹çš„é‚£ä¸ªè¡¨ä¸­çš„å…ƒç´ å°±å…¨éƒ¨æ˜¯æ¯”L3ä¸­å¤§çš„å…ƒç´ äº†ï¼Œç„¶åå†éå†i æˆ–è€…jçš„å…ƒç´ ï¼Œå…¨éƒ¨å¡å…¥L3ä¸­

ä¸æ‡‚å°±è‡ªå·±ç”»å›¾ç†è§£

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-09-30 18.51.01.mov"></video>



###### 2. å°†é¡ºåºè¡¨L1ä¸­çš„æ•°æ®åˆ†ç±»ï¼Œå¥‡æ•°æ”¾åˆ°L2ä¸­ï¼Œå¶æ•°æ”¾åˆ°L3ä¸­

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// å°†é¡ºåºè¡¨L1ä¸­çš„æ•°æ®åˆ†ç±»ï¼Œå¥‡æ•°æ”¾åˆ°L2ä¸­ï¼Œå¶æ•°æ”¾åˆ°L3ä¸­
bool split(SqList L1, SqList &L2, SqList &L3) {
    int i, j, k;
    i = j = k = 0;

    // éå†L1è¿™ä¸ªé¡ºåºè¡¨
    for (; i < L1.length; ++i) {
        //åˆ¤æ–­å½“L1çš„å…ƒç´ æ˜¯å¥‡æ•°çš„æ—¶å€™
        if (L1.data[i] % 2 == 1) {
            // èµ‹å€¼ç»™L2å¹¶ä¸”è®©L2çš„ç´¢å¼•++ï¼ŒååŠ åŠ 
            L2.data[j++] = L1.data[i];
        } else {
            // å¦‚æœæ˜¯å¶æ•°ï¼Œèµ‹å€¼ç»™L3å¹¶ä¸”è®©L3çš„ç´¢å¼•++ï¼ŒååŠ åŠ 
            L3.data[k++] = L1.data[i];
        }
    }

    L2.length = j;
    L3.length = k;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }

//    print(L1);
    split(L1, L2, L3);
//    print(L2);

    print(L2);
    print(L3);


    return 0;
}
```

éå†L1è¿™ä¸ªé¡ºåºè¡¨ï¼Œéå†çš„è¿‡ç¨‹ä¸­åˆ¤æ–­æ˜¯å¥‡æ•°è¿˜æ˜¯å¶æ•°ï¼Œå¥‡æ•°æ”¾å…¥L2ï¼Œå¶æ•°æ”¾å…¥L1

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240927151502394.png)

###### 3. L1ï¼ŒL2åˆ†åˆ«å­˜æ”¾ä¸¤ä¸ªæ•´æ•°é›†åˆï¼Œå®ç°L1ä¸L2çš„äº¤é›†å­˜æ”¾åœ¨L3ä¸­

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;


void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

bool InitList(SqList &L) {
    L.length = 0;
    return true;
}

bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1)return false;
    if (L.length == MaxSize)return false;

    for (int j = L.length; j >= i; --j) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

// æ–¹æ³•1 å¾ªç¯æ‰§è¡Œæ¬¡æ•°æœ€å¤šï¼Œå› ä¸ºåŒå±‚å¾ªç¯éƒ½æ‰§è¡Œäº†
//void intersection(SqList L1, SqList L2, SqList &L3, int &count) {
//    int i, j, k;
//    i = k = 0;
//    // éå†L1è¿™ä¸ªé¡ºåºè¡¨
//    for (; i < L1.length; i++) {
//        for (j = 0; j < L2.length; j++) {
//            if (L1.data[i] == L2.data[j]) {
//                L3.data[k++] = L1.data[i];
//            }
//            count++;
//        }
//    }
//    L3.length = k;
//}

// æ–¹æ³•2 æ‰¾åˆ°å†…å±‚çš„ä¸€æ ·çš„å€¼å°±ä¼šåœä¸‹ï¼Œæ¯”æ–¹æ³•1å°‘
void intersection(SqList L1, SqList L2, SqList &L3, int &count) {
    int i, j, k;
    i = k = 0;

    // éå†L1è¿™ä¸ªé¡ºåºè¡¨
    for (; i < L1.length; i++) {


        //æ–¹æ³•1
//        // é‡ç½®j ä¸ç„¶åœ¨ä¸€æ¬¡whileå¾ªç¯è¿›å…¥æ¡ä»¶çš„éå†åï¼Œjçš„å€¼ä¼šj++ åŠ ä¸Šå»ï¼Œå½“i=2è¿›æ¥çš„æ—¶å€™æ²¡æœ‰é‡ç½®jä¸º0ä¼šæœ‰é—®é¢˜
//        j = 0;
//        // éå†L2è¿™ä¸ªé¡ºåºè¡¨ å¹¶ä¸” æ‰¾L2é‡Œä¸L1ç›¸ç­‰çš„å…ƒç´ ï¼Œå¦‚æœä¸ç­‰å°±j++ï¼Œç›´åˆ°æ‰¾åˆ°ç›¸ç­‰çš„ï¼Œæˆ–è€…éå†å®Œæ•´ä¸ªL2é¡ºåºè¡¨
//        while (j < L2.length && L1.data[i] != L2.data[j]) {
//            j++;
//            count++;
//        }

        // æ–¹æ³•2 è¿™æ ·ä¹Ÿå¯
        for (j = 0; j < L2.length && L1.data[i] != L2.data[j]; ++j);

        // çœ‹ä¸Šé¢çš„whileå¾ªç¯æ˜¯ä¸æ»¡è¶³ && å·¦å³å“ªè¾¹çš„æ¡ä»¶ï¼Œå¦‚æœæ˜¯ä¸æ»¡è¶³å³è¾¹çš„æ¡ä»¶è·³å‡ºå¾ªç¯çš„ï¼Œè¯´æ˜æœ‰äº¤é›†ï¼Œå°±è¦èµ‹å€¼ç»™L3
        if (j < L2.length) {
            L3.data[k++] = L1.data[i];
        }
    }
    L3.length = k;
}



int main() {
    SqList L1;
    InitList(L1);
    SqList L2;
    InitList(L2);
    SqList L3;
    InitList(L3);

    int arr1[4] = {1, 9, 3, 7};
    int size1 = sizeof(arr1) / sizeof(ElemType);
    printf("size1=%d\n", size1);
    for (int i = 0; i < size1; ++i) {
        InsertList(L1, i + 1, arr1[i]);
    }
//
    int arr2[3] = {3, 7, 5};
    int size2 = sizeof(arr2) / sizeof(ElemType);
    for (int i = 0; i < size2; ++i) {
        InsertList(L2, i + 1, arr2[i]);
    }

    int count = 0;
    intersection(L1, L2, L3, count);
    printf("count=%d\n", count);
//    Print(L1);
//    Print(L2);
    Print(L3);

    return 0;
}
```

æ–¹æ³•1ï¼ŒåŒå±‚å¾ªç¯éå†ï¼Œæ‹¿å‡ºæ¯”å¦‚å¤–å±‚å¾ªç¯ä¸€ä¸ªå…ƒç´ å’Œå†…å±‚å¾ªç¯çš„å…ƒç´ ä¸€ä¸€æ¯”è¾ƒï¼Œå¦‚æœç›¸ç­‰å°±æ”¾å…¥L3
æ–¹æ³•2ï¼Œæ„Ÿè§‰å¾ˆç¬¨ï¼Œä¹Ÿæ˜¯åŒå±‚å¾ªç¯ï¼Œå†…å±‚é‡Œç”¨kå»æ‰¾ç›¸ç­‰çš„ï¼Œæ‰¾åˆ°å°±åœä¸‹æ¥ï¼Œç„¶åå†ç”¨ä¸€ä¸ªæ¡ä»¶å»åˆ¤æ–­æ˜¯å¦éå†å®Œäº†æ•´ä¸ªè¡¨ï¼Œå¦‚æœéå†å®Œäº†æ•´ä¸ªè¡¨è¯´æ˜æ²¡æœ‰ç›¸ç­‰çš„ï¼Œå¦‚æœæ²¡æœ‰éå†å®Œè¯´æ˜æœ‰ç›¸ç­‰çš„éœ€è¦èµ‹å€¼ï¼Œï¼ˆè¿™é‡Œå…¶å®å¯ä»¥å’Œæ–¹æ³•1ä¸€æ ·ç›´æ¥æ‰¾åˆ°ç›¸ç­‰çš„å°±èµ‹å€¼å°±å¥½äº†ï¼Œå°±ä¼šçœä¸‹ä¸€ä¸ªifæ¡ä»¶ï¼‰

###### 4. å°†é¡ºåºè¡¨Lä¸­æ‰€æœ‰å¥‡æ•°è°ƒæ•´åˆ°è¡¨çš„å·¦è¾¹ï¼Œæ‰€æœ‰çš„å¶æ•°è°ƒæ•´åˆ°è¡¨å³è¾¹

ä»å·¦å¾€å³æ‰¾ï¼Œæ‰¾åˆ°ä¸æ˜¯å¥‡æ•°å°±åœäº†ï¼Œ
ä»å³å¾€å·¦æ‰¾ï¼Œæ‰¾ä¸åˆ°ä¸æ˜¯å¶æ•°å°±åœäº†ï¼Œ
ç„¶åä¸¤ä¸ªäº¤æ¢ä½ç½®



ç»“æŸæ¡ä»¶æœ‰ä¸¤ç§æƒ…å†µï¼Œç¬¬ä¸€ç§æ˜¯i==jï¼Œä¸æ»¡è¶³æ¡ä»¶å°±è·³å‡ºå¾ªç¯äº†ï¼Œå¦ä¸€ç§æ˜¯i>jè¿™ç§æƒ…å†µï¼Œè¿™ä¸¤ç§æƒ…å†µéƒ½æ˜¯ç»“æŸ

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240928183811355.png)



1å¤„ï¼š
å› ä¸ºå·¦è¾¹æ”¾çš„æ˜¯å¥‡æ•°å˜›ï¼Œæ‰€ä»¥æˆ‘æ‰¾åˆ°å¶æ•°å°±åœäº†
å› ä¸ºå³è¾¹æ”¾çš„æ˜¯å¶æ•°å—ï¼Œæ‰€ä»¥æˆ‘æ‰¾åˆ°å¥‡æ•°å°±åœäº†
ç„¶åæŠŠæ­¤æ—¶i å’Œ j çš„ç´¢å¼•çš„æ•°æ®å…ƒç´ äº¤æ¢ä½ç½®
ç„¶åæ¢å®Œåï¼Œæˆ‘å°±i++ j++ä¸€ä¸‹

ç„¶åå†æ¬¡å¾ªç¯ï¼Œæ‰§è¡Œ1å¤„çš„æ­¥éª¤

è§†é¢‘é‡Œæœ‰ç‚¹é—®é¢˜ï¼Œæœ€åå®é™…æ˜¯ j=3 i=4

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-09-30 20.41.28.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// æ–¹æ³•2
void sort(SqList &L) {
    int i, j;
    ElemType x;
    i = 0;
    j = L.length - 1;
    while (i < j) {
        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¶æ•°åœä¸‹æ¥
        while (i < j && L.data[i] % 2 != 0) {
//        while (i < j && L.data[i] % 2 == 1) {
            i++;
        }
        // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¥‡æ•°åœä¸‹æ¥
        while (i < j && L.data[j] % 2 != 1) {
//        while (i < j && L.data[j] % 2 == 0) {
            j--;
        }

        if (i < j) {
            x = L.data[i];
            L.data[i++] = L.data[j];
            L.data[j--] = x;
        }
    }
    printf("i=%d j=%d\n", i, j);
}

// å°†é¡ºåºè¡¨Lä¸­æ‰€æœ‰å¥‡æ•°è°ƒæ•´åˆ°è¡¨çš„å·¦è¾¹ï¼Œæ‰€æœ‰çš„å¶æ•°è°ƒæ•´åˆ°è¡¨å³è¾¹
void change(SqList &L) {
    int i, j; // ä¸¤ä¸ªç´¢å¼•åˆ†åˆ«æŒ‡å‘é¡ºåºè¡¨å¤´å°¾
    ElemType x; // ç”¨æ¥ä¸´æ—¶å­˜æ”¾æ•°æ®çš„å…ƒç´ 
    i = 0; // iæŒ‡å‘é¡ºåºè¡¨å¤´éƒ¨
    j = L.length - 1; // jæŒ‡å‘é¡ºåºè¡¨å°¾éƒ¨

    do { // å…ˆæ‰§è¡Œä»£ç ï¼Œå†åˆ¤æ–­æ¡ä»¶ å½“ä¸æ»¡è¶³i<jæ—¶åœæ­¢å¾ªç¯
        while (i < j && L.data[i] % 2 == 1) { // å½“å‰ä½ç½®æ˜¯å¥‡æ•°å°±ç»§ç»­çœ‹ä¸‹ä¸€ä¸ªä½ç½®ï¼Œåœ¨å¶æ•°çš„æ—¶å€™åœä¸‹
            i++;
        }
        while (i < j && L.data[j] % 2 == 0) { // å½“å‰ä½ç½®æ˜¯å¶æ•°å°±ç»§ç»­çœ‹ä¸‹ä¸€ä¸ªä½ç½®ï¼Œåœ¨å¥‡æ•°çš„æ—¶å€™åœä¸‹
            j--;
        }
        /*
            i<jè¯´æ˜iæ˜¯å¶æ•°ï¼Œjæ˜¯å¥‡æ•°ï¼Œæ‰€ä»¥äº¤æ¢ä½ç½®
            äºŒè€…ç›¸ç­‰ï¼Œçš„è¯åŒä¸€ä¸ªæ•°å­—ä¸éœ€è¦æ¢
         */
        if (i < j) {
            x = L.data[i];
            L.data[i++] = L.data[j];
            L.data[j--] = x;
        }
    } while (i < j);


}

int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

//    print(L1);
    change(L1);
    print(L1);

//    print(L2);

//    print(L3);
    return 0;
}
```



###### 5. é¡ºåºè¡¨å°±åœ°é€†ç½®

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240928190955656.png)

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// é¡ºåºè¡¨å°±åœ°é€†ç½®
void Reverse(SqList &L) {
    int i, j; // å®šä¹‰ä¸¤ä¸ªæ ‡è®°
    i = 0; // æŒ‡å‘è¡¨å¤´
    j = L.length - 1; // æŒ‡å‘è¡¨å°¾
    ElemType x;
    while (i < j) { // å¦‚æœi++ j--ä¸¤ä¸ªæ…¢æ…¢é è¿‘ï¼Œj=iæˆ–è€…i>jåœä¸‹
        x = L.data[i];
        L.data[i++] = L.data[j];
        L.data[j--] = x;
    }
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

    Print(L1);
    Reverse(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 6. ğŸŒŸ è®¾è®¡ä¸€ä¸ªé«˜æ•ˆç®—æ³•ï¼Œå°†é¡ºåºè¡¨Lçš„æ‰€æœ‰å…ƒç´ é€†ç½®ï¼Œè¦æ±‚ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦ä¸ºO(1)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240928192831811.png)

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// è®¾è®¡ä¸€ä¸ªé«˜æ•ˆç®—æ³•ï¼Œå°†é¡ºåºè¡¨Lçš„æ‰€æœ‰å…ƒç´ é€†ç½®ï¼Œè¦æ±‚ç®—æ³•çš„ç©ºé—´å¤æ‚åº¦ä¸ºO(1);
void Reverse(SqList &L) {
    ElemType temp; // æš‚å­˜æ•°æ®
    for (int i = 0; i < L.length / 2; ++i) { // å°†æ•°ç»„å¯¹åŠæ°å¼€ï¼Œåªéå†ä¸€åŠ ä¸¤ä¸¤äº’æ¢
        temp = L.data[i];
        L.data[i] = L.data[L.length - 1 - i];
        L.data[L.length - 1 - i] = temp;
    }
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

    Print(L1);
    Reverse(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 7. ğŸŒŸ å¯¹äºé•¿åº¦ä¸ºnçš„é¡ºåºè¡¨Lï¼Œç¼–å†™ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(1)çš„ç®—æ³•ï¼Œè¯¥ç®—æ³•åˆ é™¤çº¿æ€§è¡¨ä¸­æ‰€æœ‰å€¼ä¸ºxçš„æ•°æ®å…ƒç´ 

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240928200845984.png)

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-01 19.51.48.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// å¯¹äºé•¿åº¦ä¸ºnçš„é¡ºåºè¡¨Lï¼Œç¼–å†™ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(1)çš„ç®—æ³•ï¼Œè¯¥ç®—æ³•åˆ é™¤çº¿æ€§è¡¨ä¸­æ‰€æœ‰å€¼ä¸ºxçš„æ•°æ®å…ƒç´ 
void Delete_x(SqList &L, ElemType x) {
    int i, k;
    i = k = 0;
    // iåˆ é™¤å‰å«åŸè¡¨ï¼Œkåˆ é™¤åå«æ–°è¡¨ï¼Œä½†å…¶å®éƒ½æ˜¯åœ¨ä¸€ä¸ªè¡¨é‡Œæ“ä½œçš„ï¼Œç´¢å¼•ä¸åŒ
    for (; i < L.length; ++i) {
        // éå†åŸè¡¨ï¼Œå¦‚æœä¸ç­‰äºxï¼Œå°±æŠŠä¸ç­‰äºxçš„æ•°å­˜åˆ°ç´¢å¼•ä¸ºkçš„è¡¨é‡Œï¼Œå°±æ˜¯æ¢äº†ä¸ªç´¢å¼•ï¼Œè¿˜æ˜¯åœ¨ç”¨ä¸€ä¸ªè¡¨é‡Œ
        // å¦‚æœåŒ¹é…åˆ°xäº†ï¼Œè¿™ä¸ªå¾ªç¯ä»€ä¹ˆæ“ä½œéƒ½ä¸åš
        if (L.data[i] != x) {
            //å› ä¸ºæ˜¯åœ¨åŒä¸€ä¸ªè¡¨ä¸­æ“ä½œçš„ï¼Œæ‰€ä»¥ç©ºé—´å¤æ‚åº¦å°±æ˜¯O(1)ï¼Œåªä¸è¿‡æ˜¯æŠŠåŸæ¥çš„ç´¢å¼•iå˜æˆäº†k
            L.data[k++] = L.data[i];
        }
    }
    L.length = k; //ç»™é¡ºåºè¡¨èµ‹å€¼æ–°è¡¨è¡¨é•¿
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    int arr[10] = {1, 8, 3, 4, 5, 8, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_x(L1, 8);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```



###### 7.1 ğŸŒŸ 7.0çš„ç¬¬äºŒç§è§£æ³•

åŸè¡¨ç´¢å¼•ä¸ºi
kè®°å½•æœ‰å¤šå°‘ä¸ªxå…ƒç´ 
æ–°è¡¨é‡Œå­˜çš„æ˜¯æ²¡æœ‰xå…ƒç´ çš„ä¸ªæ•°ï¼Œæ‰€ä»¥å°±æ˜¯L.length - k

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240928203935481.png)

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-01 20.09.42.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// å¯¹äºé•¿åº¦ä¸ºnçš„é¡ºåºè¡¨Lï¼Œç¼–å†™ä¸€ä¸ªæ—¶é—´å¤æ‚åº¦ä¸ºO(n)ï¼Œç©ºé—´å¤æ‚åº¦ä¸ºO(1)çš„ç®—æ³•ï¼Œæ”¹ç®—æ³•åˆ é™¤çº¿æ€§è¡¨ä¸­æ‰€æœ‰å€¼ä¸ºxçš„æ•°æ®å…ƒç´ 
// è§£æ³•2
void Delete_x(SqList &L, ElemType x) {
    int i, k;
    i = k = 0;

    while (i < L.length) {
        if (L.data[i] == x) {
            k++; // kè®°å½•ç­‰äºxçš„å…ƒç´ çš„ä¸ªæ•°
        } else {
            L.data[i - k] = L.data[i]; //å½“å‰å…ƒç´ å‰ç§»kä¸ªä½ç½®
        }
        i++;
    }
    L.length -= k; // é¡ºåºè¡¨é•¿åº¦å‡å»k
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    int arr[10] = {1, 8, 3, 4, 5, 8, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_x(L1, 8);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 8. ğŸŒŸğŸŒŸ ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤æ‰€æœ‰å…¶å€¼é‡å¤çš„å…ƒç´ ï¼Œä½¿è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„å€¼å‡ä¸åŒ

æˆ‘è®©i=0ï¼Œj=1ï¼Œæˆ‘è¦çœ‹iå’Œjæ‰€æŒ‡çš„å…ƒç´ æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒå°±åˆ é™¤ä¸€ä¸ªï¼Œä¸åŒå°±å¾€åèµ°

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240928204443301.png)

è§†é¢‘ç¬¬ä¸€ç§’æ²¡å½•ä¸Šï¼Œiä¸€å¼€å§‹æ˜¯åœ¨0çš„ä½ç½®

<div width="200px"><video  src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-01 20.42.27.mov"></video></div>

ä¸‹é¢è¿™ä¸ªè§†é¢‘æ˜¯åœ¨åŒä¸€ä¸ªè¡¨ä¸­æ“ä½œçš„

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-12 15.45.24.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤æ‰€æœ‰å…¶å€¼é‡å¤çš„å…ƒç´ ï¼Œä½¿è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„å€¼å‡ä¸åŒ
bool Delete_same(SqList &L) {
    if (L.length == 0) {
        return false;
    }
    int i; // iå­˜å‚¨ç¬¬ä¸€ä¸ªä¸ç›¸åŒçš„å…ƒç´  æŒ‡å‘åŸè¡¨çš„ç¬¬ä¸€ä¸ªä½ç½®
    int j; // jä½œä¸ºå·¥ä½œæŒ‡é’ˆ æŒ‡å‘åŸè¡¨çš„ç¬¬äºŒä¸ªä½ç½®
    for (i = 0, j = 1; j < L.length; j++) {
        // å¦‚æœiå’Œjçš„å€¼ä¸ç›¸ç­‰äº†ï¼Œå°±è®©iæŒ‡é’ˆå…ˆå¾€åç§»åŠ¨ä¸€ä½ï¼Œç„¶åå­˜å…¥jçš„å€¼
        // å¦‚æœiå’Œjçš„å€¼ç›¸ç­‰ï¼Œé‚£ä¹ˆå°±è®©jå¾€åèµ°ï¼Œç›´åˆ°é‡åˆ°ä¸ç­‰çš„ï¼Œå†è®©iæŒ‡é’ˆå…ˆå¾€åç§»åŠ¨ä¸€ä½ï¼Œç„¶åå­˜å…¥jçš„å€¼
        if (L.data[i] != L.data[j]) { // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªä¸ä¸Šä¸€ä¸ªå…ƒç´ ä¸åŒçš„å€¼ å¦‚æœç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªä¸ç›¸ç­‰
           //æˆ‘å°±æŠŠå…ˆæŠŠiåç§»ä¸€ä½ï¼Œå› ä¸ºæˆ‘æ­¤æ—¶çš„iæ¯”å¦‚æ˜¯ç¬¬ä¸€æ¬¡å¾ªç¯ï¼Œæˆ‘åŸè¡¨é‡Œiç§»åŠ¨å‰çš„å…ƒç´ è‚¯å®šæ˜¯ç¬¬ä¸€ä¸ªä¸”å”¯ä¸€ä¸€ä¸ª
            // æ‰€ä»¥æˆ‘å°±æŠŠæˆ‘åé¢é‚£ä¸ªï¼Œä¹Ÿå°±æ˜¯jçš„ä½ç½®æ”¾å…¥åˆ°æˆ‘içš„åé¢
            // æ­¤æ—¶æˆ‘æ–°è¡¨é‡Œçš„å†…å®¹éƒ½æ˜¯å”¯ä¸€çš„ï¼Œç„¶åj++ï¼Œæ¥ç€æ¯”
            L.data[++i] = L.data[j];
        }
    }
    L.length = i + 1;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_same(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 9. ä»é¡ºåºè¡¨ä¸­åˆ é™¤å…¶å€¼åœ¨ç»™å®šå€¼sä¸tä¹‹é—´ï¼ˆè¦æ±‚s<tï¼ŒåŒ…å«s tï¼‰çš„æ‰€æœ‰å…ƒç´ ï¼Œè‹¥sæˆ–tä¸åˆç†æˆ–é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™é€€å‡ºè¿è¡Œ

å°±æ˜¯sä¸tï¼Œæ¯”å¦‚æˆ‘è¦åˆ é™¤å€¼ä¸º2~7ä¸­é—´çš„æ‰€æœ‰å…ƒç´ ï¼ŒåŒ…å«2å’Œ7ï¼Œé‚£ä¹ˆså°±æ˜¯2ï¼Œtå°±æ˜¯7

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-09-29 15.46.35.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// ä»é¡ºåºè¡¨ä¸­åˆ é™¤å…¶å€¼åœ¨ç»™å®šå€¼sä¸tä¹‹é—´ï¼ˆè¦æ±‚s<tï¼ŒåŒ…å«s tï¼‰çš„æ‰€æœ‰å…ƒç´ ï¼Œè‹¥sæˆ–tä¸åˆç†æˆ–é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™é€€å‡ºè¿è¡Œ
bool Delete_s_t(SqList &L, ElemType s, ElemType t) {
    if (L.length == 0 || s >= t) {
        return false;
    }
    int i, k;
    i = k = 0;
    for (; i < L.length; i++) {
        if (L.data[i] >= s && L.data[i] <= t) { // å¦‚æœä½ L.data[i]åœ¨è¿™ä¸ªèŒƒå›´å†…æˆ‘å°±ä¸è¦ä½ 
            k++;
        } else { // ä¸åœ¨è¿™ä¸ªèŒƒå›´å†…çš„ié¡¹æˆ‘æ‰èµ‹å€¼ç»™ä½  i-k
            L.data[i - k] = L.data[i]; // å½“å‰å…ƒç´ ï¼Œå¾€å‰ç§»åŠ¨kä¸ªä½ç½®ï¼Œå› ä¸ºæˆ‘å¿½ç•¥äº†kä¸ªå…ƒç´ 
        }
    }
    L.length -= k;// kæ˜¯å¤šå°‘ï¼Œè¯´æ˜æœ‰å¤šå°‘ä¸ªåœ¨[s,t]åŒºé—´å†…çš„å…ƒç´ ï¼Œä¹Ÿè¯´æ˜åˆ é™¤äº†kä¸ª
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_s_t(L1, 2, 7);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 10. ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤å…¶å€¼åœ¨ç»™å®šå€¼sä¸tä¹‹é—´ï¼ˆè¦æ±‚s<tï¼ŒåŒ…å«s tï¼‰çš„æ‰€æœ‰å…ƒç´ ï¼Œè‹¥sæˆ–tä¸åˆç†æˆ–é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™é€€å‡ºè¿è¡Œ

æˆ‘æ‰¾åˆ°è¿™ä¸ªåŒºé—´åï¼Œå…‰æŠŠè¿™ä¸ªåŒºé—´åˆ é™¤å°±å¥½äº†



<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-09-29 16.52.49.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// é—­åŒºé—´å³åŒ…å«s t
// ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤å…¶å€¼åœ¨ç»™å®šå€¼sä¸tä¹‹é—´ï¼ˆè¦æ±‚s<tï¼ŒåŒ…å«s tï¼‰çš„æ‰€æœ‰å…ƒç´ ï¼Œè‹¥sæˆ–tä¸åˆç†æˆ–é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™é€€å‡ºè¿è¡Œ
bool Delete_s_t(SqList &L, ElemType s, ElemType t) {
    if (L.length == 0 || s >= t) {
        return false;
    }
    int i, j;
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºsçš„å…ƒç´  å› ä¸ºè¦å»æ‰[s,t]å†…çš„å…ƒç´ 
    // æ‰€ä»¥ä¸€ä¼šè¦è¦†ç›–æ‰è¿™ä¸ªç­‰äºsçš„å…ƒç´ 
    for (i = 0; i < L.length && L.data[i] < s; i++);
    if (i >= L.length) return false;// è¯´æ˜éƒ½æ¯”så°ï¼Œä¸ç”¨åˆ é™¤
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºtçš„å…ƒç´ ï¼Œè¦æ‰¾åˆ°å¤§äºçš„å…ƒç´ 
    // å› ä¸ºä¸‹é¢è¦æŠŠ[s,t]èŒƒå›´å¤–çš„å…ƒç´ æ”¾åˆ°æ–°è¡¨é‡Œ
    for (j = i; j < L.length && L.data[j] <= t; j++);

    for (; j < L.length;) {
        L.data[i] = L.data[j];
        j++;
        i++;
    }
    L.length = i;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[7] = {1, 2, 3, 4, 5, 6, 7};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_s_t(L1, 3, 5);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

ä¸Šé¢æ˜¯é—­åŒºé—´
ä¸‹é¢æ˜¯å¼€åŒºé—´

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-09-29 17.03.58.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// å¼€åŒºé—´å³ä¸åŒ…å«s t
// ä»æœ‰åºé¡ºåºè¡¨ä¸­åˆ é™¤å…¶å€¼åœ¨ç»™å®šå€¼sä¸tä¹‹é—´ï¼ˆè¦æ±‚s<tï¼Œä¸åŒ…å«s tï¼‰çš„æ‰€æœ‰å…ƒç´ ï¼Œè‹¥sæˆ–tä¸åˆç†æˆ–é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™é€€å‡ºè¿è¡Œ
bool Delete_s_t(SqList &L, ElemType s, ElemType t) {
    if (L.length == 0 || s >= t) {
        return false;
    }
    int i, j;
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºsçš„å…ƒç´  å› ä¸ºè¦å»æ‰(s,t)ä¸åŒ…æ‹¬s tçš„å…ƒç´ 
    for (i = 0; i < L.length && L.data[i] <= s; i++);
    if (i >= L.length) return false;// è¯´æ˜éƒ½å°äºç­‰äºsï¼Œä¸ç”¨åˆ é™¤
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºtçš„å…ƒç´ ï¼Œè¦æ‰¾åˆ°å¤§äºç­‰äºçš„å…ƒç´ 
    // å› ä¸ºä¸‹é¢è¦æŠŠ(s,t)çš„å…ƒç´ æ”¾åˆ°æ–°è¡¨é‡Œ
    for (j = i; j < L.length && L.data[j] < t; j++);

    for (; j < L.length;) {
        L.data[i] = L.data[j];
        j++;
        i++;
    }
    L.length = i;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[7] = {1, 2, 3, 4, 5, 6, 7};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_s_t(L1, 3, 5);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 11. ä»é¡ºåºè¡¨ä¸­åˆ é™¤å…·æœ‰æœ€å°å€¼çš„å…ƒç´ ï¼ˆå‡è®¾å”¯ä¸€ï¼‰å¹¶ç”±å‡½æ•°è¿”å›è¢«åˆ å…ƒç´ çš„å€¼ï¼Œç©ºå‡ºçš„ä½ç½®ç”±æœ€åä¸€ä¸ªå…ƒç´ å¡«è¡¥ï¼Œè‹¥é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™æ˜¾ç¤ºå‡ºé”™è¯¯ä¿¡æ¯å¹¶é€€å‡ºè¿è¡Œ

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// ä»é¡ºåºè¡¨ä¸­åˆ é™¤å…·æœ‰æœ€å°å€¼çš„å…ƒç´ ï¼ˆå‡è®¾å”¯ä¸€ï¼‰å¹¶ç”±å‡½æ•°è¿”å›è¢«åˆ å…ƒç´ çš„å€¼ï¼Œç©ºå‡ºçš„ä½ç½®ç”±æœ€åä¸€ä¸ªå…ƒç´ å¡«è¡¥ï¼Œè‹¥é¡ºåºè¡¨ä¸ºç©ºï¼Œåˆ™æ˜¾ç¤ºå‡ºé”™è¯¯ä¿¡æ¯å¹¶é€€å‡ºè¿è¡Œ
bool Delete_min(SqList &L, ElemType &value) {
    if (L.length == 0) {
        return false;
    }
    value = L.data[0]; // å‡å®šé¡ºåºè¡¨é‡Œç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æœ€å°å€¼
    int pos = 0;
    int i;
    for (i = 1; i < L.length; i++) { // iä»1å¼€å§‹ï¼Œç„¶åæ‹¿ä¾æ¬¡æ‹¿å·¥ä½œæŒ‡é’ˆiå’Œæœ€å°å€¼å»æ¯”
        if (L.data[i] < value) { //å¦‚æœå½“å‰é¡¹æ¯”valueè¿˜å°
            value = L.data[i]; //é‚£ä¹ˆèµ‹å€¼ç»™value
            pos = i; //ç´¢å¼•ä¹Ÿè®°å½•ä¸‹æ¥
        }
    }
    L.data[pos] = L.data[L.length - 1]; //æœ€åæŠŠæœ€åä¸€ä¸ªå…ƒç´ èµ‹å€¼ç»™æœ€å°å€¼
    L.length--; //ç„¶ååˆ é™¤ä¸€ä½ï¼Œé•¿åº¦å‡ä¸€
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[7] = {7, 9, 15, 6, 21, 3, 8};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    ElemType value;
    Delete_min(L1, value);
    printf("value=%d\n", value);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

##### 12. ğŸŒŸ å·²çŸ¥åœ¨ä¸€ç»´æ•°ç»„A[m+n]ä¸­ï¼Œä¾æ¬¡å­˜æ”¾ä¸¤ä¸ªçº¿æ€§è¡¨(a1,a2,a3,...,am)å’Œ(b1,b2,b3,...,bn)ï¼Œè¯•ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œå°†æ•°ç»„ä¸­ä¸¤ä¸ªé¡ºåºè¡¨çš„ä½ç½®äº’æ¢ï¼Œå³ å°†(b1,b2,b3,...,bn)æ”¾åœ¨(a1,a2,a3,...,am)çš„å‰é¢

###### ä¸ªäººç†è§£ï¼š

æ¯”å¦‚æ•°ç»„æ˜¯6é¡¹1~6 m=2 n=4

å…ˆçœ‹ç¬¬ä¸€ä¸ªReverseè°ƒç”¨ï¼Œleft right å…¶å®ä¼ å…¥çš„å°±æ˜¯0 m+n-1=5 å°±æ˜¯æ•´ä½“æ•°ç»„çš„å¼€å¤´æœ«å°¾ç´¢å¼•
midå°±æ˜¯æ‰¾åˆ°ä¸­é—´ç´¢å¼•çš„ä½ç½®ï¼Œä»0å¼€å§‹éå†åˆ°ä¸­é—´ç´¢å¼•ï¼Œä¸æ‡‚å°±çœ‹<u>ç¬¬6ä¸ªç®—æ³•</u>ï¼Œè¿™ä¸ªReverseä¸­å› ä¸ºleftæ˜¯0ï¼Œæ‰€ä»¥
å…¶å®å°±æ˜¯ç¬¬6ä¸ªç®—æ³•ï¼Œæ‰§è¡Œå®Œç¬¬ä¸€ä¸ªReverseåæ•´ä¸ªæ•°ç»„å°±é€†ç½®äº†

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-02 15.12.49.mov"></video>

è§†é¢‘é‡Œå¿˜è®°æŠŠä¸‹é¢çº¢è‰²æ¡†ç»™æ¢äº†

![](/Users/yuebinghui/Documents/program/github/note/images/image-20241002151602337.png)

å†çœ‹ç¬¬äºŒä¸ªReverseè°ƒç”¨left right å…¶å®ä¼ å…¥çš„å°±æ˜¯0 n-1=1 å°±æ˜¯æ•´ä½“æ•°ç»„çš„å¼€å¤´æœ«å°¾ç´¢å¼•
midå°±æ˜¯æ‰¾åˆ°ä¸­é—´ç´¢å¼•çš„ä½ç½®ï¼Œä»0å¼€å§‹éå†åˆ°ä¸­é—´ç´¢å¼•ï¼Œä¸æ‡‚å°±çœ‹<u>ç¬¬6ä¸ªç®—æ³•</u>ï¼Œè¿™ä¸ªReverseä¸­å› ä¸ºleftæ˜¯0ï¼Œæ‰€ä»¥
å…¶å®å°±æ˜¯ç¬¬6ä¸ªç®—æ³•ï¼Œæ‰§è¡Œå®Œç¬¬äºŒä¸ªReverseåa1åˆ°amæ•´ä¸ªæ•°ç»„å°±é€†ç½®äº†

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-02 15.19.29.mov"></video>

è§†é¢‘é‡Œå¿˜è®°æŠŠä¸‹é¢çº¢è‰²æ¡†ç»™æ¢äº†

![](/Users/yuebinghui/Documents/program/github/note/images/image-20241002152138407.png)

å†çœ‹ç¬¬ä¸‰ä¸ªReverseè°ƒç”¨left right å…¶å®ä¼ å…¥çš„å°±æ˜¯n=4 m+n-1=5 å°±æ˜¯æ•´ä½“æ•°ç»„çš„å¼€å¤´æœ«å°¾ç´¢å¼•
midå°±æ˜¯æ‰¾åˆ°ä¸­é—´ç´¢å¼•çš„ä½ç½®ï¼Œä»0å¼€å§‹éå†åˆ°ä¸­é—´ç´¢å¼• å‡å»mid - left å³4 - 4ï¼Œå› ä¸ºané•¿åº¦åªæœ‰4ï¼Œæ‰€ä»¥éå†ä¸€æ¬¡i å°±å¯ä»¥é€†è½¬æ•°ç»„
æ‰§è¡Œå®Œç¬¬ä¸‰ä¸ªReverseåå°±ç¬¦åˆé¢˜ç›®è¦æ±‚äº†

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-02 15.26.57.mov"></video>

iå…¶å®å°±æ˜¯æˆ‘æ•´ä½“æ•°ç»„æˆ–è€…è¯´æ˜¯å·¦è¾¹æˆ–è€…å³è¾¹çš„ï¼Œå¼€å§‹å»ä¾¿åˆ©å®ƒ

æˆ‘æ•´ä½“è¿™ä¸ªå’Œå·¦è¾¹è¿™ä¸ªéƒ½æ˜¯ä»0å¼€å§‹çš„ï¼Œå’Œä¹‹å‰è®²çš„æŸä¸ªé¢˜æ˜¯ä¸€æ ·çš„

![](/Users/yuebinghui/Documents/program/github/note/images/image-20241002153156416.png)

<u>ä½†æ˜¯æˆ‘å³è¾¹çš„è¯ï¼Œå³è¾¹çš„å€¼ä¸ç­‰äº0ï¼Œæ‰€ä»¥ä»leftå¼€å§‹åˆ°midå‡left</u>

<u>å³è¾¹è¿™ä¸ªè™½ç„¶æˆ‘iæ˜¯ä»0å¼€å§‹çš„ï¼Œä½†æ˜¯å…¶å®ï¼Œå®é™…æ˜¯ä»nå¼€å§‹çš„ï¼Œå› ä¸ºå·¦è¾¹é‚£éƒ¨åˆ†æ˜¯ä»b1~bn-1</u>
<u>æ‰€ä»¥æˆ‘å³è¾¹è¿™ä¸ªæ•°ç»„ä¸‹æ ‡æ˜¯ä»nå¼€å§‹çš„ï¼Œæ‰€ä»¥è¦åˆ°mid-leftæˆªæ­¢</u>ï¼Œåæ­£è¿™å—ä½ è‡ªå·±çœ‹ä¸‹ä»£ç å°±æ˜ç™½äº†

ä¸è¡Œå°±ç”»å›¾èµ°ä¸€éå°±æ‡‚äº†

```c++
#include "func.h"

#define ElemType int

void PrintArr(int A[], int size) {
    for (int i = 0; i < size; ++i) {
        printf("%d\n", A[i]);
    }
    printf("\n");
}


// å·²çŸ¥åœ¨ä¸€ç»´æ•°ç»„A[m+n]ä¸­ï¼Œä¾æ¬¡å­˜æ”¾ä¸¤ä¸ªçº¿æ€§è¡¨(a1,a2,a3,...,am)å’Œ(b1,b2,b3,...,bn)ï¼Œè¯•ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œ
// å°†æ•°ç»„ä¸­ä¸¤ä¸ªé¡ºåºè¡¨çš„ä½ç½®äº’æ¢ï¼Œå³ å°†(b1,b2,b3,...,bn)æ”¾åœ¨(a1,a2,a3,...,am)çš„å‰é¢
bool Reverse(int A[], int left, int right, int arraySize) {
    if (left >= right || right >= arraySize) {
        return false;
    }
    int mid = (left + right) / 2; // è®¡ç®—ä¸­é—´ç´¢å¼•ï¼Œç”¨äºç¡®å®šéœ€è¦äº¤æ¢çš„å…ƒç´ èŒƒå›´çš„ä¸€åŠã€‚
  //è¿™é‡Œçš„leftå¯ä»¥æ¯”ä½œæ˜¯åç§»é‡ï¼Œä½ å·¦è¾¹å¤šå‡ºæ¥å››ä¸ªå…ƒç´ ï¼Œå› ä¸ºä½ æ˜¯ä»ç´¢å¼•ä¸º4çš„ä½ç½®å¼€å§‹çš„ï¼Œæ‰€ä»¥ä½ éœ€è¦å‡å»leftï¼Œæ‰æ˜¯ä½ éœ€è¦å¾ªç¯çš„æ¬¡æ•°
    for (int i = 0; i <= mid - left; ++i) { // å¾ªç¯éå†ä»leftåˆ°midçš„å…ƒç´ ï¼Œå¹¶ä¸ä»rightåˆ°midçš„å…ƒç´ è¿›è¡Œäº¤æ¢ã€‚
      int temp = A[left + i]; // ä¸´æ—¶å­˜å‚¨å½“å‰leftä½ç½®çš„å…ƒç´ ã€‚
        A[left + i] = A[right - i]; // å°†rightä½ç½®çš„å…ƒç´ èµ‹å€¼ç»™leftä½ç½®ã€‚
        A[right - i] = temp; // å°†ä¸´æ—¶å­˜å‚¨çš„leftä½ç½®çš„å…ƒç´ èµ‹å€¼ç»™rightä½ç½®ã€‚
    }
    return true;
0
void Exchange(int A[], int m, int n, int arraySize) {
    Reverse(A, 0, m + n - 1, arraySize); // åè½¬æ•´ä¸ªæ•°ç»„ã€‚
    Reverse(A, 0, n - 1, arraySize); // åè½¬å‰nä¸ªå…ƒç´ ã€‚
    Reverse(A, n, m + n - 1, arraySize); // åè½¬åmä¸ªå…ƒç´ ã€‚
}
int main() {
    int A[] = {1, 2, 3, 4, 5, 6};
    int arraySize = sizeof(A) / sizeof(A[0]);
    PrintArr(A, arraySize);

    int m = 2; // å‰ä¸¤ä¸ªå…ƒç´ 
    int n = 4; // åå››ä¸ªå…ƒç´ 
    Exchange(A, m, n, arraySize);

    PrintArr(A, arraySize);
    return 0;
}
```

##### 13. å·²çŸ¥ä¸€ä¸ªé¡ºåºè¡¨ä¸­çš„å„ç»“ç‚¹å€¼æ˜¯ä»å°åˆ°å¤§æœ‰åºçš„ï¼Œæ’å…¥ä¸€ä¸ªå€¼ä¸ºxçš„ç»“ç‚¹ï¼Œä½¿é¡ºåºè¡¨ä¸­çš„ç»“ç‚¹ä»ç„¶æ˜¯ä»å°åˆ°å¤§æ’åº

###### ä¸ªäººç†è§£ï¼šå®ƒæœ‰åºï¼Œæˆ‘æƒ³æ’å…¥ä¸€ä¸ªå€¼ï¼Œæ’å…¥ä½ å°±è¦æŠŠå…ƒç´ ä»å‰å¾€åç§»åŠ¨ï¼Œå¹¶ä¸”æ˜¯ä»è¡¨å°¾å…ƒç´ å¼€å§‹ç§»åŠ¨ï¼Œå› ä¸ºè¡¨å°¾å…ƒç´ åæ˜¯ç©ºçš„ï¼Œä½ å°±å¯ä»¥æŠŠè¡¨å°¾å…ƒç´ æ”¾åˆ°å®ƒçš„ä¸‹ä¸€ä¸ªä½ç½®ï¼Œç„¶åç´¢å¼•å‰ç§»ï¼Œå†é‡å¤åˆšåˆšçš„åç§»å…ƒç´ çš„æ“ä½œï¼Œç›´åˆ°æ‰¾åˆ°å°äºæˆ–ç­‰äºç´¢å¼•æ‰€æŒ‡çš„å…ƒç´ ï¼Œå°±ç»™ç©ºå‡ºæ¥çš„ä½ç½®æ’å…¥x

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-02 14.03.21.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// å·²çŸ¥ä¸€ä¸ªé¡ºåºè¡¨ä¸­çš„å„ç»“ç‚¹å€¼æ˜¯ä»å°åˆ°å¤§æœ‰åºçš„ï¼Œæ’å…¥ä¸€ä¸ªå€¼ä¸ºxçš„ç»“ç‚¹ï¼Œä½¿é¡ºåºè¡¨ä¸­çš„ç»“ç‚¹ä»ç„¶æ˜¯ä»å°åˆ°å¤§æ’åº
bool Insert_x(SqList &L, ElemType x) {
    if (L.length >= MaxSize)return false; // å¦‚æœé“¾è¡¨æ»¡äº†ä¸æ’å…¥
    int j = L.length - 1; // æŒ‡å‘è¡¨å°¾ 
    while (j >= 0 && L.data[j] > x) { // å¦‚æœå½“å‰æ•°æ®æ¯”xå¤§ï¼Œé‚£ä¹ˆå°±åç§»å½“å‰æ•°æ®
        L.data[j + 1] = L.data[j]; // åç§»ä¸€ä½å½“å‰æ•°æ®
        j--; // ç´¢å¼•å¾€å‰ä¸€æ­¥
    }
    L.data[j + 1] = x; // ç»™ç©ºå‡ºæ¥çš„ä½ç½®æ’å…¥å…ƒç´ 
    L.length++;
    return true;
}

// æ–¹æ³•äºŒï¼Œè¿™ä¸ªæ€è·¯æ„Ÿè§‰æ›´å¥½ä¸€ç‚¹
void Insert_x(SqList &L, ElemType x) {
    int i;
    for (i = 0; i < L.length && L.data[i] < x; ++i); //æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„å…ƒç´ çš„ä½ç½®åœä¸‹

    for (int j = L.length; j >= i; j--) { // ç„¶åä»æœ«å°¾åˆ°içš„ä½ç½®ï¼Œ
        L.data[j] = L.data[j - 1]; // æ•´ä½“åç§»ä¸€ä½ï¼Œç»™iç©ºå‡ºä½ç½®
    }
    L.data[i] = x; //ç©ºå‡ºçš„ä½ç½®æ”¾x
    L.length++;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[5] = {7, 9, 16, 21, 23};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Insert_x(L1, 14);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

##### 14. æ±‚é¡ºåºè¡¨ä¸­å€¼ä¸ºxçš„ç»“ç‚¹çš„ä¸ªæ•° 

###### ä¸ªäººç†è§£ï¼šå¾ˆç®€å•è¯»æ‡‚é¢˜å°±å¯ä»¥æ˜ç™½

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// æ±‚é¡ºåºè¡¨ä¸­å€¼ä¸ºxçš„ç»“ç‚¹çš„ä¸ªæ•°
int count_x(SqList &L, ElemType x) {
    int c = 0;
    for (int i = 0; i < L.length; ++i) {
        if (L.data[i] == x) {
            c++;
        }
    }
    return c;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[5] = {7, 7, 16, 7, 23};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    int c = count_x(L1, 7);
//    Print(L1);

    printf("c=%d\n", c);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

