概念也要看看，不过后面看把，要记忆的

学姐有王道电子书，可以要下

学习一个题目，最好要会画出它的手动过程，这样你记忆代码逻辑根号记忆

记住length是顺序表当前有多少个元素 maxsize是顺序表可以放多少个元素

第二章所有的代码都要掌握，会写

# 线性表

## 线性表的顺序表示-顺序表

###### 顺序表的初始化和插入

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    return true;
}

// i是位序 从1开始
// 数组下标从0开始
// 比如MaxSize 是10
// 比如要插入的i是3

bool InsertList(SqList &L, int i, ElemType e) {
    // 这里小于1是因为位序从1开始，不能比1小
    /*
        i > L.length+1 是因为比如我数组有5个元素，L.length为5，我索引是 0 1 2 3 4
        比如插入一个100，位序是8，那么如果没有 i > L.length+1 这个条件，就会把100插入到索引为7的位置
        值   1 2 3 4 5 空 空 100 空 空
        索引 0 1 2 3 4 5  6  7   8  9
        就会造成这样的空隙
        所以当一共有5个元素，此时索引是0~4，
        那么你位序最多插入的就是<=L.length的位置，即1 2 3 4 5
        也就是位序大于5就会产生空隙了，就不能插入
     */
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    // 我数组已经满了，就不插入元素了
    if (L.length >= MaxSize) {
        return false;
    }
    // j=L.length 就是第一次执行的时候，先把索引为L.length的位置里放入索引为L.length-1的元素
    for (int j = L.length; j >= i; j--) {
        // 就是把前一个元素数据放到后一个元素里
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    // 插入一个元素后length++
    L.length++;
    return true;
}

int main() {
    SqList L;
    InitList(L);


    return 0;
}
```

###### 1. 将两个有序顺序表合并为一个新的有序顺序表，并由函数值返回结果

就是函数返回类型那里，除了常见的int float bool 还可以返回自己自定义的struct结构类型数据

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927141858410.png" alt="image-20240927141858410" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// 将两个有序顺序表合并为一个新的有序顺序表，并由函数值返回结果
bool Merge(SqList L1, SqList L2, SqList &L3) {
    // 两个表相加的长度不可以大于 L3的最大长度，放不下
    if (L1.length + L2.length > L3.maxSize) {                        
        return false;
    }
    // i是L1的索引 j是L2的索引 k是L3的索引
    int i = 0, j = 0, k = 0;

    // 1️⃣遍历L1 和 L2，从0到length，就是遍历整个L1或者L2 哪个表Length短就先遍历完
    while (i < L1.length && j < L2.length) {
        // 拿L1和L2的第一个元素去作比较，哪个小哪个先放入L3
        if (L1.data[i] <= L2.data[j]) {
            // 先把L1的第i个元素放到L3的k的索引上，然后k++ i++
            L3.data[k++] = L1.data[i++];
        } else {
            // 先把L2的第j个元素放到L3的k的索引上，然后k++ j++
            L3.data[k++] = L2.data[j++];
        }
    }

    /*
     检查看L1是否没有遍历完成，没有的话，就把L1剩下的数据，都依次放到L3中
     下面的两个while循环只会执行其中一个，因为1️⃣处那里的条件就是以L1或者L2其中一个遍历完成为结束条件的
     */
    while (i < L1.length) {
        L3.data[k++] = L1.data[i++];
    }
    // 检查看L2是否没有遍历完成，没有的话，就把L2剩下的数据，都依次放到L3中
    while (j < L2.length) {
        L3.data[k++] = L2.data[j++];
    }
    // 最后把k赋值给L3的length
    L3.length = k;
    return true;
}

int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1, j = 1, k = 1; i <= 10; ++i) {
        if (i % 2 == 1) {
            InsertList(L1, j++, i);
        } else {
            InsertList(L2, k++, i);
        }
    }

//    print(L1);

//    print(L2);

    Merge(L1, L2, L3);
    print(L3);


    return 0;
}
```



不懂就自己画图理解

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927144014418.png" alt="image-20240927144014418" style="zoom:30%;" />

###### 2. 将顺序表L1中的数据分类，奇数放到L2中，偶数放到L3中

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 将顺序表L1中的数据分类，奇数放到L2中，偶数放到L3中
bool split(SqList L1, SqList &L2, SqList &L3) {
    int i, j, k;
    i = j = k = 0;

    // 遍历L1这个顺序表
    for (; i < L1.length; ++i) {
        //判断当L1的元素是奇数的时候
        if (L1.data[i] % 2 == 1) {
            // 赋值给L2并且让L2的索引++，后加加
            L2.data[j++] = L1.data[i];
        } else {
            // 如果是偶数，赋值给L3并且让L3的索引++，后加加
            L3.data[k++] = L1.data[i];
        }
    }

    L2.length = j;
    L3.length = k;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }

//    print(L1);
    split(L1, L2, L3);
//    print(L2);

    print(L2);
    print(L3);


    return 0;
}
```



<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927151502394.png" alt="image-20240927151502394" style="zoom:30%;" />

###### 3. L1，L2分别存放两个整数集合，实现L1与L2的交集存放在L3中

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// L1，L2分别存放两个整数集合，实现L1与L2的交集存放在L3中

// 方法1
void intersection(SqList L1, SqList L2, SqList &L3) {
    int i, j, k;
    i = k = 0;
    // 遍历L1这个顺序表
    for (; i < L1.length; i++) {
        for (j = 0; j < L2.length; j++) {
            if (L1.data[i] == L2.data[j]) {
                L3.data[k++] = L1.data[i];
            }
        }
    }
    L3.length = k;
}

// 方法2
//void intersection(SqList L1, SqList L2, SqList &L3) {
//    int i, j, k;
//    i = k = 0;
//
//    // 遍历L1这个顺序表
//    for (; i < L1.length; i++) {
//        // 重置j 不然在一次while循环进入条件的遍历后，j的值会j++ 加上去，当i=2进来的时候没有重置j为0会有问题
//        j = 0;
//        // 遍历L2这个顺序表 并且 找L2里与L1相等的元素，如果不等就j++，直到找到相等的，或者遍历完整个L2顺序表
//        while (j < L2.length && L1.data[i] != L2.data[j]) {
//            j++;
//        }
//        // 看上面的while循环是不满足 && 左右哪边的条件，如果是不满足右边的条件跳出循环的，说明有交集，就要赋值给L3
//        if (j < L2.length) {
//            L3.data[k++] = L1.data[i];
//        }
//    }
//    L3.length = k;
//}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

//    print(L1);
//    print(L2);
    intersection(L1, L2, L3);

    print(L3);
    return 0;
}
```



























## 线性表的链式表示-链表