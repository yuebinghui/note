# 2

![image-20240914195747628](/Users/yuebinghui/Documents/program/github/note/images/image-20240914195747628.png)

来，我们来看一下这道题，要解答这道题，首先我们看到的就是一个时间复杂度，对吧？那么我们来看一下时间复杂度的一个概念。算法的时间复杂度，比如说我说这个算法，

它的时间复杂度是大of n，这个fn就意味着这是一个和n有关的一个函数，对吧？那么，它意味着什么呢？它意味着在任何情况下，那么这个在任何情况下，其实就是说在最复杂，最坏情况下。这也就意味着这个。也就是说，在最坏情况下，规模为n的一个前提下，注意这是一个前提。也就是说，

时间复杂度之中，暗藏着这个前提。然后<u>你所花费的时间，你时间上的一个规模是小于等于k倍的fn的。这个k是一个常数是和n无关的，就是说不管你这个n取几你这个k都是不变的</u>。那么有了我们这个概念之后，我们来看一下abcd四个选项，首先看a选项有问题吧？AD选项其实同一个问题就是说问题规模这个概念是你在说这个时间复杂度的时候。就隐含好了你的问题，规模就是n这是我们公认的默认的，而不是说你的问题的规模是n方呀，与n方成正比呀。这里这个n方和问题规模是没关系的，

然后看一下b选项，执行时间等于n方。出了两个问题，对吧？第一不是等于对吧？而是小于等于主要的问题是一个小于对吧？就是你是它的一个上界，并不是等于对吧？第二个问题是不是n方，而是k倍的n方，那么这个k倍的n方其实意味着什么呀？是不是就意味着c选项是成正比呀？那么，这道题我们就能选出来，是一个c选项。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914192925378.png" alt="image-20240914192925378" style="zoom:50%;" />

# 3

![image-20240914195738284](/Users/yuebinghui/Documents/program/github/note/images/image-20240914195738284.png)

我们来看这道题，那么这道题啊，其实就是考察算法原地工作啊，这么一个简单的概念，那么我们知道算法原地工作就是指算法所需的辅助空间啊，为常量，那么也就是说算法。算法的空间复杂度啊，为o1也就说这三个概念，其实同一个意思，第一个是算法原地工作，第二个是算法所需的辅助空间为常量，还有什么换句话来说就是什么？算法的空间复杂度为o1嘛，所以本题的正确选项就是b选项所需辅助空间的大小与规模n，

它没有关系，那么就说明什么算法的空间复杂度为o1。这才是它的正确理解，那么a cd啊，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914193420636.png" alt="image-20240914193420636" style="zoom:50%;" />

都是不对的，我们来分析一下，比如说一个简单的算法，一个for循环。通过一个for循环啊，把一个数组a[i]的值啊，都给它赋初值为零，那么对于这个算法来说，它需不需要额外的辅助空间呢？那么其实它是需要的，对吧？

因为这里是不是啊？借助了一个整形变量I嘛，对吧？每次通过I的自增。我们来选中这个数组元素，然后把这个数组元素的初值啊哎赋为零，那么这个变量I它的是它是不是占四个字节啊？因为一个整型是占四个字节嘛？那么，通过I的自增给数组元素赋出值，那么是不是不管这个n啊？为多大？那么这个变量I是不是始终占四个字节啊？所以它是需要辅助空间的，并且这个辅助空间的大小是不是和这个n啊是没有关系的，

对吧？这个算法整体所占的空间大小是不是和这个n啊？是不是必然是有关系的，这个n越大。那么，是不是说明这个数组元素就越多，对吧？那么数组元素越多，那么所需的空间哎就越大，<u>所以整体的空间大小是与规模n啊是有关系的。但是我们研究什么啊，空间复杂度，空间复杂度研究的是什么啊，辅助空间的大小那么？对于一个简单的for循环来说，</u>

<u>它不需要开辟额外的辅助数组，也不需要递归来执行，对吧？所以它的辅助空间啊，就是一个常量，</u>也就是说和变量n是没有关系的。本题的正确选项为b选项。好的本题讲解结束，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914194523386.png" alt="image-20240914194523386" style="zoom:50%;" />

# 5

![image-20240914195723320](/Users/yuebinghui/Documents/program/github/note/images/image-20240914195723320.png)

这道题是我们判断算法的时间复杂度的一类经典问题。它的难度不高，主要是要求我们学会一下大致的一个思路，怎么做？

首先我们可以注意到，在提到时间复杂度的时候，我说过。n是它所默认的给你的一个问题的规模，这时候我们看到这里的n作为参数而存在，然后导入到了这里。它是与你真正核心运算步骤，还记得我所说的吧，时间复杂度就是指在问题规模n的情况下，你的核心运算运行了多少步？那么，毫无疑问，这个运算之中，这个就是我们的核心运算，对吧？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914195424791.png" alt="image-20240914195424791" style="zoom:50%;" />

都不用你来判断，因为它只有这一句运算，对吧？那么，我们可以看到这步核心运算的运算次数是和你n有关的，这就是你问题规模n的一个意义所在。然后我们接下来进行判断，就是判断一下这一步要执行多少次。那么剩下来就是一个数学和逻辑上的一个问题了，从逻辑上来思考这一步是什么？是不是把I进行一个I的乘二的一个操作呀？那么IE开始是多少呀？是不是一呀？你是不是乘一个二，这就是一次运算，

然后往后走，如果没有到n的话，是不是要继续乘二？这是不是第二次执行这个I=I×2这一步，往后是不是一直执行这个呀？那么这个是什么呀？这个一直是不是I呀？直到什么？是不是小于等于n呀？那么你现在是不是就想知道，从一开始一直乘二×2×2乘多少次二你就是n了呢？或者说是小于等于n了呢，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914195534337.png" alt="image-20240914195534337" style="zoom:50%;" />

那么整个思路一转化，是不是就是二的多少次方？是嗯呢。

说的严谨一点，这里依然是一个小于等于那么我们继续往下走这一步，是不是就是一个小于等于log 2的n呀？也就是说，你的一个执行次数是小于等于log 2的n次的。这是不是我们之前所提到过的时间复杂度的一个概念呀？小于等于。注意这里。这里这个小语短语和我们这里这个小语短语是相互契合的，我们在这里其实计算的时候是没必要考虑这个的，我为了说清楚概念才故意提及了一下这个。你在实际做题的时候，这个小于等于直接把它当成是等于号来做，做出来的结果直接选。就没问题了。

但是在概念上，你要明白，你是一个小于等于的关系，然后最后我们得出来，这个结果就是我们的最后的选项就是一个d选项。没有什么问题，这道题。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914195701274.png" alt="image-20240914195701274" style="zoom:50%;" />

# 6

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914200442298.png" alt="image-20240914200442298" style="zoom:50%;" />

来，我们来看一下这道题。同样是一道判断时间复杂度的题，那么你要判断一个时间复杂度，你是不是第一步操作就是找出来你的核心预算是谁啊？也就是说，我们关注的焦点是谁？这时候我们注意我们的关注的焦点应该是它，而不是这儿。为什么？因为这里是对I进行了一个推进的作用，也就是说你一步一步I是等于I+1，这就是一个I加加的作用，对吧？你是逐步在将I往后推进的，

在改变I的数值，并将它一步一步与目标。逐渐靠近的，而你这里的I的三次方，它实际上只不过用于算出来了I的三次方这个值，然后与n进行了一个比对，然后你的I三次方这个值你是没有。存下来的，你是没有参与到，再付给ii这样一个操作的，如果你有这样一个操作，那你就是一个核心运算，对吧？但实际上，我们I的一步往后推进，

是由这一个完成的。也就是说，我推进是逐渐加一+1+1推进的，而我每加一次一，我就进行一次判断。当前的I的三次方是。是不是符合这个要求？同样，如果不符合的话，我是继续加一，而不是将你三次方的这个值进行再一次三次方来判断。这儿懂我意思了吧，这实际上就是一个读程序的一个问题，如果你做错了这道题，可能是你看到这里直接就往下开始做了这样。

这样不好，要学会认真读题，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914200141146.png" alt="image-20240914200141146" style="zoom:50%;" />

判断出来你的爱到底是怎么加出来的，再判断一下你的逻辑条件是什么？那么，我们得到这一步之后，我们是不是只要得出来I到底加了几步就可以了？那么I到底加了几步呢？是不是你就想找出来，最终符合要求的那个I是几？你就加了几步，因为你是逐渐加一加上来的，而我们这里的数值是零，对吧？所以你I是几你就加了几次，

对吧？所以。这个逻辑是我们关注的重点了，你的逻辑是一个I的三次小于等于n，你只要符合这个条件，你就会一直加下去，对吧？如果你不符合这个条件，你是不是就不会加下去了？也就是说，你要找到第一个I的三次方大于n的那个I，还记得我之前说过什么吧？如果说你只是想得出来这个值是什么？中间这个符号是不是你不用管呀？小于等于只不过是为了和你的一个。

时间复杂度那里的小于等于进行一个契合关系，而这里的大于只是供我们进行一个判断，你直接把它当成一个等于来算。I的三次方等于n，那么I是不是等于k三次的n呀？这是不是就是你最终的一个时间复杂度大o中间的那个函数呀？就是c选项呀。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914200402222.png" alt="image-20240914200402222" style="zoom:50%;" />

# 7

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914200812546.png" alt="image-20240914200812546" style="zoom:50%;" />

我们来看一下这道题，实际上这道题就是需要双层for循环，然后内层再嵌套的一个if判断语句对不对？它问你的是最后一场语句，在频度，在最坏的情况下是什么样的？也就是说，你直接看。这里是不是有一个if呀？如果if判断成功了，是不是才执行它呀？那么既然是最坏情况，你直接不管这个if是不是就行了，你直接看这个for循环，它进行了多少趟，

对不对就行了，那么我们来看一下。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914200913556.png" alt="image-20240914200913556" style="zoom:50%;" />

那么我们来看一下。第一层for循环是不是I从n- 1一直减减到一？然后在那一层是不是从j从一一直到I？那么，我们看到这是不是一个是相互相当于是相互调用的，那么至于第一层，你从n- 1到I。你从n- 1到一和从一到n- 1，是不是没有区别？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914201636579.png" alt="image-20240914201636579" style="zoom:50%;" />

所以说我们直接改成从一到n- 1，然后下面是从一到I。相当于上面这个是等于I的，那么我们来看一下你整个加的一个过程是什么？是不是相当于是相当于是这样呀？因为你第一层I是等于一的，
你这里相当于是零，那么第二个是不是你加了一步？这是不是两步是不是相当于是一到二？为什么因为在这一行循环里面，你是不是一到二啊？你的I取的是二。二对不对？那么再看这一层是不是一二三呀？那么我们这里是不是第一个是一，第二个是两步，第三个是三步，往后是四步，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914201728459.png" alt="image-20240914201728459" style="zoom:50%;" />

你要算多少步呀？是不是零+1+2加？一直加到n里了。
那么，这是不是一个数列求和呀？你求和下来，你不管怎么样，肯定是一个二分之n乘以n减一，那么你这个n是不是这儿就出现了一个n方呀？所以说你的一个频率的复杂度是不是就是大on方呀？所以说选的是一个d选项，那么如果你学过后面也是在复习的话，你会发现这个算法实际上考察的是一个冒泡排序，既然是冒泡排序的话，那么你应该直接选出来这个。复杂度。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914201825673.png" alt="image-20240914201825673" style="zoom:50%;" />

# 8

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914202444859.png" alt="image-20240914202444859" style="zoom:50%;" />

这样的一个程序代码段，或者说这样的一个算法，让我们去分析它的时间复杂度的时候啊，我们就取它的所有的分支路径上最大的那一个。

它的时间复杂度啊，最大的那个分支，那么就是它整体的一个时间复杂度，那么对于本道题来说啊，那么就是on方。所以正确选项就是a选项。注意啊，它不是把所有的分支路径上叠加，而是取最大的，比如说我这里啊，一共有n个分支，然后每一条分支啊，它的时间复杂度啊，都是on。那么，

它整体的时间复杂度，我们还是还是记作on的，而不是说所有的n啊给它加起来就等于on方，那么这个理解是不对的，是取所有的分支上它的什么？最大的那一条分支上的时间复杂度记做它整体的时间复杂度好的，这是一个简单的概念问题，



# 9

好的本题检点结束来我们来看一下这道题，这道题依旧是考一个。执行次数最后一行，那么我们来看一下这道题，这道题一开始定义m=0 I和j，然后双层for循环嵌套，那么第一层for循环是不是简简单单定义了一个ii是从一到n也是逐？逐个相加，那么第二层for循环是不是j从一到2I中间也是通过加的一个方式呀？
那么我问你，在不管I的情况下，也就是说I只是一个I没有带入具体的数字之前。你的这个j从一通过加加加到2I，你总共要执行多少个步骤？是不是2I步呀？那么我问你，你的I是从一到n的，你是不是每一步都要嵌套一下里面这个呀？所以说你一共要执行多少步？一共是不是要执行I=1的时候是二？乘以一，然后I=2的时候是不是二×2，然后继续往下嵌套，是不是加二×3一直加，
也就是说二乘以括号一+2加？加到n呀。OK，那么知道了这个之后，后面这个是不是一个是不是就是二分之n乘以n加一呀？所以说这道题我们选的就是一个a选项。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914202945324.png" alt="image-20240914202945324" style="zoom:50%;" />



好，我们来看这道题，那么这道题啊，是要求我们去分析关于这个递归代码，它的一个时间复杂度的，那么我们说过对于这样的递归代码，让我们去分析它的时间复杂度。那么，递归代码段啊，
我们也其实可以看作什么，可以看作多重循环，比如说我的循环变量I啊，其实就是这里的n对吧，那么第一次。这个I啊，等于n的时候，那么我我们是不是执行单层for循环对吧？if n=1，那么就return 1，其实就执行的就是这句话。那么，它的单层循环次数啊，是一次那我第二次是不是执行的时候return是二乘以这个这个二分针对吧？func 2分针那么二分针的时候啊，
显然也是执行一次。然后我们接下来执行四分之n八分之n那么一直到最后一的时候，那么执行啊，也是一次那么对于这样的话，我们去算它的时间复杂度，其实是不是就去考虑它一共执行了几次递归对吧？那么从n。到二分之n，到四分之n，到一那么一共执行了几次呢？我们假设。它这里的递归次数啊，是k次，那么我假设为了方便计算，那么这个n啊，
它等于什么二的k次方，那么也就是说我现在二的k次方啊，是等于n的。那我这个递归次数啊k啊，它是不是等于log以二为底n的对数对吧？那么log以二为底n的对数，我们说它这个算法的时间复杂度啊，是不是处于对数级别啊？那么我们就可以记做什么？o log n嘛，对吧？所以正确选项就是c选项，那么这个底数啊，是可以不写的，也就是说这个无论是哪个底数，
只不过是相差一个什么常数倍的关系，所以我们这里可以记住什么log n。这样的记法。那么，正确选项就是c选项，那么本题啊，其实是降低难度了，如果我把这道题改一下啊，我把这道题改一下，这里不是二乘以这个func，我是这样写，我是func啊我。n除以二，也就是二分之n，然后再乘以它本身哎func哎n除以二，
然后再加上n对吧好，我假如啊，不考虑任何的这个哎，编译优化的情况，也就说我必须先算完这个，然后把这个再算一遍。哎，我问你这样的话，他的时间复杂度又变成多少人了？大家考虑一下啊，先暂停一下，自己思考一下好，那我现在开始讲啊，如果把题目改成这样的形式的话，那么其实啊。
分析方法还是一样的，还是把一个什么递归代码段看成一个多重循环，那么它的循环变量I啊n啊，还是从n变成二分之n还是到四分之n到一？那么，唯一不同的是什么呢？这里的单层循环次数啊，变了，那么作为当I=n的时候，那么第一次的时候，那么它是return 1哎，没问题，它只是一次。那么，我们大家考虑一下，
二分针的时候，它执行几次呢？因为它是不是要执行两个二分针对吧？两个二分针，那么这里显然是就是什么两次的？那么，四分针的时候呢？因为对于每一个二分针啊，每一个二分针，它是不是它是不是都要去执行两个四分针对吧？这里要执行什么？四分之n，这里也要执行四分之n，所以四分之n的时候，它是不是要执行几次啊？
它是不是要执行四次啊？对吧？那么最后这个一一是不是相当于n分之n？对吧？那么最后是不是相当于这里要执行n次啊？那么这个时候它总的执行次数是不是从一+2，然后加四，然后点点点一直要加到n嘛？好，那么为了方便计算，我假设这个n啊，它是等于什么二的k次方？假设我n=2的k次方，那么也就是说这个式子就等于一+2的一次方，加上二的二次方点点点，
那我一直再加到二的k次方，那么就是这个什么？等比数列求和，大家可以去算一下它最后的答案应该是什么？二的k+1次方减一。那么，我们是不是要给它写成一个关于这么n的一个表达式啊？因为我们的时间复杂度分析的是和这个n的关系，对吧？那么二的k+1次方减一我这个n啊，又等于二的k次方，它是不是就等于一个2 n- 1对吧？那么，如果之后大家学到的这个完全二叉树啊，那么就有相关的结论了，
那么很多人就知道好。它就等于啊二n减一，那么二n减一，它的时间角度是不是就变成on呐？对吧on呐，那如果说题目改成func二分之n，然后再乘以个func二分之n，那么这样的话。它的时间复杂度啊，就是on的那么这样一改啊，很多同学啊，可能就会在这里犯迷糊了，那么其实什么分析方法是不是一模一样的，只要掌握了这样的，哎，
这么一个分析方法，那么其实。所有的关于递归的一个时间复杂度的分析啊，其实就是可以看成什么多重循环好的本题讲解结束。

# 16

<u>设k为执行的次数</u>

来看一下这道题。他问的是时间复杂度。我们最容易想到的做法就是。求出<u>sun加加这条指令执行的次数。执行的次数</u>知道了，时间复杂度也能够得到。它是一个两层循环，两层循环，我们先拆外层的循环。

外层的循环I是从一开始的，那I的取值会有哪些？我们列出来。它每次都是字乘以2 一直乘到最后的。要保证I小于n。
所以I应该是一二。四八等等，一直到二的k次方，它要保证I小于n，所以二的k次方应该是小于n的。<u>这就是外层的取值。</u>

那对于每一个外层的i，j有多少种可能的取值呢？<u>j是从零开始，j小于I。那就是零到i- 1。而j是j加加的，</u>
<u>所以总共会有I个取值。</u>
那对于每一个I都有I个取值，
我们只需要把所有的I相加即可。
I=1的时候加加执行一次
I=2的时候上加加执行两次
I=4的时候上加加执行四次。
所以就是把它们加起来。一直加到二的k次方。

这个应该是很好计算的，就是等比数列。它们求出来应该是二的k+1次方减一。这里我们得到的是k。题目中要求的是和n有关。
<u>注意一下二的k次方是小于n的。</u>
<u>所以二的k+1次方减一应该小于2n。</u>

根据时间复杂度的定义。执行的次数是零到2n之间。根据时间复杂度的定义，那我们就能够得到它的时间复杂度应该是on的。所以这道题就应该选b。

那对于所有的这一类的题，我们最基本的方法都是这样做。求出循环内这条指令执行的次数。从外到内，一层一层拆开循环，先拆外层的循环。看外层的循环有哪些取值。也就是这里的I，然后对于外层循环的取值，求出内层循环可能执行的次数。一定要注意的是。他们不一定都是I加加和j加加的。那本题选择b。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191405926.png" alt="image-20240914191405926" style="zoom:50%;" />

## 循环的时间复杂度总结

指数爆炸(<a href="/Users/yuebinghui/Documents/program/github/note/笔记/数学/周洋鑫/06.1零基础核心考点精讲5-2.md#指数爆炸">指数爆炸</>)

<a id="指数爆炸">指数爆炸</a>

### 每一层循环变量都是++

那接下来给大家介绍一下循环的时间复杂度总结。我把它分为两个类型，第一个类型比较简单，它的特点是每一层循环的变量都是I加加j加加k加加。这样的它可能出两层循环，三层循环，
四层循环都没有关系。只要都是I加加的，而且。这种时候我们可以不需要求出指令执行的次数，可以通过一些技巧直接得到答案。对于这一类问题，我们可以求出I的取值范围。j的取值范围k的取值范围。比如说，对于第一层循环I的取值范围应该是零到n- 1，所以应该是n。j的取值范围也是零到n- 1，应该是n。k的取值范围也是零到n- 1。它也是n。
我们要求的是时间复杂度，而不是具体的执行次数，只需要求出一个大概的范围。把这三个相乘即可。这是很简单的，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191630413.png" alt="image-20240914191630413" style="zoom:50%;" />

而第二种有一些小的区别，它们的区别在什么地方呢？第二种。j是受到I的取值影响的k，又受到j的取值影响零，这样的话，第一层应该是零到n- 1。第二层应该是零到i- 1，第三层应该是零到j- 1。如果按照这样做的话，
我们得到的答案应该是n×I×j。我们可以通过放缩法来进行一个计算。因为I的范围是零到n- 1的，我们取一个最大的值取一个n。把n带入进去。然后j我们也用n代入进去，所以它的答案也是n×n×n也就是n的立方。那对于这一类的问题，我们只要看到它是I加加j加加k加加，然后我们把它的范围看一下。这里j和k的范围虽然都和I和j有关，但是I和j都是小于n的。所以我们放缩的话，都可以把它放缩成n，那就直接每一层都是n，然后相乘即可。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191850617.png" alt="image-20240914191850617" style="zoom:50%;" />

对于第一种类型的两种，虽然它们有一些细节上的不同，但是我们可以发现它的时间复杂度是一样的。我们看到第二种的时候可以直接完全按照第一种的时间复杂度来计算，这就是类型一类型一的话，我们不需要完全求出。每一条指令的具体执行次数，我们要记住的是，它求的是时间复杂度。这样的话，考试就能给我们省下大量的时间，不只是在选择题中，还可以在自己的。是还可以在自己算法的时间复杂度，
估计中。来进行计算。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914192134302.png" alt="image-20240914192134302" style="zoom:50%;" />

而第二种类型有一个特点是。它不是一个单纯的I加加和j加加，它是有一些别的变化。它可以是I=I×2，也可以是I=I×I等，等我们要根据具体的题目来讨论I的取值。或者它在第二层j不是j加加可以改成j=j×2等等，我们要根据具体的题目具体分析。而对应的做法就是我们先拆开最外层的讨论，最外层有哪些取值？比如说这里I是一二。四八等等。一直到二的k次方。
而如果这里改成I=I×3呢，那就变成了一三。九，27等等。二，三的k次方。具体的题目要具体的去分析，而不是和类型一一样，可以套一个什么样的东西。一定要注意它的变化，到底是I=I×2还是I加加还是什么什么？这可以有助于我们区分它的类型。这就是两种情况的总结类型，一是我们可以套一个公式，把每一层的最大便利次数相乘即可。
而类型二，我们需要从外到内，一层一层拆开它，一般不会超过两层循环，因为这样计算起来会很麻烦。我们需要做的就是判断清楚它的边界条件，比如说这里I小于n，这里j小于I。然后讨论它每一次循环的过程中，到底是I=I×2，还是I=I加？加一分清楚这些东西，然后再具体的去计算。这就是循环的时间复杂度总结问题。那具体讲解到此结束。