各位同学大家好，从这个小节开始，我们会学习怎么实现单链表的某一些基本操作，那这个小节我们要学习的是如何实现插入和删除，我们会分别探讨，如果一个单链表，它带头节点或者不带头节点的话。那怎么实现按位序插入这个功能？

那除了按位序插入之外，我们还需要掌握，如果给定一个结点，那么怎么在这个结点之后和之前插入一个新的结点？

删除操作也是类似的，给你一个位序，你要知道怎么删除这些节点，

或者直接给你这个节点的指针，你也要知道怎么把它删除。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240920210448198.png)

那在之前的学习中，为了帮助大家慢慢的补上基础，所以我们在给这些图示的时候，都会给大家展示这些数据，它在内存当中到底是怎么样？然后像MA lock函数，还有free函数这些，它背后是一个什么样的过程，相信通过之前的那些学习，大家已经能够掌握这些比较基础的东西了，所以之后我们再给这些图示的时候会稍微简化一下。我们不会再画出这些结点，它在内存当中到底是怎么样分布的

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240920210531076.png)

## 按位序插入（带头结点）

好？那下面探讨第一个问题，
如果这个单链表它是带头结点的话，那么怎么实现按位序插入这个操作？我们要在第i个位置插入一个指定的元素e，那这样的话，我们是不是需要找到第i减一个结点，因为我们肯定需要把第i减一个结点的next指针给修改。比如说如果I=2，也就是说我们要在第二个位置插入一个新的结点的话，那么我们就需要先找到第一个结点，然后用malloc申请一个新的结点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240920210812802.png)

往这个结点里存入数据元素e。接下来，对指针进行修改，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240920211335937.png)

这样的话，这个新的结点是不是就变成了第二个结点诶？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240920211350450.png)

那如果我们想要在第一个位置，也就是I=1的时候想在这个地方插入一个新的结点的话，怎么办呢？那这个地方大家就能够体会到带头结点的这种单链表的好处，我们可以把这个头结点看成是第零个结点。所以当I=1的时候，刚才我们分析的这一套处理逻辑其实也是适用的

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240920211544599.png)

好，来看一下具体的代码，实现这个函数当中传入了一个呃单链表。然后这个单链表是带头结点的。然后指定了此次要插入的位置位序，并且给出了新结点当中要存放的数据元素。好，那来分析一下，
刚才我们说的这种情况，如果I=1，也就是要在表头的位置插入一个新元素的话。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240920211654253.png)

首先，这个地方有一个判断，如果i小于一的话，那说明这个i的值不合法，因为i表示的是位序嘛，位序是从一开始的，所以如果传入的这个参数本身不合法的话，直接return false。表示插入失败好，那由于此时我们的i=1，因此这儿会声明一个指针p。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921181317729.png)

然后这个指针p它是指向了呃和L相同的位置，也就是指向了这个头结点。

然后这儿我们定义了一个变量J，表示的是当前p，它指向的是第几个结点？那之前说了头结点，我们可以把它看成是第零个结点，所以此时j的值应该是零注意啊，虽然这儿我们把它杜撰出了一个所谓的第零个结点。但其实单链表当中实际存放的是后面这些节点对吧？而这些节点的编号，它是从一开始的，所以我们不允许i值小于一。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921181729894.png)

好，那接下来就会开始执行这个while循环，此时p不等于null，这是满足的，

但是j小于i- 1这个条件不满足，因此这个循环不会执行，它会直接跳到下面。好，那这一句会申请一个呃新的节点空间。然后把参数e存到新结点里面，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921182141487.png)

接下来这一句它会让s指向的这个结点的next这个指针。让它等于p结点的next指针指向的这个位置，也就是指向这儿

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921182342336.png)

最后这一句，它会让p结点的next指针。指向这个新的结点s也就是这样子好，那这样的话，我们是不是就实现了在第一个位置插入数据元素e这个事情？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921182410322.png)

### 代码

```c++
#include "func.h"


#define ElemType int
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *Linklist;

bool InitList(Linklist &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (!L) {
        return false;
    }
    return true;
}

bool ListInsert(Linklist &L, int i, ElemType e) {
    if (i < 1) return false;

    LNode *p;
    int j = 0;
    p = L;

    // i
    // 1 进不去while循环
    // 2 可以进去执行一次
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (!p) return false;

    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;


    return true;
}


int main() {
    Linklist L;
    InitList(L);

    printf("%d\n",ListInsert(L, 1, 10));
    printf("%d\n",ListInsert(L, 2, 20));

    return 0;
}




```



### 最好时间复杂度

那由于I=1这个y循环直接被跳过了，所以这种情况下只需要o1这样的时间复杂度就可以执行完成。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921182507770.png)

那这段代码想提醒大家注意的是，最后的这两句是不能颠倒的，如果先执行黄色箭头，这一句再执行绿色箭头，这一句那是会出问题的，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921182534855.png)

来看一下。经过前面的一系列执行，现在状态是这个样子，然后如果我们先执行黄色这一句，也就是先让p结点的next。指向s这个结点。然后再执行绿色这一句，也就是让s结点的next指针和p结点的next指针指向同一个位置。那这样的话，
这个指针就会指向它自己，所以你看这两句代码写错的话，这个链表就变得奇奇怪怪的，然后后面这些小朋友就都走丢了。这个链已经断了，所以这两句代码大家一定要注意

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921183043874.png)

好，接下来分析另一种情况，如果I=3的话，那此时i- 1就应该是二。那前面的这些操作会导致j的值等于零，然后p指向头结点，然后接下来开始这个while循环。此时p不等于n同时j也小于二，所以会执行这个循环里边的代码，让p=p的next，也就是让它指向下一个节点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921184100237.png)

所以j的值就变成了一好，那由于此时j依然是小于二的，所以第二轮循环的条件也是满足的，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921184202058.png)

因此还会再执行这个循环，里边的代码。p会指向再下一个节点，同时j的值会再加一，也就是变成二，那由于这个条件，此时已经不满足了，所以这个循环结束会执行后续的语句。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921184522690.png)

那再往后的话，是不是和刚才一样，就是申请一个节点，然后把这个指针给依次修改？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921184538522.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921184550758.png)

这样的话，我们就在第三个位置插入了数据元素e。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921184930752.png)

好再下一种情况，如果I的值等于五的话，那么首先p同样是会先指向这个头结点，然后i- 1的值就应该是四。j的值刚开始也是零第一次执行这个循环p会往后移一位，然后j的值变为一

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921184954665.png)

第二次循环p又会指向再下一个节点，然后j的值变为二。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921185107663.png)

第三次。是这样，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921185120365.png)

第四次。是这样。好，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921185135197.png)

那当j=4的时候，这个条件不满足了，对吧？然后就可以跳出循环执行之后的语句。对了，再次强调这个j的值，表示的是当前p指向的是第几个结点，而我们执行这个循环的本质原因，最终的目的是想要找到第i- 1。一个结点，因为我们要插入的是第i个结点，所以只要我们找到了第i减一个结点，然后我们就可以用后续的这些代码把新结点连到第i减一个结点之后就可以了。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921185611085.png)

所以大家在看代码的时候，除了能够看懂每一句它是什么意思之外，
也应该有一个全局的宏观的思维，比如你要知道这整篇代码，其实它就是要找到第i- 1个结点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921185957820.png)

然后后续的这些代码就是要在第i- 1个结点之后再插入一个新的结点，这样的话，你的这个算法逻辑是不是就很清晰了？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921190039799.png)

好继续往后分析这儿的malloc会申请一个新的节点，然后把数据元素填到里边，接下来会让s的next指向p的next。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921190200627.png)

而由于p结点以前是指向null的，所以经过这一步，运算s结点也会指向null，最后再让p的next指向新的这个结点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921190234869.png)

### 最坏时间复杂度

那这样的话，我们就在第五个位置，
也就是表尾的位置加入了一个新的结点。那由于此次要找的这个结点是最后一个结点，所以这个while循环的循环次数是最多的，因此把新结点插到表尾，这种操作就是最坏的情况，这种情况下它的时间复杂度就应该是on。这儿的问题规模n指的是这个表的长度好，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921190343261.png)

最后再来分析I=6的情况，此时这个表它的实际长度其实只有四，对吧？所以在这种情况下，如果要插入新结点的话，那最多是插入第五个结点，不可能直接插入第六个结点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921190752822.png)

来看一下这段代码怎么处理这个问题，
首先还是一样的p是指向头结点，然后j的值刚开始是零。然后i- 1的值是五，经过第一次循环p会往下移一位，然后j的值变成一，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921190821236.png)

第二次循环p再往后移一位j的值变为二。第三轮循环j的值变为三，第四轮循环j的值变为四好，此时p不等于n，这个条件是满足的。同时，四也小于五，这个条件也是满足的，所以还会进行第五轮循环，第五轮循环p指针会指向当前结点的next。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921191419111.png)

也就是指向这个位置，然后j的值变为五好，再往后的条件检查p，此时是不是等于null这个条件就已经不满足了，对吧？所以while循环结束，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921191455773.png)

就可以执行下面这个if语句。那p等于n是不是说明第二减一个结点是不存在的，现在连第二减一个结点我都找不到，那我怎么可能插入第二个结点呢？所以就直接return一个FALSE。因此，如果这个I的值太大的话，那么最终会因为这个条件不满足而跳出循环。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921191624556.png)

### 平均时间复杂度

好，
那这就是带头节点的单链表，按位插入的，实现基础不好的同学需要好好看一下这个循环怎么用？这个循环实现让p指针依次往后扫描这个事情。同时，我们设置了一个变量j用j的值来标记p指针，此时指向的是第几个结点？另外还有这个地方，这两个语句不能颠倒好，那经过之前顺序表相关的那些小节的学习不难看出呃，如果要按位序插入的话，那平均时间复杂度应该是on这个数量级。这就不再展开

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921191950033.png)

## 按位序插入（不带头结点）

好，那接下来我们要看的是，如果说这个单链表它不带头节点的话，
这个操作的实现有没有什么区别？其实基本的思路是一样的，你可以先找到第i减一个结点，然后把新结点放到这，第i减一个结点之后。就可以了，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921192354078.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921192409429.png)

只不过由于不带头结点，所以不存在所谓的第零个结点，因此如果此时我们是要在第一个位置插入这个元素的话，那么我们需要对这种情况进行特殊的处理。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921192436879.png)

那具体的代码实现是这个样子，这儿我们对i=1的情况进行了特殊的处理，好在这种情况下，首先也是会malloc先申请一个新的节点。接下来把e写到里边，再往后会让新结点的next指针指向L所指向的这个结点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921192644134.png)

最后，需要修改头指针L，让L指向这个新的节点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921193108378.png)

然后return true表示插入成功。所以可以看到，如果这个单链表它是不带头结点的，单链表的话，那么当我们插入或者当我们删除第一个结点，第一个元素的时候，我们肯定需要更改这个头指针的指向。但是如果带头结点的话，那头指针肯定永远都是指向那个头结点的，所以由于不带头结点的情况下，对第一个结点的操作。
需要专门写一段逻辑来处理，所以到这儿大家应该就能够体会到为什么说不带头节点的单链表，它的那个代码写起来一般会更麻烦一些。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921193417085.png)

好继续往后，如果i不等于1，i大于一的话，那其实后续的这些处理是不是和带头节点的那种情况是一样的，唯一需要注意的是这儿我们把这个j的值把它设置为1。表示p指针刚开始指向的这个节点是第一个节点，那后续的代码逻辑都是一样的，就不再分析。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921193650407.png)

那推荐大家自己写代码的时候使用带头节点的这种方式，我们在之后的讲解当中，除非特别声明，不然我们默认使用带头节点的这种方式来实现代码。当然，考试当中两种情况都有可能考察，那大家在做题的时候就一定需要注意审题，别看错了，条件

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921193711643.png)

### 代码

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

bool InitList(LinkList &L) {
    L = NULL;
    return true;
}

bool ListInsert(LinkList &L, int i, ElemType e) {
    if (i < 1) {
        return false;
    }
    if (i == 1) {
        LNode *q = (LNode *) malloc(sizeof(LNode));
        q->data = e;
        q->next = L;
        L = q;
        return true;
    }

    // i
    // 1 进入不了循环
    // 2 进入不了循环
    // 3 进入了

    LNode *p;
    int j = 1;
    p = L;
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (!p) return false;

    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}

int main() {
    LinkList L;
    InitList(L);

    ListInsert(L, 1, 10);
    ListInsert(L, 2, 20);

    return 0;
}
```



## 指定节点的后插操作

好，那接下来要探讨的是怎么实现后插操作，也就是说给定一个节点，在这个节点之后插入一个数据源。元素e那由于单链表的这个链接指针只能往后寻找，所以如果给定一个节点p的话，那其实p之后的那些节点我们都是可知的。我们都可以用循环的方式把它们都给找出来，但是p结点之前的那些结点我们是不是就没办法知道了？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921193905704.png)

### 代码

```c++
bool InsertNextNode(LNode *p, ElemType e) {
    if (!p)return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    if (!s) return false;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return true;
}
```



好，那我们要实现的是在p结点之后插入数据元素e。首先还是一样的，malloc申请一片空间，然后这儿我们加了一个条件判断，如果malloc函数执行的结果，它返回的值是一个none的话，那么说明此次内存分配失败。这种情况其实是有可能出现的，比如说内存已经满了之类的，这个小细节我们之前没有说过，当然了，考试手写代码的时候你不写这个，其实也没有关系。不过大家还是要知道，有可能发生这样的情况好了，如果此次内存分配成功的话，那会接着执行后续的代码，
把数据元素e填到这个新节点当中。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921194102534.png)

然后就像之前那样修改这个指针，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921194119300.png)

这样的话就完成了，把数据元素e插入到p节点之后这个事情。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921194132307.png)

### 时间复杂度

显然，这段代码并没有循环什么的，它的时间复杂度就是o一

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921194150488.png)

好。那之前我们在第i个位置插入数据元素e这个基本操作，它是不是做的就是先找到第i减一个结点？然后就是在这个结点之后插入数据元素e啊，所以在实现后插操作之后，我们就可以把这一整段代码就直接通过调用这个函数就可以完成了。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921194350736.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921194449001.png)

## 指定节点的前插操作1

好，接下来要看的是前叉操作，也就是给定一个结点p，
你要在这个结点p之前插入一个新的数据元素e。诶，是不是出问题了？我们的这些单链表，它只能往后找，不能往前找，所以对于给定的结点p它。它之前有哪些节点，我们是看不到的，这片区域是被打了马赛克的，就跟大家看视频的时候，有一些地方打上了马赛克，你想看却又看不到。好，那怎么办呢？
我们想看的是高清无码的一片区域，对吧？那我们其实可以传入一个头指针，如果给了头指针的话，那整个链表的所有信息我们就都可以知道了。那这样的话，我们要在节点p之前插入一个新的元素，那我们是不是可以依次遍历各个节点，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921194811288.png)

然后找到这个节点p的前驱节点？然后在这个前驱节点之后插入数据元素e，这样就可以了，对吧？显然如果用这种方式实现的话，那时间复杂度应该是on这个数量级。但是有时候没办法，
你想看的这个区域，可能他真的就是看不到，也就是说如果他不给你传这个头指针的话，那刚才的这个思路是不是就？没办法，实现了。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921194944048.png)

## 指定节点的前插操作2

好，那接下来看另一种实现方式，要在p的前面插入一个数据元素e，首先申请一个新的结点，然后把这个结点作为p结点的后继结点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921195317197.png)

也就是连成这个样子好，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921195333071.png)

接下来重点来了，我的节点不能跑路，但是我节点里面的数据可以跑路，对吧？这句代码会把p结点当中以前存放的这个数据元素x给复制过来，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921195411674.png)

### 时间复杂度

然后再下一句会把这次要新插入的数据元素e。把它放到p这个结点里边诶，你看虽然我们没办法找到p结点的前驱结点，但是用这样的方式是不是逻辑上也可以实现同样的效果啊？并且这种实现方式，它的时间复杂度是o1，而前面那种思路就是要找它前驱节点的那种思路，时间复杂度是on，因为你必须循环遍历各个节点。所以这个偷天换日的操作还是挺骚的。那我们这儿实现的这个功能是只给出了这个数据元素e，然后我们在这个函数里面自己一个新的节点，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921195445827.png)

### 代码

```c++
bool InsertPriorNode(LNode *p, ElemType e) {
    if (!p)return false;
    LNode *s = (LNode *) malloc(sizeof(LNode));
    if (!s)return false;

    //这里换数据的代码在这里也可以，和图片里的位置不一样
    s->data = p->data;
    p->data = e;

    s->next = p->next;
    p->next = s;
    return true;

}
```



那王导书里给的代码是这样的。
它是直接给传了这个结点s，也就是新的要插入的这个结点处理的方法是一样的，找不到p的前驱结点，那么就先把s这个结点先连到p之后。然后声明一个temp变量，先把p结点的内容保存下来，接下来把s结点的内容复制到p里边，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921195951097.png)

也就是这里边就变成了e。最后再把temp的值复制到s里边，也就是x复制到了这个地方，那这样的话就实现了结点的前叉操作。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921200704470.png)

好，那以上就是和插入相关的所有的操作的实现，

## 按位序删除（带头结点）

那接下来我们要探讨的是怎么删除一个节点，如果此次要删除第i个位置的元素的话，
那我们是不是也需要找到它的前驱节点？因为我们需要更改它前驱节点的next指针，那对于删除操作的实现，我们只探讨带头节点的这种情况。同样的头结点，我们把它看作第零个结点，所以如果我们要删除的是第一个结点的话，那么按照刚才我们提出的这种思路，我们要找到第i- 1个结点，也就是第零个结点。然后把第零个节点的next指针，把它指向再往后的一个节点，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201223764.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201237446.png)

然后我们还需要用free函数把第二个节点给释放掉。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201251924.png)

好，那接下来我们来看一下具体的代码，
实现来分析一下，如果I=4的话，那么我们首先需要根据之前的这些逻辑，找到第三个结点。也就是此次要删除的这个结点的前驱节点，那这些逻辑是不是和插入操作其实是一样的？所以我们就不再慢慢分析，总之最后p会指向第三个结点。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201425851.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201531503.png)

好，接下来会定义一个指针Q，Q指针指向了p结点的next，也就是指向了第i个结点。接下来会把q结点的这个数据元素复制到变量e里边，注意这个变量e需要把此次删除的这个结点的值。给带回到这个函数的调用者那儿，所以e这个参数是引用类型的。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201640217.png)

好再往后p的next要指向q的next，也就是指向null。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201752139.png)

然后最后调用free函数，把q结点给释放掉。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201807897.png)

### 代码

```c++
bool ListDelete(LinkList &L, int i, ElemType &e) {
    if (i < 1)return false;
//    if (i == 1) {
//        LNode *q = L;
//        e = q->data;
//        L = q->next;
//        free(q);
//        return true;
//    }
    LNode *p;
    int j = 0;
    p = L;
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (!p)return false;
    if (!p->next)return false;

    LNode *q = p->next;
    e = q->data;
    p->next = q->next;
    free(q);
    return true;
}
```





### 时间复杂度

那这样的话，我们就删除了第四个结点，那由于需要依次循环的来找到第二减一个结点。所以这个算法的最坏时间复杂度和平均时间复杂度应该是on这个量级。而如果此次要删除的是第一个结点的话，那么是不需要进行这个循环的。所以最好的情况，时间复杂度应该是o1这个数量级。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201837995.png)

好了，那大家还是需要思考一下，如果不带头节点的话，
那么删除第一个数据元素的时候，是不是需要特殊处理呢？可以和这个代码进行一个对比

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921201913540.png)

## 按位序删除（不带头结点）

### 代码

```c++
bool ListDelete(LinkList &L, int i, ElemType &e) {
    if (i < 1)return false;
    if (i == 1) {
        LNode *q = L;
        e = q->data;
        L = q->next;
        free(q);
        return true;
    }
    LNode *p;
    int j = 1;
    p = L;
    while (p != NULL && j < i - 1) {
        p = p->next;
        j++;
    }
    if (!p)return false;
    if (!p->next)return false;

    LNode *q = p->next;
    e = q->data;
    p->next = q->next;
    free(q);
    return true;
}
```



## 指定结点的删除

好，那接下来我们来看一下怎么删除指定的给定的一个节点。那按照之前的思路，如果要删除节点p的话，是不是还需要修改它的前驱节点的next指针？那同样的问题发生了，我们没办法找到它的前驱节点。除非像刚才一样，要么就是传入一个头指针，然后从链表头依次往后寻找p的前驱节点。第二种方法呢，就类似于刚才前叉操作的实现。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921202304237.png)

我们此次要删除的是结点p，
首先声明一个指针q指向p的后继结点。然后我们把p的后继结点的这个数据，这个数据元素把它复制到p结点的这个数据域里边，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921202414937.png)

也就是这个样子。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921202427129.png)

然后再让p结点的next指针指向q结点之后的那个位置。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921202528146.png)

当然q结点之后有可能是一个实际的结点，也有可能是null，但是无所谓好了，最后还需要把这个q结点释放掉，把这个内存归还给系统。那这种实现方式，它的时间复杂度也是一。有没有感觉自己还挺聪明的？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921202623577.png)

好，那接下来问题来了，
我们来考虑一种极限情况，如果此次要删除的这个p结点它。它刚好就是这个单链表的最后一个节点的话，那看一下这个代码，首先q指针是指向了p的next。也就指向none那再往后执行到这一句的时候，是不是就会出错了？因为此时q结点它并没有指向某一个具体的结点。所以想在q结点里边取得它的data域，是不是就会出现空指针的错误啊？所以这段代码其实它是有bug的。我们的王道书上给的也是这小段代码，那如果说p结点刚好是最后一个结点的话，那。呃，
我们只能从表头开始，依次往后寻找，找到它的前驱，就是用之前提的那种比较土的思路来解决这个问题。当然，如果考试的时候迫不得已，你只能这么写的话，那估计最多扣你一分，甚至不扣你的分，那这个时候大家是不是体会到这个单链表它？它只能单向的来搜索，来检索各个节点，而不能逆向的检索，是不是有时候会确实不太方便？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921203026746.png)

那如果说各个结点，
还有往前的这个指针呢？情况是不是就不一样了？那像这种可以双向寻找，双向检索的链表就是双链表，这个我们会用之后的小节来学习。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921203108598.png)

好的，那这个小节中我们学习了和单链表插入删除相关的这一系列操作的实现，其中在讨论按位序插入的时候，我们具体探讨了带头节点和不带头节点的代码实现。从代码中，大家应该能够体会到这两种情况的区别，同时就能理解上一小节提到的那个点。带头节点写代码会更方便一些。当然，两种情况代码都要会写，
大家在做题的时候一定要注意审题，是不是带头节点的？那这个小节的这些操作的实现都是十分重要的。另外，不知道大家有没有体会到我们之前花了不少的时间来讲什么？malloc函数free函数，然后画了各种各样的内存。但是当我们在前期花时间把这些基础打牢了之后，我们在学习后续这些内容的时候，是不是理解起来会越来越快？所以前期的这些内容，我们学慢一点没关系，因为很多代码里边遇到的问题都是相通的，你学之后的内容也会遇到，那这些问题如果我们能在刚开始的时候就把它解决。
那之后的理解才会越来越深，并且会学的越来越快，另外在这个小节当中，希望大家能够用我们的这个示例代码来体会一下封装的好处。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921203501019.png)

我们不是实现了一个后插操作吗？实现了这个函数之后，我们按位序插入数据元素e，这段代码是不是就变得很简洁并且清晰明了？当我们要在第i个位置插入数据元素e的时候，我们首先是要先找到第i- 1个结点，然后在这个结点之后。插入新的数据元素e。你看把这个小功能模块把它封装成一个函数之后，是不是你的代码逻辑就变得更清晰了？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240921203640027.png)

当然了，
前面这个部分我们也可以把它封装成一个函数，一个基本操作，这个我们会在下一小节当中进行介绍。好的，那以上就是这个小节的全部内容。