# 2

来，我们来看一下这道题，要解答这道题，首先我们看到的就是一个时间复杂度，对吧？那么我们来看一下时间复杂度的一个概念。算法的时间复杂度，比如说我说这个算法，

它的时间复杂度是大of n，这个fn就意味着这是一个和n有关的一个函数，对吧？那么，它意味着什么呢？它意味着在任何情况下，那么这个在任何情况下，其实就是说在最复杂，最坏情况下。这也就意味着这个。也就是说，在最坏情况下，规模为n的一个前提下，注意这是一个前提。也就是说，

时间复杂度之中，暗藏着这个前提。然后<u>你所花费的时间，你时间上的一个规模是小于等于k倍的fn的。这个k是一个常数是和n无关的，就是说不管你这个n取几你这个k都是不变的</u>。那么有了我们这个概念之后，我们来看一下abcd四个选项，首先看a选项有问题吧？AD选项其实同一个问题就是说问题规模这个概念是你在说这个时间复杂度的时候。就隐含好了你的问题，规模就是n这是我们公认的默认的，而不是说你的问题的规模是n方呀，与n方成正比呀。这里这个n方和问题规模是没关系的，

然后看一下b选项，执行时间等于n方。出了两个问题，对吧？第一不是等于对吧？而是小于等于主要的问题是一个小于对吧？就是你是它的一个上界，并不是等于对吧？第二个问题是不是n方，而是k倍的n方，那么这个k倍的n方其实意味着什么呀？是不是就意味着c选项是成正比呀？那么，这道题我们就能选出来，是一个c选项。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914192925378.png" alt="image-20240914192925378" style="zoom:50%;" />

# 3

我们来看这道题，那么这道题啊，其实就是考察算法原地工作啊，这么一个简单的概念，那么我们知道算法原地工作就是指算法所需的辅助空间啊，为常量，那么也就是说算法。算法的空间复杂度啊，为o1也就说这三个概念，其实同一个意思，第一个是算法原地工作，第二个是算法所需的辅助空间为常量，还有什么换句话来说就是什么？算法的空间复杂度为o1嘛，所以本题的正确选项就是b选项所需辅助空间的大小与规模n，

它没有关系，那么就说明什么算法的空间复杂度为o1。这才是它的正确理解，那么a cd啊，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914193420636.png" alt="image-20240914193420636" style="zoom:50%;" />

都是不对的，我们来分析一下，比如说一个简单的算法，一个for循环。通过一个for循环啊，把一个数组AI的值啊，都给它赋初值为零，那么对于这个算法来说，它需不需要额外的辅助空间呢？那么其实它是需要的，对吧？

因为这里是不是啊？借助了一个整形变量I嘛，对吧？每次通过I的自增。我们来选中这个数组元素，然后把这个数组元素的初值啊哎赋为零，那么这个变量I它的是它是不是占四个字节啊？因为一个整型是占四个字节嘛？那么，通过I的自增给数组元素赋出值，那么是不是不管这个n啊？为多大？那么这个变量I是不是始终占四个字节啊？所以它是需要辅助空间的，并且这个辅助空间的大小是不是和这个n啊是没有关系的，

对吧？这个算法整体所占的空间大小是不是和这个n啊？是不是必然是有关系的，这个n越大。那么，是不是说明这个数组元素就越多，对吧？那么数组元素越多，那么所需的空间哎就越大，所以整体的空间大小是与规模n啊是有关系的。但是我们研究什么啊，空间复杂度，空间复杂度研究的是什么啊，辅助空间的大小那么？对于一个简单的for循环来说，

它不需要开辟额外的辅助数组，也不需要递归来执行，对吧？所以它的辅助空间啊，就是一个常量，也就是说和变量n是没有关系的。本题的正确选项为b选项。好的本题讲解结束，

# 16

<u>设k为执行的次数</u>

来看一下这道题。他问的是时间复杂度。我们最容易想到的做法就是。求出<u>sun加加这条指令执行的次数。执行的次数</u>知道了，时间复杂度也能够得到。它是一个两层循环，两层循环，我们先拆外层的循环。

外层的循环I是从一开始的，那I的取值会有哪些？我们列出来。它每次都是字乘以2 一直乘到最后的。要保证I小于n。
所以I应该是一二。四八等等，一直到二的k次方，它要保证I小于n，所以二的k次方应该是小于n的。<u>这就是外层的取值。</u>

那对于每一个外层的i，j有多少种可能的取值呢？<u>j是从零开始，j小于I。那就是零到i- 1。而j是j加加的，</u>
<u>所以总共会有I个取值。</u>
那对于每一个I都有I个取值，
我们只需要把所有的I相加即可。
I=1的时候加加执行一次
I=2的时候上加加执行两次
I=4的时候上加加执行四次。
所以就是把它们加起来。一直加到二的k次方。

这个应该是很好计算的，就是等比数列。它们求出来应该是二的k+1次方减一。这里我们得到的是k。题目中要求的是和n有关。
<u>注意一下二的k次方是小于n的。</u>
<u>所以二的k+1次方减一应该小于2n。</u>

根据时间复杂度的定义。执行的次数是零到2n之间。根据时间复杂度的定义，那我们就能够得到它的时间复杂度应该是on的。所以这道题就应该选b。

那对于所有的这一类的题，我们最基本的方法都是这样做。求出循环内这条指令执行的次数。从外到内，一层一层拆开循环，先拆外层的循环。看外层的循环有哪些取值。也就是这里的I，然后对于外层循环的取值，求出内层循环可能执行的次数。一定要注意的是。他们不一定都是I加加和j加加的。那本题选择b。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191405926.png" alt="image-20240914191405926" style="zoom:50%;" />

## 循环的时间复杂度总结

指数爆炸(<a href="/Users/yuebinghui/Documents/program/github/note/笔记/数学/周洋鑫/06.1零基础核心考点精讲5-2.md#指数爆炸">指数爆炸</>)

<a id="指数爆炸">指数爆炸</a>

### 每一层循环变量都是++

那接下来给大家介绍一下循环的时间复杂度总结。我把它分为两个类型，第一个类型比较简单，它的特点是每一层循环的变量都是I加加j加加k加加。这样的它可能出两层循环，三层循环，
四层循环都没有关系。只要都是I加加的，而且。这种时候我们可以不需要求出指令执行的次数，可以通过一些技巧直接得到答案。对于这一类问题，我们可以求出I的取值范围。j的取值范围k的取值范围。比如说，对于第一层循环I的取值范围应该是零到n- 1，所以应该是n。j的取值范围也是零到n- 1，应该是n。k的取值范围也是零到n- 1。它也是n。
我们要求的是时间复杂度，而不是具体的执行次数，只需要求出一个大概的范围。把这三个相乘即可。这是很简单的，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191630413.png" alt="image-20240914191630413" style="zoom:50%;" />

而第二种有一些小的区别，它们的区别在什么地方呢？第二种。j是受到I的取值影响的k，又受到j的取值影响零，这样的话，第一层应该是零到n- 1。第二层应该是零到i- 1，第三层应该是零到j- 1。如果按照这样做的话，
我们得到的答案应该是n×I×j。我们可以通过放缩法来进行一个计算。因为I的范围是零到n- 1的，我们取一个最大的值取一个n。把n带入进去。然后j我们也用n代入进去，所以它的答案也是n×n×n也就是n的立方。那对于这一类的问题，我们只要看到它是I加加j加加k加加，然后我们把它的范围看一下。这里j和k的范围虽然都和I和j有关，但是I和j都是小于n的。所以我们放缩的话，都可以把它放缩成n，那就直接每一层都是n，然后相乘即可。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914191850617.png" alt="image-20240914191850617" style="zoom:50%;" />

对于第一种类型的两种，虽然它们有一些细节上的不同，但是我们可以发现它的时间复杂度是一样的。我们看到第二种的时候可以直接完全按照第一种的时间复杂度来计算，这就是类型一类型一的话，我们不需要完全求出。每一条指令的具体执行次数，我们要记住的是，它求的是时间复杂度。这样的话，考试就能给我们省下大量的时间，不只是在选择题中，还可以在自己的。是还可以在自己算法的时间复杂度，
估计中。来进行计算。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240914192134302.png" alt="image-20240914192134302" style="zoom:50%;" />

而第二种类型有一个特点是。它不是一个单纯的I加加和j加加，它是有一些别的变化。它可以是I=I×2，也可以是I=I×I等，等我们要根据具体的题目来讨论I的取值。或者它在第二层j不是j加加可以改成j=j×2等等，我们要根据具体的题目具体分析。而对应的做法就是我们先拆开最外层的讨论，最外层有哪些取值？比如说这里I是一二。四八等等。一直到二的k次方。
而如果这里改成I=I×3呢，那就变成了一三。九，27等等。二，三的k次方。具体的题目要具体的去分析，而不是和类型一一样，可以套一个什么样的东西。一定要注意它的变化，到底是I=I×2还是I加加还是什么什么？这可以有助于我们区分它的类型。这就是两种情况的总结类型，一是我们可以套一个公式，把每一层的最大便利次数相乘即可。
而类型二，我们需要从外到内，一层一层拆开它，一般不会超过两层循环，因为这样计算起来会很麻烦。我们需要做的就是判断清楚它的边界条件，比如说这里I小于n，这里j小于I。然后讨论它每一次循环的过程中，到底是I=I×2，还是I=I加？加一分清楚这些东西，然后再具体的去计算。这就是循环的时间复杂度总结问题。那具体讲解到此结束。