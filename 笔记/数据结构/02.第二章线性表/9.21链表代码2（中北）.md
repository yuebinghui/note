##### 11. 🌟按递增次序输出带头结点的单链表和各结点的数据元素

下面的视频，执行了一轮while循环，在87 88行重置指针后就没再录屏了，可以自己画画

<u>因为这里相当于找到最小的结点后输出后删除，所以要有两层循环的，外层遍历整个L链表，内层找最小节点的前驱结点，然后删除</u>

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-05 16.40.16.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

void min_delete(LinkList &L) {
    LNode *pre = L, *p = L->next, *q; // pre为最小结点的前驱结点的指针
    while (L->next != NULL) { // 循环到仅剩头结点
        while (p->next != NULL) { // 就是p指针指到最后一个结点就不执行下面的语句了
            // p的下一个结点的数据 和 pre的下一个结点的数据比较
            // 比p比pre还小，你p就是更小的，放入pre，标记最小结点的前驱
            if (p->next->data < pre->next->data) {
                pre = p; // 记住当前最小结点的前驱结点
            }
            p = p->next;
        }
        printf("pre->next->data=%d\n", pre->next->data); // 输出最小值结点的数据
        q = pre->next; // 删除值最小的结点，释放结点空间
        pre->next = q->next;
        free(q);

        // 重置pre 和 p的指针，循环执行上面代码
        pre = L;
        p = L->next;
    }
    free(L); // 释放头结点
}

int main() {
    int A1[] = {25, 10, 7, 15, 30};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
//    print(L2);

    min_delete(L1);
    // print(L1); // 这里不可以调用这个 链表L1已经在min_delete被释放，但在print(L1)语句中仍然尝试访问已经释放的内存。

//    print(L3);


    return 0;
}
```

##### 12. 🌟将一个带头结点的单链表A 分解成两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变.

<u>这道题里，可以注意下尾插法的好处，只需要把最后一个结点指针指向NULL就好了</u>
<u>头插法的话，需要每次处理当前结点的next赋值为前一个结点的next，然后再把前一个结点的next链接为当前结点</u>

其实方法1的思路会比较简单，代码也整洁，因为相当于建立了两个头结点，让p指向头结点后的第一个结点，然后遍历整个p链表，按规章插入L1，L2就好了，也不需要断链，直接后插就好了，最后给L1，L2的对尾结点赋值NULL

方法2的话，是建立了个L2的链表以及指向尾节点的r，但是还需要pre 来记录前驱结点，

就是可以有多种情况，
比如A里为序号为偶，B里为序号为奇
比如A里为序号为奇，B里为序号为偶
比如A里为值为偶，B里为值为奇
比如A里为值为奇，B里为值为偶

序号就第一个结点，第二个结点
用i取余来判断，序号是奇数还是偶数，![image-20241007153424972](/Users/yuebinghui/Documents/program/github/note/images/image-20241007153424972.png)

用当前结点的值取余，判断是奇数还是偶数![image-20241007153602127](/Users/yuebinghui/Documents/program/github/note/images/image-20241007153602127.png)

如果是根据值的奇数偶数来分的话，那么就不需要i了，直接把if 判断改成判断p->data的奇偶性就好了

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 16.16.16.mov"></video>

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 16.12.15.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}


LinkList separate_create(LinkList &L1) {
    int i = 0; // 记录表A中结点的序号
    LinkList L2 = (LNode *) malloc(sizeof(LNode)); // 创建L2的头结点
    L2->next = NULL; // L2表的初始化
    LNode *L1r, *L2r; // 尾插法需要的指针，用来指向表尾的最后一个结点
    LNode *p; // p 为工作指针 指向第一个结点
    L1r = L1;
    L2r = L2;

    p = L1->next; // p为链表的工作指针，指向待分解的第一个结点
    L1->next = NULL; // 置L1表为空

    while (p != NULL) {
        i++;
        if (i % 2 == 0) { // 如果序号是偶，就让结点放到L2表的后面
            L2r->next = p; // 在L2表表尾插入新结点
            L2r = p; // L2r指向队尾
        } else { // // 如果序号是奇，就让结点放到L1表的后面
            L1r->next = p;// 在L1表表尾插入新结点
            L1r = p;// L1r指向队尾
        }
        p = p->next; // 后移一个结点，重复上面的操作，直到指针指向NULL
    }
    // 表的最后一个结点指向NULL
    L1r->next = NULL;
    L2r->next = NULL;
    return L2;
}

// 方法2 🌟
// 思路：我这个建立了一个L2，然后移动p当指向 序号为偶数的时候，
// 就在L上操作就好了，用pre指向p的前一个结点，这样可以pre->next = p->next;，就把序号为偶的结点分出来
// 然后把这个结点尾插法放入L2中

// 当序号为奇数的时候，就让pre 和 p指针后移就好了
LinkList detach(LinkList &L) {
    LinkList L2 = (LNode *) malloc(sizeof(LNode));
    L2->next = NULL;
    LNode *r = L2;

    LNode *p = L->next;
    LNode *pre = L;

    int i = 0;
    while (p != NULL) {
//        if (p->data % 2 == 1) {
        if (i % 2 == 0) {
            pre->next = p->next;

            // 👇🏻L2链表的操作
            p->next = L2->next;
            r->next = p;
            r = p;
            // 👆🏻L2链表的操作

            p = pre->next;
        } else {
            pre = p;
            p = p->next;
        }

        i++;
    }

    r->next = NULL;
    return L2;
}

int main() {
    int A1[] = {1, 2, 40, 50, 60};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    LinkList L2 = separate_create(L1);
    print(L1);
    print(L2);

//    print(L3);


    return 0;
}
```

##### 13. 🌟设A={a1,b1,a2,b2, ... ab,bn}，将A拆分成两个单链表，A={a1,a2...an} b={b1,b2...bn}

这里和我12题里的方法2中的思路很像，
同理这里也可以按12题里的方法1来写，就是按序号的这种

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 16.49.14.mov"></video>

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 16.57.10.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

LinkList separate_create(LinkList &L1) {
    LinkList L2 = (LNode *) malloc(sizeof(LNode)); // 创建L2的头结点
    L2->next = NULL; // L2表的初始化
    LNode *p = L1->next; // p 为工作指针 指向第一个结点
    LNode *q; // q指向p的下一个结点，防止断链用的
    LNode *L1r = L1;
    LNode *L2r = L2;

    while (p != NULL) {
        L1r->next = p; // 因为链表第一位是L1的表，所以先放L1的
        L1r = p; // L1r是尾插法的必备指针，永远指向表尾
        p = p->next; // 后移一位工作指针
        if (p != NULL) { // 如果p还是结点，不是NULL，就准备链接L2的结点
            q = p->next; // 就让q指向p的下一个结点，防止断链
            p->next = L2r->next; // 让p当前结点指向L2的next
            L2r->next = p; // 让L2r的最后一位结点链接当前结点
            L2r = p;// L2r是尾插法的必备指针，永远指向表尾
            p = q; // 后移一位工作指针
        }
    }
    L1r->next = NULL;
    return L2;
}

int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    LinkList L2 = separate_create(L1);
    print(L1);
    print(L2);

//    print(L3);


    return 0;
}
```

##### 14. 删除单链表中数值相同的元素（重复元素）有序

如果题目没说是否有头结点，默认有

方法2
<u>pre 和 p后移，</u>
<u>如果遇到相同的，给p后面的那个结点赋值为q，让p->next指向q->next，然后删除q</u>
<u>每次循环都是pre=p p=p->next</u>



有序的操作视频

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 18.41.54.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

//方法2
void delete_same2(LinkList &L) {
    LNode *p = L->next;
    LNode *pre = L;
    LNode *q;

    while (p) {
        if (pre->next->data == p->next->data) {
            q = p->next;
            p->next = q->next;
            free(q);

        } 
        pre = p;
        p = p->next;
    }
}

void delete_same(LinkList &L) {
    LNode *p = L->next, *q;  // p是工作指针，头结点后的第一个结点
    if (p == NULL)return; // 如果已经没有结点了，那么就不做操作
    while (p->next != NULL) { // 如果p指针的下一个是NULL，说明此时已经有序了，不需要和NULL比了
        q = p->next;  // 如果p有后一个元素，那么标记为q
        if (p->data == q->data) { // 如果p和q相等的话，
            p->next = q->next; // 那么就要让p指向q的下一个结点
            free(q); // 然后删除q
        } else { // 如果p和q不相等的话，
            p = p->next; // 就让p后移一位
        }
    }

}

int main() {
    int A1[] = {1, 4, 4, 5, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    delete_same(L1);
    print(L1);

//    print(L3);


    return 0;
}
```

无序的操作视频

如果无序呢
就是假如p指向第一个元素，那么我是不是需要另一个指针把p后面的所有元素遍历一遍
先让q指向p的next，然后判断p和q是否相同

![image-20241007181822015](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181822015.png)

如果不用，那么我让q继续往后走

![image-20241007181847331](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181847331.png)

如果一样了，那么我就把，此时的q给free掉

![image-20241007181915935](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181915935.png)

如果你要把q free掉，是不是前面需要加一个前驱了
因为如果我先删除5，那么我需要先找到5的前驱，如果不先标记，我就没法找5的前驱

![image-20241007182006742](/Users/yuebinghui/Documents/program/github/note/images/image-20241007182006742.png)


P是第一次的时候，就拿这个Q便利整个列表，然后P再往后移一次，然后再拿Q遍历整个列表。

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 20.12.01.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

void delete_same(LinkList &L) {
    LNode *p = L->next;  // p是工作指针，头结点后的第一个结点
    LNode *q; // q结点指向下一个结点，用来比较大小
    LNode *pre; // 用来指向要删除结点的前驱结点
    if (p == NULL)return;

    while (p && p->next != NULL) { // 因为第92行的 p=p->next可能让p为NULL，所以加个判断p &&
        q = p->next; // q指向p的后继结点
        pre = p; // pre指向q的前驱
        while (q != NULL) { // 遍历p后面的所有元素
            if (p->data == q->data) { // p 和 q 比，如果相等了
                pre->next = q->next; // 删q
                free(q);
                q = p->next; //
            } else { // p 和 q 比，不相等，先动前驱，再动q
                pre = q;
                q = q->next;
            }
        }
        p = p->next; // 遍历下一个链表元素
    }
}


int main() {
    int A1[] = {1, 4, 4, 2, 2, 3, 3, 7, 8, 8, 7, 5};
    LinkList L1;
    TailInsertList(L1, A1, 12);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    delete_same(L1);
    print(L1);


//    print(L3);


    return 0;
}
```

##### 15. 两个有序链表的合并

很简答就不录视频了

![image-20241007205316768](/Users/yuebinghui/Documents/program/github/note/images/image-20241007205316768.png)

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}


// 我这种是直接把L1和L2拆成了L3
void merge2(LinkList L1, LinkList L2, LinkList &L3) {
    LNode *p = L1->next;
    LNode *q = L2->next;
    LNode *r;
    r = L3;

    while (p && q) {
        if (p->data < q->data) {
            r->next = p;
            r = p;
            p = p->next;
        } else {
            r->next = q;
            r = q;
            q = q->next;
        }
    }

    if (q) p = q;
    while (p) {
        r->next = p;
        r = p;
        p = p->next;
    }
    r->next = NULL;


}



void merge(LinkList L1, LinkList L2, LinkList &L3) {
    LNode *p = L1->next;
    LNode *q = L2->next;
    LNode *r, *s;
    L3->next = NULL;
    r = L3; // 尾插法必备指针

    while (p != NULL && q != NULL) { // 某一个为链表遍历完成时，结束循环
        s = (LNode *) malloc(sizeof(LNode));

        if (p->data < q->data) { // 两个表当前所指的数据比大小，谁小谁先存入s
            s->data = p->data;
            p = p->next; // 后移一位
        } else {
            s->data = q->data;
            q = q->next; // 后移一位
        }

        // 然后尾插法
        r->next = s;
        r = s;
    }
    // 必定有一个链表先遍历完成
    // 如果q没有遍历完，那么p肯定遍历完了，让p=q，下面从p开始继续遍历
    // 如果q遍历完了，说明p没遍历完，那么这个if语句忽略
    if (q != NULL) p = q;
    // 从p开始遍历，余下没有遍历的元素，塞入L3
    while (p != NULL) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = p->data;
        r->next = s;
        r = s;
        p = p->next;
    }
    r->next = NULL;
}


int main() {
    int A1[] = {1, 3, 5};
    LinkList L1;
    TailInsertList(L1, A1, 3);
//
    int A2[] = {2, 4};
    LinkList L2;
    TailInsertList(L2, A2, 2);

    int A3[] = {};
    LinkList L3;
    TailInsertList(L3, A3, 0);


    print(L1);
    merge(L1, L2, L3);
    print(L3);


//    print(L3);


    return 0;
}
```

##### 16. 设计一个算法，判断一个单链表中各个结点值是否有序

也简单，不录屏了

这里的意思是p p->next flag同时为真，while循环才会继续运行

![image-20241007205847881](/Users/yuebinghui/Documents/program/github/note/images/image-20241007205847881.png)

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

bool is_sort(LinkList L1, char flag) {
    LNode *p = L1->next;

    if (flag == 'p') {
        while (p->next) {
            if (p->data > p->next->data) {
                return false;
            }
            p = p->next;
        }
        return true;
    }

    if (flag == 'n') {
        while (p->next) {
            if (p->data < p->next->data) {
                return false;
            }
            p = p->next;
        }
        return true;
    }
    return true;
}

// 当参数 c="a" 时表示链表为升序，当参数c="d"时表示链表为降序
int is_sorted(LinkList L, char c) {
    int flag = 1; // 默认有序的
    LNode *p = L->next; // 指向头结点后的第一个结点

    // 这里的两个if 条件都是没有等号的，所以 1 2 2 3就判断为无序了，
    // 如果想要让 1 2 2 3也是有序那么，
    // 变成这样就好了 p->data <= p->next->data

    switch (c) {
        case 'a': // 看你是否是升序
            while (p && p->next && flag) { // 如果当前有结点，并且当前结点的下个结点也存在，并且flag为真 进入代码块
                if (p->data < p->next->data) { // 如果结点小于下一个结点，说明升序
                    p = p->next; // 后移一位
                } else { // 反之，标记为无序
                    flag = 0;
                }
            }

            break;

        case 'd': // 看你是否是降序
            while (p && p->next && flag) { // 如果当前有结点，并且当前结点的下个结点也存在，并且flag为真 进入代码块
                if (p->data > p->next->data) { // 如果结点大于下一个结点，说明降序
                    p = p->next; // 后移一位
                } else { // 反之，标记为无序
                    flag = 0;
                }
            }
            break;
    }
    return flag;
}


int main() {
    int A1[] = {5, 3, 3, 2, 1};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {2, 4};
//    LinkList L2;
//    TailInsertList(L2, A2, 2);
//
//    int A3[] = {};
//    LinkList L3;
//    TailInsertList(L3, A3, 0);

    print(L1);
    int flag = is_sorted(L1, 'd');
    printf("%d\n", flag);
//    print(L3);


//    print(L3);


    return 0;
}
```

##### 17. 🌟 删除有序单链表中所有值大于x而小于y的结点

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-08 10.35.15.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}


// 删除有序单链表中所有值大于x而小于y的结点
void delete_x_y(LinkList &L, ElemType x, ElemType y) {
    LNode *pre = L;
    LNode *p = L->next;
    LNode *q;
    while (p && p->data <= x) { // 找到第1个大于x的结点的位置，因为此时pre所指的就是要删除结点的前驱
        pre = p; // 前驱先动
        p = p->next; // 然后再后移，不然前驱就丢失了
    }
    while (p && p->data < y) { // 找到第一个大于等于y的结点的位置
        p = p->next;
    }

    q = pre->next; // q指向了要删除的结点
    pre->next = p; // 将要删除结点的前驱结点链接到p，此时链表已经去除了所有大于x而小于y的结点
    pre = q->next; // 让pre指向要删除结点的下一个

    // 如果q是当时要删除的元素，p是 第一个大于等于y的结点的位置
    // 所以只要q 和 p不等就一直删除q，直到p和q指向同一个位置，说明p前面的要删除元素就都删除完了
    while (q != p) {
        free(q); // 删除q
        q = pre; // 后移一位q指针，指向下一个要删除的元素
        pre = pre->next; // pre后移
    }
}


int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {2, 4};
//    LinkList L2;
//    TailInsertList(L2, A2, 2);
//
//    int A3[] = {};
//    LinkList L3;
//    TailInsertList(L3, A3, 0);


    print(L1);
    delete_x_y(L1, 1, 5);
    print(L1);


//    print(L3);


    return 0;
}
```

##### 18. 在一个单链表中值为y的结点前面插入一个值为x的结点

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-08 10.54.05.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}


// 在一个单链表中值为y的结点前面插入一个值为x的结点
bool delete_x_y(LinkList &L, ElemType y, ElemType x) {
    LNode *p;
    LNode *pre;
    p = L->next;
    pre = L;
    while (p && p->data != y) { // 当p->data = y时停止查找
        pre = p;
        p = p->next;
    }
    if (!p) return false;

    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = x;
    s->next = pre->next;
    pre->next = s;
    return true;
}


int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {2, 4};
//    LinkList L2;
//    TailInsertList(L2, A2, 2);
//
//    int A3[] = {};
//    LinkList L3;
//    TailInsertList(L3, A3, 0);


    print(L1);
    delete_x_y(L1, 2, 15);
    print(L1);


//    print(L3);


    return 0;
}
```

##### 19. 🌟求单链表中的个数

注意循环里 p!=NULL 和 p->next!=NULL 的区别 后者当然会少循环一次

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L, int A[], int size) {
    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}



int count(LinkList L, int haveHead) {
    int count = 0; // 从0开始数数，对着呢

    LNode *p = L; // 默认没有头结点
    if (haveHead) { // 如果有头结点
        p = L->next;
    }

  // 如果有p结点，那么就说明有一个结点，那么就加1，有一个就加一个
    while (p) { 
        count++;
        p = p->next;
    }
    return count;
}


int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);

//    int A1[] = {1, 2, 3, 4, 5};
//    LinkList L1;
//    no_head_TailInsertList(L1, A1, 5);
//
//    int A2[] = {2, 4};
//    LinkList L2;
//    TailInsertList(L2, A2, 2);
//
//    int A3[] = {};
//    LinkList L3;
//    TailInsertList(L3, A3, 0);


//    no_head_print(L1);
    int sum = count(L1, 1);
    printf("sum=%d\n", sum);

    print(L1);


//    print(L3);


    return 0;
}
```

# 双链表

![image-20241008122329325](/Users/yuebinghui/Documents/program/github/note/images/image-20241008122329325.png)

## 1.双链表的插入操作

![image-20241008133300222](/Users/yuebinghui/Documents/program/github/note/images/image-20241008133300222.png)

## 2.双链表的删除操作

![image-20241008122424686](/Users/yuebinghui/Documents/program/github/note/images/image-20241008122424686.png)

##### 20. 在双链表中值为y的结点前插入值为x的结点

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-08 14.09.42.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct DLNode {
    ElemType data;
    DLNode *prior, *next;
} DLNode, *DLinklist;

bool InitDLinklist(DLinklist &DL) {
    DL = (DLNode *) malloc(sizeof(DLNode));
    DL->prior = NULL;
    DL->next = NULL;
    return true;
}

void print(DLinklist DL) {
    DL = DL->next;
    while (DL) {
        printf("%d\n", DL->data);
        DL = DL->next;
    }
    printf("\n");
}

bool tail_insert_list(DLinklist &DL, ElemType A[], int size) {
    DLNode *r = DL;

    for (int i = 0; i < size; ++i) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = A[i];

        s->next = r->next; //让当前结点的next指针指向前一个结点的next
        if (r->next) {
            r->next->prior = s;
        }
        s->prior = r; //让当前结点的指针prior指向前一个节点
        r->next = s; // 让前一个结点next指向当前结点
        r = s;
    }
    return true;
}

bool insert_x(DLinklist &DL, ElemType y, ElemType x) {
    DLNode *p = DL->next;
    while (p && p->data != y) {
        p = p->next;
    }

    // 因为此时的p指向的是，元素y，而我们要在y的前面去做插入操作，我们是在p结点前插
    // 王道书的插入操作是在p结点的后面插入，所以要注意代码顺序
    if (p) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = x;

        // 不可以先动p结点的指针，因为如果先给p结点的指针赋值就会使得一会给s赋值的时候出问题
        // 先把s结点的next 和 prior赋值好再更改p的指针
        s->next = p;
        s->prior = p->prior;

        p->prior->next = s;
        p->prior = s;
    }

    return true;
}

int main() {

    DLinklist DL;
    InitDLinklist(DL);
    ElemType A[] = {1, 2, 3, 4, 5};
    tail_insert_list(DL, A, 5);

    print(DL);
    insert_x(DL, 3, 10);
    print(DL);


    return 0;
}
```

##### 21. 删除带头结点的双链表L的第i个元素

```c++
#include "func.h"

#define ElemType int

typedef struct DLNode {
    ElemType data;
    DLNode *prior, *next;
} DLNode, *DLinklist;

bool InitDLinklist(DLinklist &DL) {
    DL = (DLNode *) malloc(sizeof(DLNode));
    DL->prior = NULL;
    DL->next = NULL;
    return true;
}

void print(DLinklist DL) {
    DL = DL->next;
    while (DL) {
        printf("%d\n", DL->data);
        DL = DL->next;
    }
    printf("\n");
}

bool tail_insert_list(DLinklist &DL, ElemType A[], int size) {
    DLNode *r = DL;

    for (int i = 0; i < size; ++i) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = A[i];

        s->next = r->next; //让当前结点的next指针指向前一个结点的next
        if (r->next) {
            r->next->prior = s;
        }
        s->prior = r; //让当前结点的指针prior指向前一个节点
        r->next = s; // 让前一个结点next指向当前结点
        r = s;
    }
    return true;
}

// 返回第i个位置的结点
DLNode *GetElem(DLinklist DL, int i) {
    DLNode *p = DL->next;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}

bool delete_i(DLinklist &DL, int i) {
    DLNode *p;
    if (i < 1) return false; // i值不合法
    p = GetElem(DL, i);
    if (!p) return false;
    if (p->prior) {
        p->prior->next = p->next;
    }
    if (p->next) {
        p->next->prior = p->prior;
    }
    free(p);
    return true;
}

int main() {

    DLinklist DL;
    InitDLinklist(DL);
    ElemType A[] = {1, 2, 3, 4, 5};
    tail_insert_list(DL, A, 5);

    print(DL);
    delete_i(DL, 5);
    print(DL);


    return 0;
}
```

##### 22. 从右往左打印一个双链表中各个结点的值

```c++
#include "func.h"

#define ElemType int

typedef struct DLNode {
    ElemType data;
    DLNode *prior, *next;
} DLNode, *DLinklist;

bool InitDLinklist(DLinklist &DL) {
    DL = (DLNode *) malloc(sizeof(DLNode));
    DL->prior = NULL;
    DL->next = NULL;
    return true;
}

void print(DLinklist DL) {
    DL = DL->next;
    while (DL) {
        printf("%d\n", DL->data);
        DL = DL->next;
    }
    printf("\n");
}

bool tail_insert_list(DLinklist &DL, ElemType A[], int size) {
    DLNode *r = DL;

    for (int i = 0; i < size; ++i) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = A[i];

        s->next = r->next; //让当前结点的next指针指向前一个结点的next
        if (r->next) {
            r->next->prior = s;
        }
        s->prior = r; //让当前结点的指针prior指向前一个节点
        r->next = s; // 让前一个结点next指向当前结点
        r = s;
    }
    return true;
}

// 返回第i个位置的结点
DLNode *GetElem(DLinklist DL, int i) {
    DLNode *p = DL->next;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}

bool print_right_to_left(DLinklist &DL) {
    DLNode *p = DL->next;
    // 遍历到最后一个结点停止
    while (p->next) {
        p = p->next;
    }

    // 从最后一个结点往前遍历，并打印当前结点值
    // 在头结点停止
    while (p->prior) {
        printf("p->data=%d\n", p->data);
        p = p->prior;
    }

    return true;

}

int main() {

    DLinklist DL;
    InitDLinklist(DL);
    ElemType A[] = {1, 2, 3, 4, 5};
    tail_insert_list(DL, A, 5);

    print(DL);
    print_right_to_left(DL);
    print(DL);


    return 0;
}
```

##### 23. 设计算法，将双链表改为循环双链表

```c++
#include "func.h"

#define ElemType int

typedef struct DLNode {
    ElemType data;
    DLNode *prior, *next;
} DLNode, *DLinklist;

bool InitDLinklist(DLinklist &DL) {
    DL = (DLNode *) malloc(sizeof(DLNode));
    DL->prior = NULL;
    DL->next = NULL;
    return true;
}

void print(DLinklist DL) {
    DL = DL->next;
    while (DL) {
        printf("%d\n", DL->data);
        DL = DL->next;
    }
    printf("\n");
}

bool tail_insert_list(DLinklist &DL, ElemType A[], int size) {
    DLNode *r = DL;

    for (int i = 0; i < size; ++i) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = A[i];

        s->next = r->next; //让当前结点的next指针指向前一个结点的next
        if (r->next) {
            r->next->prior = s;
        }
        s->prior = r; //让当前结点的指针prior指向前一个节点
        r->next = s; // 让前一个结点next指向当前结点
        r = s;
    }
    return true;
}

// 返回第i个位置的结点
DLNode *GetElem(DLinklist DL, int i) {
    DLNode *p = DL->next;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}

// 设计算法，将双链表改为循环双链表
bool change(DLinklist &DL) {
    DLNode *p = DL->next;
    while (p->next) {
        p = p->next;
    }
    printf("p=%d\n", p->data);

    p->next = DL;
    DL->prior = p;
    return true;
}

int main() {

    DLinklist DL;
    InitDLinklist(DL);
    ElemType A[] = {1, 2, 3, 4, 5};
    tail_insert_list(DL, A, 5);

//    print(DL);
    change(DL);
//    print(DL); //这里打开就死循环了，因为没有判定终止条件，因为这个链表是个环


    return 0;
}
```
