# 1.0\_开篇\_数据结构在学什么（课程标题）

好，下面就让我们正式开始进入数据结构这门课，那第一个视频当中，我们要和大家分享的是数据结构这门课，它到底在学什么？那我们先抛出结论，这是我自己的理解数据结构，这门课它要学习的就是怎么用程序代码把现实世界的问题给信息化。并且我们还要研究怎么用计算机更高效的来处理这些信息，从而创造价值，那所谓创造价值就是可以变成钱，对吧？好，接下来我们来看几个呃，把现实世界的问题给信息化的例子。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906125611866.png" alt="image-20240906125611866" style="zoom:50%;" />



在一九八零年，
有一个叫做托夫勒的未来学家，他写过一本书，叫第三次浪潮。它把人类社会的发展分为了三个浪潮，或者说三个阶段。第一个浪潮是农业阶段，大概持续了一万年。第二个浪潮是工业阶段，大概是从17世纪末开始的，也就是说迄今为止也就是300多年的时间。而第三次浪潮是正在到来的信息化阶段，我们现在从自己生活的方方面面都可以很强烈的感受到，这个世界正在快速的被信息化这个事情。比如说我们小时候存钱都是用硬币或者纸币对吧，然后存到这样一个存钱罐里拿在手上，
感觉沉甸甸的，很有分量。但也就是在最近几年，我们的金钱变成了一串轻飘飘的数字，比如像我自己，虽然现在我的财富已经达到了六位数，但是拿在手上再也没有这种沉甸甸的充实感，我也不知道为什么。啊，一二三四五六啊六位数没记错啊，那除了金钱被信息化之外，现在很多服务业也正在被高度的信息化。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906125723095.png" alt="image-20240906125723095" style="zoom:50%;" />



比如以前我们要去一家店里吃饭，那我们排队是这么排的，每个人都必须在场，
然后等待着食堂大师傅的临幸。但是在现在这个信息化的世界，我们排队只需要在微信上取一个号，然后等待着被叫号就可以了，我们本人并不需要亲自在现场等待。这么做既节省了顾客的时间，同时也节省了商家等位区的空间，所以把现实世界的一些问题给信息化，是可以产生经济价值的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906130009131.png" alt="image-20240906130009131" style="zoom:50%;" />

再来看最后一个故事，我们小时候交朋友肯定都是线下交的，只有物理空间上的相邻才可以呃，造就我们之间的友情或者爱情，对吧？但是在现在这个高度信息化的世界，
我们只要微博点了，互相关注，大家就是一辈子的好朋友，对吧？好，那刚才我们看了三个现实世界的问题，被信息化的例子，那大家在学数据结构这门课之前应该已经学过C语言。接下来，我们来思考一下，用大家学过的C语言，怎么在计算机当中表示，刚才我们所说到的这些信息呢？第一个例子高达六位数的财富，怎么在计算机当中记录呢？
很简单，我们只需要设置一个float型，也就是浮点型的变量是不是就可以解决？第二个例子，怎么把队列给信息化呢？比如我们是不是可以定义一个数组，然后在这个数组当中分别记录每一桌的人，他到底是要小桌还是大桌，对吧？那在学了数据结构这门课之后，大家会知道，除了数组之外，其实还有更好的解决方式来实现我们这个数字化，信息化的队列。再来看最后一个例子，
我们在玩微博的时候，微博当中有很多很多的用户，对吧？然后这些用户之间会互相的关注。那想一下，用大家学过的C语言，怎么表示这些用户互相关注这个逻辑关系呢？毫无思路，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906130208019.png" alt="image-20240906130208019" style="zoom:50%;" />



所以回到最开始的问题，在学了数据结构这门课之后，大家就会知道怎么用程序代码把现实世界当中的问题给信息化。包括刚才我们提到的微博当中，各个用户互相关注这个事情，如何用程序代码来实现？那把现实世界的问题信息化只是第一步。
在这门课当中，我们还会研究怎么用计算机来高效的处理这些信息，从而创造价值。那这是数据结构，这门课那除了数据结构，这门课之外，很多学校在考研的时候还会考察计算机组成原理操作系统和计算机网络这三门课。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906130256607.png" alt="image-20240906130256607" style="zoom:50%;" />



其实另外这些课程的学习也是为了让大家更好的理解这个信息化的世界来，简单说一下，我们现在使用的计算机或者手机这些东西，它底层其实就是由一些硬件。也就是CPU啊，内存啊，主板啊，这些东西组成的那计算机组成原理这门课其实研究的就是计算机底层的这些硬件，
它是怎么工作的？它的工作原理是什么？这样的一个问题。那在我们的计算机硬件之上，我们一般还会架设一层操作系统，比如说大家现在很喜欢使用的安卓系统。Windows系统或者苹果的iOS系统，那操作系统这门课它要研究的就是这些操作系统，它在背后是怎么工作的，怎么管理你的手机，管理你的电脑的？研究的是这样的一个问题，那我们的手机或者计算机在安装了操作系统之后，我们还会在上面安装一系列的应用软件，对吧？
比如大家很喜欢使用的微信QQ。王者荣耀或者一些呃比较奇怪的视频播放软件，那我们计算机专业的同学以后绝大多数应该是要从事这种上层的应用软件的开发。那这些应用软件本质上也是为了解决现实世界当中的某些问题，因此我们就需要具备扎实的数据结构基础，因为这样的话我们才知道如何把现实世界的问题给信息化。然后交给我们的计算机来处理，所以计算机组成原理操作系统和数据结构C语言学完这几门课，我们就知道了，我们的计算机手机它在背后到底是怎么工作的？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906130428569.png" alt="image-20240906130428569" style="zoom:50%;" />

那刚才还提到了另外一门课，计算机网络计算机网络，它实现了各个计算机或者计算机和手机之间的互联互通。所以学习了计算机网络这门课之后，大家就会知道你和别人的手机是怎么相互传递信息的，
你给别人发的微信是怎么到别人的手机里的？那其实这不就是我们现在所生活的高度信息化的世界吗？因此对于计算机专业的同学，即便呃，有的同学可能不考其中的某些科目。但是在有时间的情况下，还是强烈建议大家要把这四门课都给学一下，因为只有学过这四门课，我们才能真正的理解这个信息化世界的本质。这也是我们计算机专业的学生和只会写代码的人的一个区别，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906130532487.png" alt="image-20240906130532487" style="zoom:50%;" />

好，那最后我想借用开篇提到的那个作者，他的一句名言，作为我们第一个小视频的结尾。唯一可以确定的是，
明天会让我们所有人大吃一惊，回顾整个人类文明发展的历程，我们人类首先是经历了农业革命。农业革命使人类学会了农耕，因为学会了自己种粮食，人类才开始在各个地方定居下来。各种人类文明才开始慢慢萌芽，而300多年前的工业革命又导致我们的世界出现了枪炮和机械这些东西。这些工业革命的产物导致了某些古文明的灭亡，或者说非现代文明的灭亡，比如清朝的灭亡，很大程度上就是因为。当时的西方已经在迅速的进行工业革命，而清朝还在闭关锁国，而现在我们的世界正在进行的是信息革命。
我们的生活每一年都会因为信息化而变得非常不一样，比如外卖，滴滴打车。几年前谁都不敢想象这些事情。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906130629441.png" alt="image-20240906130629441" style="zoom:50%;" />

所以我们的未来一定是越来越高度信息化的世界，所以接下来这段时间让我们一起努力学习。学好这几门基础课，让自己成为信息革命的参与者。好，那本小节的内容讲解结束，我们下集再见。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906130638940.png" alt="image-20240906130638940" style="zoom:50%;" />

# 1.1数据结构的基本概念（课程标题）

各位同学大家好，从这个小节开始，我们会正式进入数据结构这门课的正课内容，先来看第一章绪论部分。绪论这个章节其实并不是四零八大纲当中要求掌握的章节，只不过对绪论这个章节的学习能够帮助大家搭起一个学习的思维框架。学完绪论之后，大家就会知道之后各个具体的数据结构应该用什么样的思路，什么样的方法来学习好，那这个小节中我们会首先介绍一些数据结构相关的基本概念。我们会把一些相互之间关联性比较强的概念放在一起，帮助大家理解。另外，我们还会介绍数据结构的三要素，也就是说在学习各种数据结构的时候，大家需要关注的三个方面的问题。
分别是逻辑结构，物理结构和数据的运算，我们会先学习数据结构的三要素，然后再回头来讲解抽象数据类型这个概念，因为理解了三要素之后再回头理解这个概念会相对轻松一些。那这个小节会涉及比较多的概念，比较无聊，给大家的学习建议是可以抓大放小啊，不必纠结于某一个具体的细节概念。因为这些概念其实都不是特别重要，并且随着之后课程的学习，会对这些概念的理解越来越深刻。另外，我们还会在这个小节的末尾，把最重要的那些概念再带大家串一遍好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906131325163.png" alt="image-20240906131325163" style="zoom:50%;" />

那首先来看一些最基本的概念，第一个要认识的是什么？是数据，数据是信息的载体，是描述客观事物的数字符及能够输入到计算机中，并且被计算机程序。识别和处理的符号集合，那其实从计算机的视角来看，所谓的数据啊，对于计算机来说就是一些二进制零和一，对吧？因为计算机能够识别和处理的只有二进制数，我们现实世界当中的所有数据，只要我们能够确定一个转换规则，
其实都可以转换成二进制表示的形式。

## 数据

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906131550110.png" alt="image-20240906131550110" style="zoom:50%;" />

## 数据元素

## 数据项

那什么是数据元素呢？这是王道书给的定义。数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。然后一个数据元素由若干个数据项组成，其实什么是数据元素？什么是数据项？这个得看我们到底是要用计算机来处理什么样的问题。我们要根据我们实际的业务需求来确定到底什么是数据元素，什么是数据项，比如说大家去吃海底捞的时候不是会有海底捞的排队排号的系统吗？那对于海底捞的这个排号系统来说，所谓的一个数据元素，其实就会对应一波顾客，
因为每一波顾客在排队的时候，他都会取一个号。而每一波顾客排队的信息当中，包含了这一波顾客，他的号数对吧？同时还需要记录这个顾客的取号时间。另外，根据实际的业务需求，可能还需要记录这一波顾客他到底有多少人，也就是就餐人数是多少，那在这个应用场景当中，每一波顾客的信息其实就是一个数据元素。而每个数据元素当中，又会由多个数据项组成。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906131726676.png" alt="image-20240906131726676" style="zoom:50%;" />

再比如说我们玩微博的时候，
每一个人的账户都会有一个基本信息，那么在微博这个应用的呃业务场景下。所谓的一个数据元素，其实就是对应一个账户，一个账号，而每一个账号，它会包含这个账号的昵称。还有性别，生日等等，这一系列的信息每一项基本的信息就是一个数据项，另外对于一些复杂的信息，比如说像生日信息，也许我们可以把它拆解为。更多个数据项把它拆分成年，月，
日这样的形式，那么这样的多个数据项把它组合起来，表示一个整体的信息，我们可以把这样的一个整体称为组合项。总之呢，我们要根据实际的业务需求，业务情况来确定我们要把哪些内容作为一个整体。是根据实际的业务需求来确定的好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906131943567.png" alt="image-20240906131943567" style="zoom:50%;" />

那接下来要学习的两个概念是数据结构和数据对象。在讲数据结构之前，先来看一下什么叫结构，比如在我们小学的时候学过一些汉字，老师会告诉我们一个汉字是什么样的结构，比如这个汉字是左右结构。这个是左中右，
这个是上中下结构，那不难看出所谓的结构其实指的就是它的各个元素，它们之间的一个关系。比如像慢这个字，可以把它拆解成三个部分，那这三个部分或者说这三个元素，它们之间的结构关系就是上中下这样的结构，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906132122124.png" alt="image-20240906132122124" style="zoom:50%;" />

## 数据结构

## 数据对象

所以所谓的<u>数据结构指的就是。相互之间存在一种或多种特定关系的数据元素的集合</u>，也就是说<u>数据结构强调的是各个数据元素之间。它们到底有什么关系</u>？而<u>数据对象这个概念只强调数据元素，具有相同的性质，但是并不强调数据元素之间的关系</u>好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240906132338765.png" alt="image-20240906132338765" style="zoom:50%;" />

还是来讲海底捞的例子。
之前我们说了，在海底捞排队的某一波顾客的信息，我们可以把它看作一个数据元素，那不同的顾客，他们的排队信息其实逻辑上看是存在某一种。先后关系的，比如在某个特定的门店排队的那些顾客的信息，他们之间就会存在一种先后的关系。三号顾客在四号之前，四号顾客在五号之前，所以由于这些数据元素之间，它们存在某一种关系，因此由这些相互之间有关系的数据元素。就组成了一个数据结构，那这儿我们看的是a门店的顾客信息，
那假设还有另外一个门店也有一些顾客在排队。但是显然另一个门店的顾客排队信息，也就是这些数据元素，其实和上边这些数据元素并没有直接的关联关系。但是，由于这些数据元素，它们都具有相同的性质，所以我们可以把所有门店的排队顾客信息都看作是同一个数据对象里的数据元素。相信用这个例子并不难理解，数据结构强调的是数据元素之间一定要存在某种关系，而数据对象只需要要求在这个集合当中的所有数据元素都具有相同的性质就可以了。好，那既然数据结构要强调，要关心的是各个数据元素之间的关系，那么当我们在学习，
在设计一个数据结构的时候，应该注意数据结构的哪些方面呢？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131129262.png" alt="image-20240907131129262" style="zoom:50%;" />

## 数据结构三要素

### 1.逻辑结构

那这就涉及到下一个知识点，数据结构的三要素，分别是逻辑结构，物理结构和数据的运算。我们来依次看一下，首先来看逻辑结构。逻辑结构指的就是数据元素之间，它们的逻辑关系是什么？那数据的逻辑结构分为集合线性结构，树形结构和图状结构，或者叫网状结构。分为这样的四种，我们依次来看一下那集合这种结构，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131329022.png" alt="image-20240907131329022" style="zoom:50%;" />

#### 集合

其实和我们数学里的集合是一样的概念，就是指各个数据元素，它们同属于一个集合。除此之外，别无其他关系。比如，在我们吃烤肉的时候，在一个烤盘上，各种各样的食物，它们都属于烤盘这个集合。但是，各个元素之间并没有其他的逻辑关系，那这是集合。这种逻辑结构。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131406675.png" alt="image-20240907131406675" style="zoom:50%;" />

#### 线性结构

再来看下种逻辑结构叫线性结构。
其实看这个图就很好理解所谓的线性结构，是指各个数据元素之间，它们存在一对一的关系。然后除了第一个元素之外，其他所有的元素都有唯一的前驱，比如假设左边这个是第一个元素，那么这个元素它是没有前驱的，也就是在它的前面没有别的元素。而对于后面的任何一个元素来说，它都会找到一个直接的前驱，那和前驱相对应的概念叫后继。除了最后这个元素之外，每一个元素它都可以找到一个后继，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131512879.png" alt="image-20240907131512879" style="zoom:50%;" />

比如在我们吃烤串的时候，在这个肉签上呃，
我们把。各种食物，各种肉给穿上去，那么这些肉它们之间的逻辑关系就是线性结构，这样的关系。另外，像刚才我们提到的海底捞吃火锅的例子，这个队列当中的各个元素，它们之间其实从逻辑上看也存在这种一前一后的关系。所以这些数据元素之间也存在线性结构，这样的关系

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131600844.png" alt="image-20240907131600844" style="zoom:50%;" />

#### 树形结构

再来看下种树形结构数据元素之间存在着一对多的关系啊，这个看图很好理解树形结构其实就和我们的树枝一样。由某一个节点开始，长出一个一个的分支。其实，
这种树形结构的数据元素啊，是很常见的。比如说，像我们开篇给的这个思维导图。这些一个一个的节点，它们之间不就是这种树形结构的关系吗？另外，我们的电脑当中，各级目录还有各个目录下边的呃一些奇怪的文件。它们之间的关系其实也是这种树形结构的关系，所以其实树形结构也是很常用的好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131709599.png" alt="image-20240907131709599" style="zoom:50%;" />

#### 图状结构-网状结构

再来看最后一个呃逻辑结构叫图状结构或者叫网状结构。指的是数据元素之间存在多对多的关系，比如我们的微信好友关系。从逻辑上看，
其实就是一种图状的结构，网状的结构。每一个用户被抽象为一个数据元素，而用户之间如果加了好友，那相当于在这两个数据元素之间建立了一条边，建立了某种联系。那比如你要和你的前女友断绝关系的话，那从数据结构的角度来看，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131804519.png" alt="image-20240907131804519" style="zoom:50%;" />

是不是就相当于把这两个数据元素之间的联系给它干掉了？也就这条边消失了。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131825735.png" alt="image-20240907131825735" style="zoom:50%;" />

好，再来汇个总数据的逻辑结构，分为这样的四种。其中，我们在数据结构这门课里边啊，
要着重讨论的是后面的这三种，也就是集合这种结构。呃，基本不讨论线性结构，会在第二和第三章当中进行讨论。树形结构会在第四章当中图结构，会在第五章中进行讨论。好，那这是数据结构的三要素当中的第一个数据的逻辑结构，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907131935859.png" alt="image-20240907131935859" style="zoom:50%;" />

### 2.物理结构-存储结构



接下来要看的是数据的物理结构，或者很多地方更愿意把它称为存储结构。数据的存储结构所要探讨的问题是如何用计算机来表示出数据元素的那种逻辑关系，也就是刚才我们探讨的这些逻辑关系怎么用计算机来表示这样的一个问题。那数据的存储结构同样分为四种，分别是顺序存储，
链式存储，索引存储和散列存储。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907132038225.png" alt="image-20240907132038225" style="zoom:50%;" />

#### 顺序存储

那为了让大家理解起来容易一些，我们在绪论这个部分先探讨。线性结构这种最简单的逻辑关系，在计算机当中应该怎么表示？如果采用顺序存储，这样的存储结构的话，那么需要把逻辑上相邻的元素在物理上，物理内存里。也把它相邻的存放就像这个样子，也就是说在计算机的物理内存里边，用数据元素的存储位置，相邻来表示。各个数据元素逻辑上的这种相邻的关系好，
这是顺序存储，如果采用这种存储方式的话，那要求给各个数据元素分配的是。一片连续的存储空间，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907132149236.png" alt="image-20240907132149236" style="zoom:50%;" />

#### 链式存储

再来看另一种存储方式。链式存储如果采用链式存储的话，那么逻辑上相邻的各个元素在物理位置上可以不相邻。而是借助这个元素，存储地址的指针来表示，它的下一个元素到底是在什么位置存储呢？所以如果采用的是链式存储，这种方式的话，那么各个元素之间的先后关系是用这种指针来表示的。那这儿需要提醒大家，如果对C语言的指针不太熟悉的同学，
在学这个数据结构这门课之前一定要自己先花点功夫把C语言当中和指针相关的内容好好自学一下。好，这是链式存储，并不要求各个数据元素，它的存放位置在物理上，相邻

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907132553153.png" alt="image-20240907132553153" style="zoom:50%;" />

#### 索引存储

再来看下一种呃索引存储，如果采用这种存储结构的话，那么会建立一张索引表。在这个索引表当中记录呃，各个数据元素的这种先后次序，同时也要记录每一个元素，它实际的呃存放地址。所以如果采用索引存储的话，那么需要在内存当中再消耗一些存储空间来专门的存放一个这样的索引表诶，可能有的跨考的同学不知道关键字是什么意思？
所谓的关键字，就是可以区分不同的数据元素的呃数据项，比如之前我们举的海底捞的例子，每一波顾客，他取的那个排队的号。都是唯一的，所以在海底捞的排队系统当中，可以把顾客取到的那个号数作为数据元素的关键字。总之，可以用关键字这样的属性来区分各个数据元素，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907132759629.png" alt="image-20240907132759629" style="zoom:50%;" />

#### 散列存储

好再来看最后一种存储结构，散列存储。采用这种方式的话，会根据数据元素的关键字直接计算出该元素的存储地址，又称哈希存储，
要解释清楚什么是散列存储，并不是短短的几分钟能够解决的。所以这个地方我们先不展开，在我们第六章散列表相关的那些部分的学习会更进一步的介绍，什么叫散列存储这个地方能有个模糊的印象就可以了。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907132845397.png" alt="image-20240907132845397" style="zoom:50%;" />

好，那刚才我们介绍了数据的四种存储结构，我们可以把后面的这几种存储结构统称为非顺序存储。在之后章节的学习中，还会对这些存储结构有越来越深的认识，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907133206445.png" alt="image-20240907133206445" style="zoom:50%;" />

那在绪论这个章节当中，我们只需要理解两点，第一，如果采用顺序存储的话，那么各个数据元素在物理上必须是连续的。
就像我们传统的排队，每个排队的人在物理空间上必须都是连续的，而如果采用的是非顺序存储的话，那么各个数据元素在物理上可以是离散的。比如现在去银行办业务，那我们取了一个号之后是不是哪儿有座位，我们就可以坐哪儿，这就是非顺序存储。第二点，大家要知道的是，数据的存储结构会影响存储空间分配的方便程度。啊，什么意思呢？比如如果采用顺序存储，然后在这种情况下有人想在这个地方插个队，
那么在这个人插队之前是不是他后面的这些人都分别需要往后挪一位啊？也就是说，如果采用顺序存储的话，那么给这个人分配他所需要的存储空间是比较不方便的。但是如果采用的是非顺序存储的话，那有人想插队，比如说来了一个银行的VIP。那么，是不是只需要给这个人一个更小的，更早的号就可以了？但是可以把这个人分配到任何一个此时空闲的位置。所以，非顺序存储对于存储空间的分配会更方便一些，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907133514657.png" alt="image-20240907133514657" style="zoom:50%;" />

同学们还需要理解的是，这个数据的存储结构，
它还会影响对数据的运算速度。比如，在这两个例子当中，我们想要找到这个队列里排在第三个的人，那顺序存储是不是一眼就可以找到第三个人就是这儿嘛？而如果采用非顺序存储的话，那想要找到此时排在第三位的人是不是就没有这么容易啊？所以数据的存储结构不同，那么对数据的查找，运算，查找操作的速度就会受到影响。那除了查找之外，其他的一些运算速度也会受到存储结构的影响，这一点我们会用后续的章节再慢慢加强大家的理解。好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907133619978.png" alt="image-20240907133619978" style="zoom:50%;" />

### 3.数据的运算

#### 运算的定义

那以上就是数据的存储结构，相关的一些知识点，那接下来要看的是数据结构三要素的最后一个要素，对数据的运算。我们一般会针对数据的逻辑结构来定义，需要对这些数据进行哪些操作，或者说哪些运算。另外，针对不同的存储结构。相应的数据运算实现方式也不一样。比如，海底捞的队列，它是一种线性的结构。那根据队列，这种逻辑结构的特性，
我们可以定义一些在这个场景当中，我们需要实现的。呃，运算，这是从现实需求出发呃提出的一些所需要的运算，比如第一个运算对头元素出对。这个运算肯定是需要的，对吧？服务员在叫号的时候，其实本质上不就是把对头的这个数据元素让他出对嘛？第二个需要定义的运算是新元素入队，比如有一桌新的顾客。他取了一个新的号，那是不是就需要把这桌顾客所对应的数据元素把它啊插入到这个队列的队尾？那就不再举例，
总之我们需要根据啊，数据的逻辑结构来确定，对这种逻辑结构的数据需要进行哪些运算？那根据之前的讲解，我们知道像队列这样的结构，其实在计算机当中会有各种各样的存储结构，存储的实现方式。像左边这种就是顺序存储，右边这种就是链式存储，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907133920303.png" alt="image-20240907133920303" style="zoom:50%;" />

#### 运算的实现

那来看一下什么叫运算的实现，是针对存储结构的，我们现在假设呃，对这个数据结构要做的。操作是要插入一个新的数据元素，也就是九九九号，
那如果存储结构采用的是左边这种顺序存储的话，我们是不是需要把九九九号对应的数据元素把它放到这个位置，对吧？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907133959544.png" alt="image-20240907133959544" style="zoom:50%;" />



而如果采用的是链式存储的话，那可以把九九九号对应的数据元素放到任意一个位置，只需要把九九八和九九九用指针连在一起就可以了。所以虽然我们要实现的运算同样都是在对尾插入一个元素，但是不同的存储结构，它的这个运算的实现方式是不一样的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907134037574.png" alt="image-20240907134037574" style="zoom:50%;" />

好，那到此为止，我们就介绍完了数据结构的三要素，我们在之后的章节当中讨论到任何一种数据结构的时候，都会关注到数据结构的这三个方面。好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907134105311.png" alt="image-20240907134105311" style="zoom:50%;" />

## 数据类型

#### 原子类型

最后我们再来看这个小节中，我们需要了解的最后的两个概念，数据类型和抽象数据类型，什么是数据类型呢？数据类型是一个值的集合和定义，在这个集合上的一组操作的总称，这个不好理解。我们一会儿再解释那数据类型可以进行进一步的分类，第一种叫原子类型，就是指它的值不可以再分的数据类型，比如我们很多编程语言当中提供了布尔类型。int类型，那回头看数据类型的这个定义，什么叫做它是一个值的集合和定义？在这个集合上的一组操作呢？
对于布尔这种数据类型来说，这种数据类型可以取得的值就是。两种true和FALSE，然后可以对布尔这种数据类型进行的操作啊，就是与或非这样的操作，那像int也就是整数这种啊，数据类型来说它。它可以取值的范围就应该是这样一个范围，当然不同的编程语言当中int类型的这个取值范围是不一样的啊，这儿我们只是随便举了一个例子。然后可以对int类型进行的操作就是加减乘除模运算等等，这一系列大家很熟悉的操作。所以讲到这儿，大家应该就能够理解什么叫做呃值的集合和一组操作了

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907134314476.png" alt="image-20240907134314476" style="zoom:50%;" />

#### 结构类型

好，除了原子类型之外，还有结构类型，就是指它的值可以再分解成若干个分量的数据类型。比如在C语言当中，我们很熟悉的struct也就是结构体，我们可以在这个结构体当中定义更多的分量，然后不同的分量可以是不同的数据类型。比如这个结构体，我们是用来表示排队顾客的信息，那对这种结构类型来说，它可以取哪些值，可以对它进行哪些操作，这个我们是需要根据具体的业务需求来确定的。比如如果我们一个店里排队的顾客人数不可能超过九九九，这么多顾客的话，那么我们就可以规定顾客取得这个号数，
它的范围是一到九九九。然后如果每一桌的人数啊，最多不能超过12个的话，那么我们可以把people这个变量，它的取值把它规定为一到12，总之这是根据我们的业务需求来确定的。那我们当然也可以定义对这个结构类型的操作，比如如果要让两拨顾客拼桌的话，那这种运算在背后，我们需要把这两桌顾客把他们的人数就是people。给相加合并当然有可能还需要其他的一些操作，总之对于结构这种数据类型来说，它可以取什么值，可以进行什么样的操作，这是我们根据自己的业务需求，
具体的需求来确定的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907134509931.png" alt="image-20240907134509931" style="zoom:50%;" />

## 抽象数据类型

好，那在这儿我们了解了一些具体的数据类型，了解了具体的数据类型之后，对抽象的数据类型其实就更好理解了。抽象数据类型，英文缩写adt，它是抽象数据组织和与之相关的操作。如果用我们之前学过的知识来理解的话，当我们在定义一个抽象数据类型的时候，其实我们就是用数学化的语言定义了某一种数据的逻辑结构和对。对这种数据的运算，而只有当我们要实际的用计算机去实现这种数据结构的时候，才需要涉及，才需要考虑到呃，
我们到底要采用哪种存储结构？所以，抽象数据类型其实并不关心，并不讨论啊，具体要采用哪种存储结构，只关心另外两个方面。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907134650678.png" alt="image-20240907134650678" style="zoom:50%;" />

好，这个小节我们涉及的概念知识点还是挺多的，我们来快速的把它回顾一下，刚开始我们认识了什么是数据，这个不用过多解释。然后数据对象其实是数据的一个子集，数据对象由呃一系列具有相同性质的数据元素组成，而每个数据元素当中又包含一个一个的数据项。那当我们在讨论数据结构的时候，
我们更关注的是各个元素，它们之间存在的某一种逻辑上的关系。同时，我们还需要定义对这些数据元素应该要实现哪些运算，或者说哪些操作。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907134747240.png" alt="image-20240907134747240" style="zoom:50%;" />



在这个小节的后半部分，我们介绍数据结构的三要素和。抽象数据类型，那当我们定义了一个抽象数据类型的时候，就确定了一个数据结构的逻辑结构和数据的运算，这样的两个方面，也就是定义了一个具体的数据结构。而当我们要用计算机实现这种数据结构和对数据结构的运算的时候，我们就需要考虑需要涉及到这个存储结构的问题。存储结构的不同会导致运算的具体实现不同，
只有确定了存储结构之后才能实现一个数据结构，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907134840629.png" alt="image-20240907134840629" style="zoom:50%;" />

再次强调大家不需要过度的纠结绪论，这个章节当中的某一些。很细节的概念，如果理解不了，或者感觉理解的不够透彻，没关系，先继续往后学，后续内容的学习会不断的巩固，大家对呃以上提到的这些概念的认识。好，那以上就是这个小节的全部内容。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240907134858423.png" alt="image-20240907134858423" style="zoom:50%;" />

# 1.2_1_算法的基本概念（课程标题）

好了，在这个小节中，我们会学习一个新的概念算法，我们会认识什么是算法？算法必须具备的五个特性以及一个好的算法需要具备哪些特质？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909120812809.png" alt="image-20240909120812809" style="zoom:50%;" />

## 什么是算法

好，首先来看什么是算法。曾经有一个计算机界的大佬提出过这样的一个观点，程序等于数据结构加算法。那通过之前的学习，我们知道数据结构研究的就是如何用数据的方式来描述现实世界的问题。呃，包括数值型的问题，非数值型的问题，数据元素之间的关系等等，这些问题如何用数据来描述？
这是数据结构要解决的问题。那除此之外，我们还需要把数据存入计算机当中，对吧？那有了数据之后，我们只有对数据的处理，才会产生实际的价值，所以算法其实研究的就是如何高效的处理这些数据。以解决实际的问题来看一下王道书上给出的算法的定义。算法是对特定问题求解步骤的一种描述，它是指令的有限序列。其中的每条指令表示一个或者多个操作啊，还看不懂对吧？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909120933244.png" alt="image-20240909120933244" style="zoom:50%;" />



没关系，那假如你现在你要解决这样的一个实际问题。
想要做番茄炒蛋，那你要做这个事情，你是不是得先有呃先有食材对吧？什么鸡蛋？四个西红柿，两个料酒等等。那有了食材之后，你就可以开始做菜了，你做菜可以分为这样的一些步骤，西红柿切块啊，第二步是什么鸡蛋打匀，第三步倒入鸡蛋翻炒，第四步倒入西红柿。那经过这样的一些步骤的处理之后，你就可以把你的食材加工为呃，
最后你要吃的这个番茄炒蛋，对吧？你就正确的解决了这个问题，好，所以对于计算机程序来说也是一样的，数据结构就是给计算机提供了一个它要加工的食材。而算法就是描述了啊，这个计算机要如何处理这些食材，描述了具体的步骤好，所以这是数据结构和算法之间的一个关系。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909121034335.png" alt="image-20240909121034335" style="zoom:50%;" />



好，因此算法是求解问题的步骤啊，比如说我们现在有这样的一堆数据元素。它们之间呈现出了这种线性的关系，线性的关系啊，
也就是一个线性表那么。现在我想要实现一个算法，要解决一个这样的问题，我想要把这些数据元素按照年龄递增的次序，把它们进行一个排序。好，那如何解决这个实际的问题呢？我们是不是得分步骤，一步一步来，第一步我们可以先扫描剩下的这五个元素？从中找到年龄最小的一个元素。那现在这几个人当中，年龄最小的一个人是不是叫咸鱼？他只有18岁对吧？那这个元素把它拿出来，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909121128946.png" alt="image-20240909121128946" style="zoom:50%;" />

并且插到第一个位置。这是第一步，接下来第二步，我们扫描剩下的这四个元素，因为之前最小的一个元素，我们已经找到了，对吧？那接下来再从剩下的四个元素当中找到年龄最小的一个元素，是不是就OK了？好，那扫描之后一个一个扫描之后发现诶，这个人他才40岁，是最年轻的，那我们把他这个数据元素。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909121209165.png" alt="image-20240909121209165" style="zoom:50%;" />

插入到第二个位置。
接下来第三步，我们继续扫描剩下的三个数据元素还是一样的，找出这三个数据元素当中年龄最小的一个，把它插入到第三个位置。好，接下来第四步，再从剩下的两个元素当中扫描，找出年龄最小的一个，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909121328604.png" alt="image-20240909121328604" style="zoom:50%;" />

那再把它。插入到第四个位置。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909121403119.png" alt="image-20240909121403119" style="zoom:50%;" />

好，那这样我们是不是得到了一个按照年龄递增的一个排序的结果好，所以刚才我们描述出了处理问题的具体步骤。那这就是一个算法，算法可以用这种自然语言描述，
也可以用伪代码或者代码来描述。当然，如果我们要用计算机实现这个算法的话，那我们肯定得写成计算机代码，对吧？什么C语言JAVA等等。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909121438634.png" alt="image-20240909121438634" style="zoom:50%;" />

## 算法的五个特性

### 有穷性

好，那现在我们已经知道了什么是算法，那么一个算法需要具备哪些特性呢？首先，第一个必须具备的特性叫有穷性，就是一个算法。它必须在执行有穷步之后结束，并且每一步都可以在有穷时间内完成，这是有穷性，
所以相比之下，算法和程序其实是有区别的。算法必须是有穷的，而程序可以是无穷的，因此像我们使用的微信。我们可以说微信是一个程序，但我们不能说它是一个算法，因为你会发现你打开微信之后，它可以无穷无尽的运行下去。就只要你不关闭，那它永远不会停止，而算法又必须在有穷的时间内要完成，所以微信不是算法，但是可以算作是一个程序。好，
那这算法必须具备的第一个特性，有穷性，如果不满足这些特性，那么就不是一个算法。除了刚才我们说的这个呃，可以一直运行下去的程序，它不是算法之外，如果你写了一个死循环，那么它是一个算法吗？显然也不是对吧，因为死循环也不具备有穷性好，所以啊，算法首先必须要具备有穷性。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909121636892.png" alt="image-20240909121636892" style="zoom:50%;" />

### 确定性

接下来，算法还必须具备确定性。
算法当中的每条指令必须有明确的含义，并且对于相同的输入只能得到相同的输出。好，什么叫相同的输入只能得到相同的输出呢？还是刚才那个例子。在刚才这个例子当中，我们会发现这五个人当中有两个人岁数是相同的，他们的年纪。一样大都是49岁好，那我们要得到一个按照岁数递增的一个排序，结果那么上面这种结果。马排在丁前面。这是okay的，对吧？然后下面这种排列方式丁排在马的前面，
是不是也是OK的？同样都是按照岁数递增的这个顺序来排列。但是呢。如果我们写了一个算法，经过算法的处理之后。对于这个算法来说，给定这个相同的输入。一次处理得到上面这些结果，另一次处理又得到下面这些结果，那这个算法就不能称之为一个算法，因为它就不具备确定性。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909121802400.png" alt="image-20240909121802400" style="zoom:50%;" />

我们要求对于相同的输入一定要得到相同的输出，一定要能得到相同的输出好，所以我们算法当中对于各个步骤的描述必须是无歧义的。那为了让这个算法无歧义，
我们是否可以这么描述当两个人的岁数都相同的时候？我们可以呃，按照这样的原则来处理。原本就排在前边的这个人，他会优先的被排在前边。那这样的话，马和丁他们的这个嗯，岁数相同，但是由于马原本就排在前边，就是对于这个输入的这个数据来说，马原本就排在前边。因此，在呃经过算法的处理之后，我们也会让马排在前边，然后丁排在后面，
这是对于岁数相同的两个数据元素的一个处理。好，所以如果能够确定这样的一个无歧义的，明确的，明确的，这样的一个呃规则的话，那么对于相同的输入，我们肯定就可以得到相同的输出，那这样的算法才可以称之为算法。好，因此这是算法需要具备的第二个特性确定性，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909122118002.png" alt="image-20240909122118002" style="zoom:50%;" />

那讲到这儿，大家在对刚才我们给出的这个算法的步骤啊。看一下，当我们在处理到这儿第三步的时候，
只是说扫描剩下的三个元素，找到年龄最小的一个元素，把它插入到第三个位置，但是现在我们可以说。这个元素是年龄最小的，也可以说这个元素是年龄最小的，对吧？所以刚才我们给出的所谓的这个算法的步骤描述当中。其实这种描述是有歧义，不明确的，也就是说我们刚才给出的这个描述，它不具备确定性。不具备刚才所说的确定性。那不具备这个特性的话，其实这个东西就不能称之为算法，
对吧？虽然刚才我们把它谎称为算法，但现在我们知道了。算法的这个求解步骤的描述，必须是具有明确意义，无歧义的好，所以刚才给出的这个我们不能算作算法。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909122233062.png" alt="image-20240909122233062" style="zoom:50%;" />

### 可行性

好，那接下来算法还需要具备第三个特性，叫做可行性。可行性就是说你给出的这个实现方案必须能够用呃，计算机代码来实现，说白了就是这个意思，最后算法还需要有。输入和输出这样的两个因素。

输入就是丢给算法处理的这头数据。（蓝色的数据）

而输出就是算法处理完了之后。得到的这个结果，

这就是输入和输出一个算法，可以有零个或者多个输入，就算法是可以没有输入的。比如说hello world就是没有输入的，并且这些输入是取自于某个特定的对象的集合，这的对象指的是数据对象。比如像刚才这个例子当中。我们给算法处理的这一堆数据，这堆数据它就是来自于个人财富。个人财富这个数据对象里边对吧？这些数据元素都是描述个人财富的数据对象嘛，所以输入是来自于某个特定的数据对象，
算法要对这些输入的数据进行处理。那处理完了之后，算法会产生一个或者多个输出，就不可能说一个算法是零个输出，算法肯定要有一个结果了，就像你hello world最后肯定也会呃有一个打印输出的结果嘛。虽然实际并没有做什么有意义的事情，但是总之只要我们说这是一个算法的话，那它肯定有一个或者多个输出。并且这个输出的结果和实际的输入是有某种特定关系的。所以看到这，我们会发现算法其实和数学里的函数非常类似，对吧？y=fx这个函数。x.
是不是相当于输入啊？这个函数的输入，而f这个映射关系。相当于就是算法，对吧？就是算法，而y就是经过呃f这个映射关系计算之后得到的一个计算结果，所以y。它就是一个输出。好，所以算法和我们这个数学里的函数，其实它思想都是一致的，都是很类似的东西，大家可以打破这些学科之间的次元壁。尽情的去联想这些东西哈好，

### 输入

### 输出

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909122531900.png" alt="image-20240909122531900" style="zoom:50%;" />

那这是算法需要具备的五个特性，第一个特性叫做有穷性。有点穷啊，不是就是在有穷的步骤内就可以完成，有穷的时间内就可以完成啊，这叫有穷性，然后第二个特性叫确定性，第三个特性叫可行性。最后，算法还需要有输入和输出，这是算法必须具备的五个特性，只要其中一个特性不满足，那么这个算法就不能称之为一个算法。



## 好算法的特质

### 正确性

好，那么在满足这些特性之后，
一个好的算法还需要具备哪些特质呢？当我们设计一个好的算法的时候，我们需要呃追求哪些目标呢？那这就是接下来我们要探讨的问题，一个好的算法需要具备的特质好，那第一个特质叫做正确性，这个算法要能够正确的解决问题。一个算法要能够正确的解决问题，这个必须的必是吧，像刚才我们给出的这些例子当中，我们要得到一个按照年龄递增次序排列的这样的一个结果。那如果我们的算法处理之后，得到的结果是这样的。就是有一个比较年轻的人，他排在了后面，
那经过这个算法处理之后，并没有正确的解决问题。因此，这个算法就不是一个好的算法，算法必须是正确的，但是这个算法可以称之为一个算法吗？也可以是吧，它只是没有正确的解决问题，但是我们依然可以把这个算法称为一个算法。好，所以一个好的算法，首先需要具备正确性，能够正确的解决问题。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909125019602.png" alt="image-20240909125019602" style="zoom:50%;" />

### 可读性

接下来，一个好的算法还需要具备可读性。
我们可以用自然语言来描述算法，也可以用伪代码描述算法，也可以用真正的什么C语言JAVA这些啊代码来描述算法，都是OK的。描述算法的方法千千万，但是当我们呃就描述一个算法之后，这个算法呃最好是具备可读性。比如你写C语言代码，实现了某一个算法。那么，你的这段代码，它可读性不好的话，就意味着你的队友要跟你协作。他看了你这段呃代码之后一看，啊，
这是什么piece of shit对吧？就你的队友可能看不懂你的代码，这样的话，你们团队协作就会有问题，另外呢，如果他可读性不强，你自己写了一段时间之后啊，回头看自己的代码。你看这个嗯，这是谁写的？你自己都看不懂啊，那这个代码虽然它实现了一个算法，但是它不具备可读性。可读性很差，那这显然就不是一个好的算法好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909125753939.png" alt="image-20240909125753939" style="zoom:50%;" />

所以一个算法还必须具备可读性，一个成熟稳重的程序员在写程序的时候。通常会在自己的代码后面一些关键的地方写上注释。用注释的方式来提高算法和代码的可读性，这个是一个成熟稳重的程序员必须具备的一个一个素质哈。好，所以以后如果我们写到代码题的时候，<u>你也要给这些改卷老师写一写注释，你不要用一个纯代码来描述你的逻辑。你写了注释的话，改卷老师肯定也会更喜欢嘛，这小伙子不错是吧？</u>好，那这是好的算法，需要具备的第二个特质，
叫做可读性。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909125918253.png" alt="image-20240909125918253" style="zoom:50%;" />

### 健壮性

接下来，一个好的算法需要具备的第三个特性叫做健壮性，就是当输入非法数据的时候，算法能够适当的做出反应，并且进行处理，而不会产生一些莫名其妙的输出结果。比如像刚才我们要给这些人，这些人啊，按照年龄递增的次序来进行排序，但是这些人当中混入了一个奇怪的家伙，他的年龄是负100岁。那这个数据显然是非法的，不正确的，那如果你设计的算法在处理这堆呃数据的时候。
发现其中包含了一些非法数据，并且对这种错误进行处理，比如说给出什么报错的提示等等，那这样的算法它就是健壮的。可以适当的对这些错误的非法的数据啊，做出反应，这是一个健壮的算法。而如果你的算法根本不会检查这些东西，不关注这些边界，这些细节的啊，条件呃，给你一堆数据，那么我不管三七二十一将错就错，还是把这些非法数据啊进行了一个处理。那这样的算法就是健壮性不够强，
不够strong好，所以好的算法需要具备的第三个特性叫做健壮性。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909130152084.png" alt="image-20240909130152084" style="zoom:50%;" />

### 高效率与低存储量需求

接下来好的算法还需要具备高效率和低存储需求。所谓高效率，就是你的电脑执行这算法的时候，花的时间少，而低存储量需求说白了就是。执行算法的过程当中，你的内存开销小，不费内存，那如果用接下来这两个小节要介绍的呃术语来描述的话。高效率指的就是时间复杂，度低而低，存储量需求指的就是空间复杂，度低，
那在接下来两个小节当中，我们会为大家介绍这两个重要的知识点。啊，怎么度量一个算法的时间复杂度和空间复杂度，这也是第一章里面重要的考试内容。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909130400524.png" alt="image-20240909130400524" style="zoom:50%;" />

好的，那么在这个小节当中，我们学习了算法相关的一些基本概念。程序等于数据结构加算法，因此当我们说我们要设计一个好的程序的时候，其实背后包含了两个问题，第一个问题，我们要设计一个好的数据结构。来描述我们要处理的问题，第二，
有了数据结构之后，我们还需要基于数据结构来设计一个好的算法来处理这些数据。因此，设计一个好的程序，就是要设计一个合适的好的数据结构以及高效率的算法。那说大白话，数据结构就是我们要处理的一些信息，而算法就是处理这些信息的一个具体的。步骤对于我们来说，我们就是要用代码的方式来描述处理信息的，这些步骤

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909130519350.png" alt="image-20240909130519350" style="zoom:50%;" />

好，那一个算法必须具备五个特性。叫做有穷性，确定性，可行性，
输入和输出这五个特性啊，是算法必须具备的，只要其中一个不满足，那么这个算法就不能称之为一个算法。好，那在满足了这几个特性之后，我们还需要精益求精，追求这个算法尽可能的好，那一个好的算法需要具备这样的一些特性，分别叫正确性，可读性，健壮性。还有高效率和低存储量需求，那最后的这个特性就是接下来两个小节，我们需要研究的问题。
高效率指的就是执行时间尽可能的少，而低存储量需求就是执行的过程当中不费内存，那接下来的两个小节当中我们就会分别研究这两个问题。如何度量一个算法的时间复杂度，以及如何度量一个算法的空间复杂度好，那么接下来我们进入的这两个知识点就相对来说会比较硬核。大家做好准备，好的，那以上就是这个小节的全部内容。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909130615953.png" alt="image-20240909130615953" style="zoom:50%;" />

# 1.2_2_算法的时间复杂度（课程标题）

各位同学大家好，在这个小节中我们会学习上一小节遗留下来的一个问题，算法的效率应该怎么度量？那需要从两个方面考虑，分别是时间复杂度和空间复杂度，在这个视频中，我们会首先介绍时间复杂度应该怎么计算？那顾名思义时间复杂度就是用于评价一个算法的时间开销，这样的一个指标，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909130908918.png" alt="image-20240909130908918" style="zoom:50%;" />

## 如何评估算法时间开销？

那首先我们用自己的直觉来想一想。可以用什么样的思路来评判一个算法的时间开销呢？其实站在我们程序员的角度来看，一个算法它肯定终归是要用某一种程序代码来实现的。那我们要评判这个算法的时间开销，是不是很自然的可以想到，我们只需要让这段程序这段代码上机器跑一下，
然后看一下它的运行时间是多少？是不是就可以统计出一个算法的时间开销，也就是采用事后统计的方式，但是用这样的方式来评价一个算法的优劣，其实存在一些问题。第一，我们的这段程序代码，它的执行速度是不是和机器性能是有关的？在好的机器上可能很快就能运行，在差的机器上可能要很久才能运行。所以你不能说一个算法统计出来，它运行时间短，它就一定优秀，或者运行时间长，它就一定不优秀。
这是不客观的，另外算法的时间开销还和呃，你实现这个算法所采用的编程语言是有关系的，越高级的语言执行效率越低，比如你用C语言。写的程序一般就要比JAVA写的程序啊，效率上要更高一些，因为JAVA是更高级的语言，所以同一个算法用不同的语言实现也会导致我们最终。统计出来的，看到的这个运行时间会有偏差，但本质上算法还是同一个算法，我们并不能说这是算法设计上的问题。只不过是由于使用的编程语言不一样导致的，再一个方面算法的时间开销，
还和这个编译程序产生的机器指令质量是有关的。呃，那这个不再展开，看不懂也没关系，最后我们还想强调有的算法，它是不能事后再统计的，比如如果你写的算法是用于控制导弹轨迹的。那你不能说先让这个导弹试射一发，等它打到错误的地方，我再来统计运行时间，那这样就没有意义了，因此如果用事后统计这样的方式来评估一个算法的时间开销的话，这种方式这种思路是有问题的。那刚才我们列举的前三个原因说明了，如果我们只是采用事后统计运行时间的方式来评估一个算法的优劣的话。
那么，除了算法本身设计的好坏之外，其实还会有其他的很多外界因素，也会影响这个算法的实际运行时间。所以我们应该能够想到，在评价一个算法的优劣的时候，是否能够排除和算法本身无关的那些外界因素呢？这是第一个优化的思路。然后刚才提到的第四个原因又说明了我们的算法，其实应该预先就能够估计出它的时间开销。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909131244349.png" alt="image-20240909131244349" style="zoom:50%;" />

那我们的算法时间复杂度其实就是呃，想要在算法运行之前就预估出一个算法，它的时间开销t。和问题规模n之间的关系，这儿的t代表的是time什么意思呢？
我们的一个算法，它的运行时间t。应该是和它要处理的，这个问题规模大小是有关的，对吧？如果问题规模越大，那这个算法它的运行时间也理应更长。所以算法的时间开销t应该是和问题规模n之间呈现某一种函数关系的。所以当我们在分析一个算法的时间，复杂度的时候，最重要的就是要尝试着用问题规模n这个参数来表示出算法的时间开销。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909131459702.png" alt="image-20240909131459702" style="zoom:50%;" />

好，那既然是要分析算法的时间复杂度，那我们自己啊，当然需要写一些小例子来作为练手的工具。
刚好在备课的这两天看了一部电影呃，复联四它里边有这样的一段很暖心的对话，这个父亲也就是钢铁侠告诉他女儿说我爱你1000遍，然后这个女儿说那我爱你3000遍。好，那我们设计一个简单的算法，用来实现表白，爱你n遍这个事情，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909131546877.png" alt="image-20240909131546877" style="zoom:50%;" />

用C语言来实现的话就是这个样子啊，我们把它称之为逐步递增型爱你。这儿定义一个变量I啊，表示的是I你的程度，然后接下来就会进行n次循环，每一次会导致I的值加一。并且会打印出爱你的程度，
然后最后还会打印出这样的一句话，那我们在main函数里调用这个逐步递增型爱你这个函数啊，传入的n的值n的值是3000。这儿的n其实就是问题的规模，因为传入的参数n越大的话，那么这个循环的次数也会越多，也会导致这个算法的运行时间会越长。那接下来我们来尝试分析一下这个问题，规模n和算法的执行时间t之间有什么关系？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240909131749026.png" alt="image-20240909131749026" style="zoom:50%;" />

在这个算法中，我们写了这样的五行代码，给它分别进行编号。我们默认执行这样任意一行代码，所花的时间是相同的。虽然实际上它们执行时间肯定不一样，
但是如果考虑太多因素的话，我们就没办法来评价这个算法了，所以我们把问题简化。好，那接下来我们来数数，看这些代码分别执行了几次，第一行代码很显然只执行了一次。好，那接下来我们来数数，看这些代码分别执行了几次，第一行代码很显然只执行了一次。第二行代码，它是一个while循环做了一个条件判断，不难看出这个循环里边的代码总共会执行3000次，但是这个循环的条件判断。
它需要执行3001次，因为执行了第3000次之后，还需要进行判断，发现I的值已经到3001了，那在这个时候它才可以跳出循环执行第五句。所以这个条件判断这一句应该是执行了3001次，而里边三四这两句执行了3000次，那第五句很显然也只执行了一次。所以当问题规模为3000的时候，这个算法的执行就应该花费这么多单位的时间，那如果把3000换成n的话，我们也可以得到。呃，时间开销t和n之间的一个表达式关系分析的方法和刚才是一样的，如果一行代码执行的时间需要一毫秒的话，
那么这个式子是不是说明？当问题规模为n的时候，这个算法的时间开销应该是3 n+3这么多毫秒，当然我们并不需要带入单位去考虑，因为我们已经说了，在不同机器上执行它的速度是不一样的。但是我们从这个式子当中可以看到问题，规模n和算法的时间，开销t之间的关系。那我们的这个算法，其实它的时间复杂度的表达式还是相对来说比较简单的，但是如果换一个算法，比如说它的时间表达式算出来之后有什么n的三次方加上。什么6n的平方，加上一堆东西，
那当这个时间复杂度的表达式变得很复杂之后，我们就很难从这个表达式当中看出一个算法，它到底是好算法还是坏算法？所以接下来要探讨的第一个问题是，我们是否可以忽略这些表达式当中的某些部分，或者说是否可以把这个时间复杂度的表达方式给简化呢？第二个要探讨的问题是，如果一个算法，它有好几千行代码，当这个代码很长的时候，我们如果还用刚才这种一行一行来数的这种方式来统计的话。那显然，这种思路是不切实际的好。那首先来看第一个问题，能否简化时间复杂度的表达式。
那我们刚才的那个算法，它的时间复杂度是这个样子，那假设现在还有另外的两个算法，它们的时间复杂度和问题规模n之间的关系分别是这个样子。其实不难想到，当问题规模n足够大的时候，我们可以忽略掉这些表达式当中更低阶的这些部分。让大家直观的感受一下，当问题规模n=3000的时候，对于第一个算法的时间复杂度，我们只保留它前面更高阶的这个部分。也就只保留3n，那么我们计算的结果应该是得到9000，这是它的时间开销，而如果把表达式的后面部分也考虑进去的话，
那计算结果是9003。其实区别不大，对吧？再来看第二个算法，如果我们只保留它阶数最高的这一项，也就是n的平方的话，那么计算的结果n的平方是这个样子。而第二个算法的时间开销的精确表达是这个样子，其实区别不大，对吧？也就是说，如果现在有这样的一个算法，它。它的时间开销和问题规模n之间的关系是tn=n^2，那么我们可以认为这个算法。
和t2这个算法其实差不多是一样优秀的，对吧？谁也不比谁好多少，谁也不比谁差多少，所以当我们评价t2这个算法的时候，其实可以把它的时间开销。后面的这些低阶的部分给去掉就不考虑进去，对于第三个算法其实也是一样的，我们只保留它的。时间开销表达式的最高阶的这一项，那么算得的结果n的三次方和它本身的这个精确表达其实差的不大。同样的，也就是说，如果有一个算法，它的时间开销和问题规模n之间的关系是时间开销等于n的三次方。
那么，这个算法的优劣程度和这个算法的优劣程度也差不多，因此我们得出的结论是。一个算法的时间开销表达式，我们只需要保留接触更高的部分就可以了，也就是说第一个算法我们可以认为它的时间开销是等于3n。第二个算法，我们可以认为它的时间开销是等于n的平方，第三个算法，我们可以认为它时间开销是n的三次方。其实，当我们在评价一个算法优劣的时候，甚至还可以把这个常数项也给忽略掉。也就是说，如果有一个算法。
它的时间开销和n的关系是tn=n，那么当问题规模为3000的时候啊，这个算法的时间开销就应该是3000个单位的时间，对吧？你说这个算法和时间开销为9000的算法区别大吗？看起来相差三倍，但其实它们的时间开销也是同一个数量级的。就有点类似于你和你舍友，你有3000块，他有9000块，你说谁比谁富有多少吗？不见得吧，但是如果有一个人他有。900万的话，那这已经不是一个数量级了，
因此当我们在描述一个算法的时间复杂度的时候，一般来说，我们只需要关注它的时间复杂度是什么样，一个数量级就可以了。那可以用这种所谓的大o表示法来表示一个算法的时间开销，它到底是什么样的数量级？如果一定要用严谨的数学思维来描述的话，那我们可以说tn=o。fn意味着limit当n趋近于无穷的时候，这个tn的。精确表达式和o里边的这个fn，这两个表达式，它们的比值的极限。应该是等于某一个常数k的，这就是这个大o表示法背后的一个数学含义，
可能有的同学还没有复习到高等数学，所以这儿理解不了也没有关系，我们只需要知道对于时间复杂度的度量。我们只需要关注它的表达式当中最高阶的这一项，并且把它的系数给干掉化为一，然后在前面套一个大o就可以了。用这样的方式来表示一个算法的时间开销应该是什么数量级的？那我们的课本上是用这样的数学语言来描述了，刚才我们提到的那个过程，第一个叫做加法规则，就是说多项相加的时候只保留最高阶的项，并且。系数变为一，如果硬要套公式的话，就意味着呃，
比如我们t3这个表达式，我们可以把它写成。on的三次方加上o。n的平方，再加上o。注意，这儿我们已经把这个系数变为了一，然后加法规则指的是多个大o相加的时候，我们只保留阶数最高的数量级，最高的那个大o。也就是只保留最高的这一项，所以t3我们可以把它记为t 3=o的三次方，这个所谓的加法规则其实和我们刚才说的是同一个事情。另一个要注意的是，乘法规则就是当两个大o相乘的时候，
需要把它们合并那来看一个会同时用到加法规则和乘法规则的例子。假设有这样的一个算法，它的时间开销和问题规模n之间的关系是这样的，那按照加法规则，我们只需要把相加的这两项。给它套上一个大o就可以了，就是表示它的数量级，其实这儿已经用到了乘法规则n方乘以log n其实是两个呃，关于n的表达式的相乘嘛。所以如果要用大o表示法表示它们的数量级的时候，我们只需要把它俩相乘合并就可以了，也就是在外面统一套一个大o。好，那我们知道，根据加法规则，
当这样的两项相加的时候，我们只需要保留数量级更大的那一项就OK了。那n的三次方和n方乘以log 2n到底哪一个的数量级更大呢？这是我们接下来要探讨的问题，直接给出结论，这是大家在进行算法复杂度分析的时候。啊，经常会碰到的一些常见的数量级，从左到右依次递增，这个要很熟练，因为我们已经说了，在计算复杂度的时候，我们需要判断。到底哪一个表达式，哪一个项的阶数更高，
我们只保留阶数更高的那一项，而为了判断谁的阶数更高，大家就需要记住这一串的东西。好，那刚才我们纠结的点在这个地方，就是n的三次方和n方乘以log 2n到底谁的阶数更高，那其实n的三次方我们可以把它写成n的平方×n。所以这儿有一个n的平方，这儿有个n的平方，那我们是不是只需要判断log 2n和n到底谁的阶数更高，谁的数量级更大？这样的话，我们就可以确定到底要保留哪一项，对吧？好，
那根据这个式子，我们很容易看出是n的数量级要比log 2n更大的。所以我们应该保留的是on的三次方这一项，这是加法规则嘛，如果要用数学手段来证明的话，其实也很简单，我们只需要看一下，当n足够大，也就是当n趋近于。无穷的时候log 2n和n的比值，我们用洛必达法则就可以得到这样的一个式子，那这个极限的值是零。意味着当n趋近于无穷，或者说当问题规模n足够大的时候n要比log 2n变大的速度快很多，也就是增长率更大。
所以如果说有一个算法，它的时间复杂度是大n这个数量级的，另一个算法，它的时间复杂度是。是log 2n这样的数量级的，那很显然第二个算法会更优秀一些，同样的我们计算一个极限就可以证明。二的N次方，这样的数量级要比n的平方数量级要更大啊，同样是用洛必达最后得到的极限是。啊零也就是说，当n足够大的时候，二的N次方变大的速度要比n的平方变大的速度快很多。同样的，如果有一个算法，
它的复杂度是二的N次方，这样的数量级另一个算法，它的复杂度是n的平方，这样的数量级，那显然第二个算法也会更优秀一些。当然，其实在数据结构这门课当中，只需要把这些记下来就足够用了，不要求大家会自己证明，所以极限这个部分，如果目前这个阶段暂时看不懂，没有关系。呃，别紧张，给大家一个图，
可以很直观的体会到不同的数量级，它们的增长速度的区别。其实这儿的y指的是时间开销，也就是之前我们一直提到的tn来看一下，常数阶也就是o1这样的算法。这种算法的时间开销并不会随着问题规模的增大而增大，所以这种算法在时间方面的表现肯定是最优秀的，那稍微更次一些的是呃，时间复杂度。等于对数阶这样的算法看一下，这个曲线就可以知道，随着问题规模的增大，这种算法的时间开销，其实增长的速度并不会特别快。那再往后更次的，
就应该是幂函数阶这样的算法，这个k可以是一二三等等等哈，那显然这个k的值越大那。那这个算法肯定越差，那比幂函数阶还要差的算法就是这种指数阶的算法，最差的是时间复杂度等于阶乘这种数量级的算法。好呢，教大家一个咒语长对密指接。常数级的小于对数级的小于幂函数级的小于指数级的小于阶乘级的。长对幂直接好，那如果我们能够快速的判断时间复杂度的表达式当中到底哪一项的阶数更高，那么我们就可以快速的应用。加法规则只保留更高阶的项，所以到此为止，我们回答了第一个问题。
当我们在讨论一个算法的时间复杂度的时候，我们并不需要给出。这个算法的时间开销t和n之间的详细的表达式，只需要关注这个表达式的数量级就可以了。好，接下来看第二个问题，刚才我们求问题规模n和时间开销t的方法是一行一行代码来分析。但是如果一段程序，它有好几千行代码，那很显然一行一行来数这种方法是不实际的。比如我们在第一行代码之前又插入了1000行顺序执行的代码，所谓顺序执行的代码指的是不带有循环的代码。那如果是这样的话，我们的这个算法的时间开销t又需要多加1000，因为它会多执行1000行。
那如果代入n的话，后面加的这个常数就应该变成是1003，而不是三，但是经过之前的学习，我们知道我们只需要关注。这个时间开销的数量级就可以，也就是用大o表示法来记，虽然后面的这个常数项看起来大了很多，但是如果用大o表示法来记的话。其实这两个表达式，它们的数量级都是on这样的数量级，因此我们得出结论顺序执行的代码，它只会影响常数项。可以忽略，也就说我们并不需要一行一行数，
前面的这1000行代码甚至不需要数，第一行和第五行代码。我们只需要关注循环这个部分就可以了，那之前我们在分析这个循环内部的语句的时候，其实我们把整个循环所涉及到的这三条语句都已经考虑进去了。但是经过之前的分析，我们知道这样的系数最终肯定都是变为一的，当我们只考虑这个表达式的阶数的时候，其实不管这个系数是多少，最终我们肯定都会把它变为一。也就是说，其实我们只需要分析这个循环当中的某一条语句，某一个基本操作就可以了。我们只需要随便挑一个语句来分析这个语句的执行次数和n的关系。对于这个算法来说，
循环里边的任意一条语句啊，像四这个语句，它的执行次数就应该等于n，因此我们最终得到的这个算法的时间复杂度。就是on这么多好，那既然我们只需要关注代码当中循环的部分，那如果说有嵌套的循环。那这种代码应该怎么分析呢？我们在这个while循环里边又加了一个for循环，这个for循环会循环n次。然后外面这一层while循环呃，也会循环n次，因此里边的这个for循环总共会执行n×n，也就是n的平方这么多次。因此，
考虑时间开销的话，外层循环的这些语句，它们的时间开销应该是on这个数量级的，因为它总共执行n次嘛，而内层循环的这些语句。句它的执行次数就应该是n的平方，这样的数量级，那根据之前提到的加法规则，我们只需要保留更高阶的这个部分，也就是保留on的平方。这就是这个算法，时间复杂度的数量级，所以我们得出的第三个结论是如果有多层嵌套循环的话，那么我们只需要关注最深层的。这个循环，
它到底循环了几次？我们需要找到它循环的次数和问题规模n之间的关系，这样就可以求出算法的时间开销。好，那到此为止，我们就回答了刚开始提出的两个问题，接下来我们来做两个小练习，这儿给出了第三个算法。这个算法会设置一个变量I，这个I的值表示的是I你的程度，然后这儿有一个while循环，每一次I的值会翻倍，也就是乘以二。直到I的值比n大的时候，它才会跳出这个循环，
然后执行最后这一句，那打印输出的结果是这个样子啊，当然这只是截取了小部分。好，那我们的重点是来分析一下这个算法的时间复杂度，根据之前的学习，我们知道像这一句，还有这一句这些顺序执行的语句，我们可以不管，我们只需要关注循环的部分。并且挑选这个循环当中的，随便一条语句，然后看一下它的执行次数和n之间的关系，那我们假设这个printf执行了x次，也就是说这个循环总共循环了x次这么多。
那I的值刚开始是一第一次循环，是不是会导致I的值变为二，而第二次循环又会使I的值再次翻倍，也就变成四。然后再往后的话是86，32，以此类推，这是第一次循环，第二次循环，第三次循环。所以当循环了x次之后，I的值应该是二的x次方这么多，对吧？那根据这个循环的条件，我们知道当I的值。
大于n的时候，这个循环就可以跳出，也就是说当二的x次方大于n的时候，这个循环就可以结束。不难理解，当循环次数x=log 2 n+1的时候，刚好可以让I的值大于n。也就是说，这个循环里边的某一条语句，它的执行次数就应该是这么多，所以这个算法的时间开销tn应该和x这个表达式是同等数量级的。那根据加法规则o的log 2 n+o一，我们需要把后面这个舍弃只保留高阶的部分，因此这个算法的时间复杂度就应该是o的log 2n。好，
这是第一个练习，第二个练习，我们再把这个算法再给改一下，我们需要传入一个数组，这个数组的长度是n这么多。然后这个数组中乱序的存放了一到n这些数，我们的这个算法要做的事情是从这个数组的第一个元素开始，依次往后寻找。要找到这个数组中值为n的那个元素，找到这个元素之后就可以跳出循环，然后结束这个算法。所以大家会发现，对于这个算法来说，输入的这个flag数组不一样，那么它的这个循环次数也会不一样。
因为它是从第一个元素开始，依次往后查找的，所以如果它要找的n这个元素，它刚好是在flag这个数组的第一位。那么，是不是这个循环只需要循环一次，它就可以结束了？而如果n这个元素，它是在flag数组的最后一位。那是不是这个循环就必须循环n次，直到查到最后一个元素，它才可以跳出循环？因此，当我们计算这个算法的时间复杂度的时候，就需要考虑不同的情况。
最好的情况就是元素n在第一个位置，这种情况下，这个循环只需要循环一次，所以这个算法的时间复杂度应该是o1，就是常数级的。这是最好的情况，那这个时间复杂度，我们把它称之为最好时间复杂度。那最坏的情况就是我们说的第二种情况，元素n在最后一个位置，在这种情况下，这个循环需要执行n次，所以这个算法的时间复杂度变成了on。那如果不考虑这两种特殊的情况，我们考虑平均情况的话，
我们应该怎么计算呢？如果要考虑平均情况的话，我们会假设。这个元素n它出现在任意一个位置的概率都是相同的，也就是说flag这个数组它其实就是有n个这样一个一个小格子。然后n这个元素有可能出现在其中的任意一个格子当中，并且出现的概率都是n分之一好，那假设n这个元素出现在第一个位置的话。循环的次数应该只需要循环一次，对吧？如果n出现在第二个位置，那应该循环两次，如果n出现在第三个位置，那应该循环三次，以此类推。
由于这个元素出现在每个位置的概率都是n分之一，所以我们再乘上这个概率全中，这样的话就可以得到一个数学期望。平均来看，这个算法要找到元素n所需要的循环次数，平均是二分之n加一这么多。那如果用大O记法的话，它的数量级就应该是on这么多，所以从这个例子当中，我们可以看到很多算法，它的执行时间和输入的数据是有关系的。所以对于这一类的算法，我们需要考虑在不同的情况下，它的时间复杂度是多少，一般来说我们只会度量一个算法的最坏情况和平均情况。
对于最好时间复杂度，其实这个参考的意义不大，因为当我们在评价一个算法的时候，我们主要是想看一下这个算法，它在一些不好的情况下是否会出现。啊，这种运行时间过长的问题，因此当我们评价一个算法的时候，一般只考虑最坏和平均复杂度。那在之后的学习中，我们还会遇到很多实际的算法，还会带大家分析更多的这种时间复杂度。所以大家在学习这个小节之后，只需要掌握一些基本的方法就可以，以后我们还会有更多的练习。
好再快速的回顾一下这个小节中我们介绍了什么是时间复杂度，时间复杂度应该怎么计算，大致上分为这样的几个步骤，第一是要找到一个所谓的基本操作。对于有循环的程序来说，我们只需要看最深层的循环，它循环了几次，找到它循环的次数和问题，规模n之间的关系。当然，除了循环结构的算法之外，其实还有递归型的算法。递归型的算法大家会在课后习题当中遇到。我们需要用问题规模n来表示出基本操作的执行次数，找到它们之间的这个关系。
然后基本操作的执行次数，它的数量级其实就是算法的时间复杂度tn，当我们在评价一个算法复杂度的时候，只需要关注这个算法复杂度的。数量级就可以，也就是用大o表示法，如果复杂度的表达式当中有多个项，那么我们只需要保留更高阶的那个项就可以。那到底哪个项更高阶呢？我们这儿给出了呃一个，大家需要记住的东西，记住的口诀就是巴拉拉能量，常对幂指阶。然后最后我们介绍了呃，在有的算法当中，
我们必须考虑到最坏情况和平均情况，因为对于有的算法来说，输入数据不同，那么它的运行时间也会受到影响。所以今后的学习中，我们主要关注各个算法的最坏时间，复杂度和平均时间复杂度好以上就是这个小节的全部内容，大家在理解了之后一定要自己动手做一下我们的课后习题。来巩固对时间复杂度的理解，每一年的考研当中，时间复杂度的分析肯定都是占有一定分值的。所以一定要注意练习好，那赶时间的同学可以开始学习下一个视频，如果不赶时间的同学和大家分享一个小故事，就是想用我自己亲身经历的一个事情告诉大家为什么？
我们只考虑就是问题，规模足够大的时候的情况，先给出结论，很多算法的性能问题，只有在问题规模足够大的时候，才会暴露出来。我大四的时候在一家游戏公司实习，然后当时我接到一个任务，让我写一个玩家之间匹配对战的一个算法。那我设计的那个算法，其实就使用了两层的嵌套循环，也就是说我那个算法的时间复杂度是o的n方这么多。我自己私下测试这个算法的时候呃，我只用了大概两三百个玩家，这样的数据来测试，
也就是说我的问题规模n也就是几百，这样的数量级。我的代码逻辑是没有问题的，但是当我把代码提交在线上，服务器部署之后，问题发生了，当时我们那个游戏同时在线用户。已经到几十万这个级别了，可以算一下，我在本地测的时候，我的时间开销tn就应该是100的平方，也就是一万，对吧？而部署到线上之后，实际的时间开销就应该是十万的平方，
也就是十的十次方这么多，所以你看一下当这个问题规模增大的时候。即使我们的线上服务器，它的处理能力已经很强了，但是对于这种复杂度的算法来说，依然不是短时间内就可以执行完的。所以由于我的这个算法设计有问题，就导致了当时的几十万玩家都受到了影响。后来我的师傅帮我优化了我的算法，改成了on这个级别的复杂度，也就是说如果问题规模大概是十万，这个等级的话，那么时间开销也就是一零。零零零这么多，比起十的十次方小太多太多了。
因此，想通过我工作当中的这个亲身经历，让大家意识到算法的时间复杂度，真的是很重要。这个是我们程序员的基本功，在你的代码真正的跑在商业的环境里边的时候，你算法的性能就有可能会因为问题规模增大而。而暴露出来，甚至导致一些不可挽回的经济损失。好的，那么以上就是这个小节的全部内容。
