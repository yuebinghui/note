各位同学大家好，在这一小节中我们会学习顺序表的查找操作怎么实现？那分为两种查找，一种是按位查找，一种是按值查找，我们会分别介绍怎么用代码实现，并且会分析这个代码的时间复杂度。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920190808034.png" alt="image-20240920190808034" style="zoom:50%;" />

## 顺序表的按位查找

好，那首先来看按位查找怎么实现对一个线性表进行按位查找，就是要从这个线性表l当中取得第i个元素。那如果这个线性表是用顺序表的方式实现，并且是用静态分配，这样的方式实现的话，那么所有的数据元素就是存放在data这个数组当中，那在这种情况下想要获得第i个数据元素其实非常简单，唯一需要注意的是。
第i个元素啊，它对应的数组下标应该是i- 1，因为这个位序是从一开始的，而数组下标是从零开始的。那这个元素的返回值和你的数据元素的类型是相同的，当然如果想让你的代码健壮性更强一些的话，在这个地方是不是还可以判断一下这个I的值？是否合法好，那这个也很简单，就不再展开

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920190912401.png" alt="image-20240920190912401" style="zoom:50%;" />

好接下来看一下，如果我们采用动态分配方式来实现顺序表的话，那么data这个变量，它其实是一个指针。这个指针指向了顺序表当中的第一个数据元素，那存储这个顺序表所需要的内存空间是用malloc函数申请的一整片的连续空间。
虽然data这个变量它是一个指针，但是同样可以用这种数组下标的方式访问相应的元素。这有可能是跨考的同学，不知道的点好，那我们来分析一下计算机在背后，它做了一些什么？你的这个data变量，它其实是一个指针。指针指向了malloc函数给它分配的一整片连续内存空间的起始地址，也就指向了这个地址。那我们假设现在这个指针，它所指向的地址是2000。然后在这个图当中，我们假设这样的一小格代表一个字节的大小，也就是1b的大小，
那如果说你的一个数据元素，也就是你的elemtype需要占六个字节的话。那么你用L点data 0这样的方式取得的值，其实就是从data这个指针所指向的这个地址。再往后六个字节的内容，你在这儿给它return了一个data 0，其实就是给它返回了这六个字节的内容，而这六个字节当中对应的内容刚好就是你的第一个。一个数据元素

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920191450283.png" alt="image-20240920191450283" style="zoom:50%;" />

好，那同理如果你的代码里写的是data 1的话，那data 1所对应的数据就应该是从二零零六这个地址开始，往后的六个字节。也就是你的第二个数据元素，那再往后的话也是一样的，就不再列举好，
那在这个地方，我们所定义的data指针，它所指向的数据类型就是element type这种类型。所以如果你按这种数组下标的方式来写代码的话，那其实计算机在背后会根据你的这个指针所指向的数据类型，它所占用的空间大小。来给你计算每一个数组下标，它应该对应的是哪几个字节的数据？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920191641695.png" alt="image-20240920191641695" style="zoom:50%;" />

好，那如果说我们定义另外的一个指针，这个指针它所指向的地址也是这儿也是2000。不过我们把这个指针它的呃类型规定为指向int型，而一个int型的变量是占四个字节。那么，你用类似的这种呃指针加上数组下标的方式来取得数据的话p0，
它所对应的数据就应该是从2000这个位置开始。往后的四个字节，这四个字节的内容是p0，再往后的四个字节是p1。再往后的四个字节是p2，以此类推，所以这是跨考的同学要理解的一个点，<u>用某一个类型的指针加上数组下标的这种方式来访问数据的话。那么，系统在背后为你取数据的时候，每一次取几个字节，其实和你的这个指针所指向的类型有关。</u>

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920191847451.png" alt="image-20240920191847451" style="zoom:50%;" />

因此，这也就能解释，为什么我们在之前的课里边给大家强调过，如果你用malloc函数申请一片连续的内存空间。那么，malloc函数返回的这个指针，你需要把它强制转换为和你的这个数据类型相对应的同类型的指针。因为虽然指针指向的都是同一个地址，但是如果你的这个指针所指向的数据类型，你给它定义错了，那么在访问你的数据元素的时候也会出现问题。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920192226892.png" alt="image-20240920192226892" style="zoom:50%;" />

### 时间复杂度

好的，那么既然顺序表按位查找这个操作，它只需要这样的一个return语句都没有任何的循环，也没有递归调用。所以按位查找这样的操作，它时间复杂度就应该是o1，那这也是我们之前提到过的顺序表。
随机存取的特性能够实现随机存取的基础就在于顺序表当中所有的数据元素在内存里边都是连续存放的，并且这些数据元素的数据类型相同。也就是说，每一个数据元素所占的内存空间是一样大的，所以我们只需要知道一个顺序表的起始地址。然后再知道每一个数据元素的大小，就可以立即找到第i个元素，它存放的位置。好的，那这是按位查找，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920192435597.png" alt="image-20240920192435597" style="zoom:50%;" />

## 顺序表的按值查找

接下来来看按值查找，按值查找操作就是要找到这个线性表l当中。有没有哪个数据元素和我们传入的这个参数e是相等的，如果能找到这样的数据元素的话，那么就要返回这个数据元素的存放位置。
好，那这个基本操作的实现也很简单，我们在这儿传入一个参数e。然后这个地方执行一个for循环，从这个顺序表最开始的那个元素开始依次往后检索。依次判断这个顺序表当中的各个数据元素和我们传入的这个数据元素e是否相等。如果相等的话，那么返回这个数据元素的位序，由于这个地方我们返回的是位序变量I指的是数组下标。所以我们在返回的时候需要用数组下标加一好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920192657047.png" alt="image-20240920192657047" style="zoom:50%;" />

那来看一个实际的例子啊，我们定义了这样的一个顺序表，这个顺序表当中数据元素的数据类型是int类型。并且这个顺序表已经初始化，而且插入了六个数据元素，
也就插入了六个int型的变量，那由于这个顺序表存放的是int型的变量。所以我们要对比啊，两个int型的变量，只需要用这样的一个运算符来进行比较就可以了。除了int型变量之外，像char double float等等这些基本数据类型都可以直接用判断相等的这个运算符来进行比较。

好，那现在假设有人调用了你这个函数，他想找的是在这个线性表l当中有没有等于九的数据元素？那首先会执行这个for循环，刚开始I是等于零的，并且lens的值等于六，那第一个数据元素，它的值和九是不相等的，
也就是这个if条件不满足。所以会进行I加加的操作。I的值由零变为一，然后进行第二轮的循环，第二轮循环扫描的就是这个数据元素和九依然不相等。因此I的值会变为二，然后进行第三轮的循环，第三轮循环就找到了和这个参数相等的数据元素，因此会返回这个数据元素的位序，也就是三。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193205791.png" alt="image-20240920193205791" style="zoom:50%;" />

好的，那接下来要思考的问题是，如果说我们的这个顺序表当中，它所存放的数据元素类型是一个更复杂的结构类型的话。那么，
两个结构类型的比较是否也可以用这种等于等于这个运算符呢？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193432115.png" alt="image-20240920193432115" style="zoom:50%;" />

答案是不能，我们在这儿定义了一个叫做customer的结构类型，然后写了一个简单的函数，声明了a和b这样的两个变量，这两个变量都是customer这种类型。并且我们故意把这两个customer里边的呃字段值都设为一，然后在这儿写一个if语句，我们想尝试用等于等于这样的运算符判断。a和b这两个结构类型的数据是否相等，但是会发现这个IDE提示我们说你的这个运算符它是。不可以用于比较两个customer类型的变量的。所以如果用这样的运算符来比较两个结构类型的变量的话，那别说是让这段代码运行了，你的这段代码连编译都编译不了。
所以如果要对比两个结构体的话，那么你必须自己写代码来分别的对比这个结构体里边的各个分量是否相等。如果这些分量都相等的话，那么就可以认为这个结构体是相等的，当然你也可以实现一个基本操作用来判断你所定义的两个结构体是否相等。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193600523.png" alt="image-20240920193600523" style="zoom:50%;" />

好，总之在C语言当中，你是不可以直接用，等于等于这个运算符来判断两个结构类型是否相等的。而如果使用C加加的话，你可以尝试重载这个运算符，为了照顾到跨考的同学，这儿就不再展开。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193751674.png" alt="image-20240920193751674" style="zoom:50%;" />

那给大家的建议是呃，在你们考研初试当中，
如果说这个学校，他说他考的科目就叫数据结构。那你在判断两个数据元素是否相等的时候，可以直接使用，等于等于这个运算符，不管你的这个数据元素到底是基本数据类型还是结构类型？因为数据结构这门课，它更多的是考察你对数据结构还有数据结构相关的算法的一个理解，并不会过分严格的要求你的这个代码。是否严格遵照某一种编程语言的规则？但是如果你报考的那个学校，它考的科目里边，它告诉你是考C语言程序设计。那么，这个学校在改卷的时候，
也许他就会比较在意你的这个C语言语法是否够严格？当然了，这个具体问题具体分析，大家最好还是看一下相关的历年真题，它题目里边是否要求你的C语言语法啊，要足够的标准。那这个地方给大家一个小小的提醒

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920193849609.png" alt="image-20240920193849609" style="zoom:50%;" />

### 时间复杂度

#### 最好

#### 最坏

#### 平均

好，那接下来分析一下，按值查找这个操作的时间复杂度要算时间复杂度的话，我们需要关注的是最深层循环的。这个语句的执行次数也就是循环了几次，这个循环次数和问题规模n之间的关系是什么？那我们这儿的问题规模n。指的是线性表的表长好，那时间复杂度分为最好最坏和平均三种情况，
最好的情况肯定是如果你要找到这个值，刚好和表头元素的值相同的话。那这个循环是不是就只需要执行一次，所以最好时间复杂度应该是o1常数阶的，

那由于我们检索这些数据元素是从头到尾一个一个往后检索的。所以如果你要查找的这个值，它是最后一个数据元素的话，那么循环的次数就需要循环n次。需要把n个数据元素全部扫描一遍，才可以找到目标，所以最坏时间复杂度应该是on，

而平均时间复杂度，我们可以先假设呃，你要找的这个目标元素出现在任何一个位置的概率都相同。那总共有n个元素，
也就是说出现在任何一个位置的概率都是n分之一，而如果这个目标元素在第一位的话，那么循环只需要循环一次，在第二位的话，循环两次，以此类推，如果在第n位，那就循环n次。因此，平均来看，这个平均所需要的循环次数就应该是这个循环的次数乘以这种情况发生的概率，然后相乘相加。最终得到的结果应该是二分之n加一，因此平均时间复杂度应该是大on

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920194257875.png" alt="image-20240920194257875" style="zoom:50%;" />

好的，那这个小节的内容很简单，
我们学习了按位查找和按值查找。那由于顺序表当中的各个元素都是连续存放的，所以如果想要找到顺序表第I个元素的话，只需要o1的时间就可以立即找到。也就说，顺序表具有随机存取的特性，而如果是按值查找的话，那么我们需要从第一个元素开始依次往后检索。当然，如果这个顺序表当中的数据元素，它是按照某一种顺序，比如说从大到小或者从小到大的排列的。那对于数据元素有序的这种顺序表的查找，其实会有很多更高效的算法，那这个我们会在之后查找那个章节。
来学习其他的更高效的查找算法，但是如果顺序表当中的数据元素，它们本身存放就是没有任何规律的，那就只能从第一个元素依次开始往后寻找。平均来看，找到目标元素，时间复杂度应该是on那<u>再次强调跨考的同学需要注意位序和数组下标的关系。</u>

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920194820436.png" alt="image-20240920194820436" style="zoom:50%;" />

另外，还需要注意怎么判断两个结构体，也就是struct数据类型，它们是否相等。好了，那以上就是这小节的全部内容。

## 1

来，我们来看这道题，我们先快速过一下每个选项，然后我再来讲为什么首先看a选项，它是毫无疑问的正确的，因为它没有存放指针域，因此存储密度大。然后BC选项是一个链表的优点，我们等会讲，然后d选项通过看数我们就能知道顺序存储结构是并不能够很方便的表达所有的逻辑结构的。我们来看一下几个例子，首先我们看这个，这是一个计算机的一个内存，然后左边是内存的地址。然后我们看一下当前我们这是一个顺势存储结构的一个内存，那么由于顺势存储结构，
它是。没有这个指征域的，所以说它的数据前后关系全靠物理地址上的前后关系来搭建的。比如说这是第一个位置。那么，我们第一个位置，接下来的物理的下一个位置就是它逻辑上的下一个位置。然后理所应当，一直往下。一直到它标记给你的终止，这是一个通过物理地址来标记一个逻辑上的前后顺序的一个方法。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925193953177.png" alt="image-20240925193953177" style="zoom:50%;" />

我们再来看一下使用一个后面的指针日会带来什么样的效果，这个时候假设。我以六提前告诉你，作为起始点，
然后这是我们要读的内容，然后六后面是指针域，它写了一个八这。这个八意思是什么呢？意思是这一条信息的下一条是八？然后我们读到了第二条信息，然后从第二条信息的指针域，我们又读到了再下一条的地址。假设这里是个零。然后我们读到了第三条在这里，然后读这个信息，然后再读零这一点的一个地址，零这一点的地址，比如说我告诉你是三。直到这里读它的信息，
然后这里比如说是一个空，然后它就是终止了。这是左右就是一个典型的一个顺势存储结构和链式存储结构的一个例子，我们来看一下BC选项。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925194135524.png" alt="image-20240925194135524" style="zoom:50%;" />

我们举相同的一个例子，假如说我们现在首先存储了四个数据，然后左右是相同的。右边是一个顺序存储，假设是零零一零零二零零三零零四。然后左边儿是我们的链式存储，我们同样首先我们要记住61个起始，然后零零一。下一条是八零零二，然后下一条是零零零三，然后再下一条是三零零四，
然后我们来挨个来看一下插入和删除各是怎么样操作的？首先我们看右边，假设我现在要在零零二和零零三中间插一个零零五。那么，在我们的顺序存储结构里面，应该怎样插入呢？是不是应该先把零零四放到下一个位置，再把零零三放到下一个位置？然后再在这里写上零零五才可以呀。这是只是四个元素的意思，如果我下面有100个元素，你是不是就要往下移100次，然后再把零零五放进来才可以啊？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925194242628.png" alt="image-20240925194242628" style="zoom:50%;" />

那么，我们来看一下链式存储结构是什么样的？
同样在零零二和零零三中间，我们要插一个零零五。首先，我们任意找一个内存空闲的，我们写上零零五，然后再联想一下零零五的下一个是谁呀？是不是零零三呀？那么，零零三的地址是零，所以我们这儿写一下零，让我们看到零零二的下一个是不是变了呀？不是零了呀，是不是我们新添的这个了呀？我们把新添的地址写在这里。这是不是已经构建好了呀？
我们再走一遍，第一个是六零零一。然后下一个是八零零二，下一个是五零零五，然后下一个是零零零三，然后再下一个零零四没问题。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925194430521.png" alt="image-20240925194430521" style="zoom:50%;" />

我们再来看，删除的时候是怎么操作的？我们同样删除这个零零五，看一下在右边，我想要删除这个零零五，是不是得首先？把它抹去，然后把下面的所有的每一个上移一位啊。假设下面有无数个的话，
是不是要上移很多很多次呀？那么，我们看左边儿怎么操作？是不是就是一个反操作呀？首先把这一行抹去，然后把这里的五改成零。是不是就已经操作完成了呀？所以说插入运算方便和删除运算方便是我们链式存储结构的一个优点，而不是顺序存储的优点。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925194545087.png" alt="image-20240925194545087" style="zoom:50%;" />

我们再来看一下d选项。以数为例是什么意思呢？瞬时存储结构和链式存储结构要注意，我们这里的链式存储结构只有一个指针域。但是它并不是说链式存储结构只能有一个指针域，比如说。
我现在有一个有两个指针域的，然后我要存一棵树，怎么存呢？我们不能举一些很正常的例子，我们举一个比较特殊的例子。假设是这样的。我们标一下号，这是一号节点，这是二号节点，这是三号节点，这是四号节点，我们在这样一个表里面是怎么存的呢？首先任意找一个开始。然后写上这是一号节点，我们假设这两个指针域各是left和right。
然后三号地址，它存了一号节点，一号节点的左指针指向了二号，二号是谁呢？我们假设在这里放一个二，然后把它的地址写在一的。这里，然后三号任意找一个地方写上三号，只要空闲的都能放，不用按顺序，然后把它的地址写在这里。然后我们来再来看一下二号节点，它的left和right是不是都是空呀？那我们把它的指针这里置成空，然后我们看三号节点，
它left是不是有呀？又是不是就没有了呀？我们在一个任意的一个地址里面写上。这里，然后我们看三的这里写上它的地址，是不是就是零呀？然后再在四这里看它左右都是空，因此这两个地方也是空。那我们看我们是不是已经通过，只用了四个地址就已经完成了这棵树的一个存储了呀，并且很清晰。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925194800308.png" alt="image-20240925194800308" style="zoom:50%;" />

那么，如果用顺序存储结构，应该怎样存呀？是不是不太好存呀？
我给大家提供一个思路，就是说我们无论是什么样的树，我们都把它假设成一个满的。然后把这些虚拟的节点设成空。然后你再在顺序里面存，怎么存呢？一二三，然后空空。四空。这样是不是完成了这棵树的一个存储呀？我们可以看到是相当浪费空间的，对不对？这些空间都被白浪费掉了，如果说我们现在是一个。比较大的一个数，
而且空集点较多的话，甚至我可以举这样的一个例子。一直往下指。没有旁边儿的节点，是不是浪费的空间相当大呀？所以说它并不方便，所以我们这道题。选a。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925194909929.png" alt="image-20240925194909929" style="zoom:50%;" />

## 2

我们来看这道题，那么这道题啊，考察的是跟顺序表有关的概念，首先我们来看a选项，a选项说顺序表可以利用因维数组来表示啊，这个前半句话是没有问题的。然后后面又说他说因此顺序表与一维数组啊，
在逻辑结构上是相同的，那么后面这句话就错了。因为这二者之间啊，是没有逻辑关系的顺序表，一定是一维数组吗？这个不一定的顺序表，我们绝大部分时候啊，都是用一维数组来表示。但并不代表顺序表一定是用一维数组来实现的，那么一维数组来实现的所有结构啊，都是顺序表吗？那么其这其实啊，也是不对的。因为我们后面啊，如果学到树的时候学到图的时候，
那么我们也知道像二叉树那么像最典型的二叉树，它的顺序存储啊，我们也可以用什么？一维数组来实现的，也就是说，一维数组在逻辑结构上也有可能是什么树形结构，对吧？那么也有可能是二叉树，那么这个到时候我们学到二叉树的时候啊，自然会学到的。所以a选项是错误的，那么b选项说在顺序表中啊，逻辑上相邻的元素物理上不一定相邻，那么b选项也是错的。那么，
顺序表的定义什么？顺序表的定义就是说逻辑上相邻的元素啊，你的物理位置上也一定相邻，这个就是顺序表，它本身的定义如果说。连这一条都不符合的，那么它就一定不是顺序表了，所以b是错误的，那么c选项说顺序表和一维数组一样，那么都可以进行随机存取，对那么c选项是对的。c选项为什么是对的呢？那么正是因为它什么？它逻辑上相邻的元素啊，它的物理位置上也一定要相邻的。
并且啊，在和这个d选项说在顺序表中啊，每个元素的类型啊，不必相同，那么d选项也是错的，因为。在数据表中，我们规定每个元素的类型必须相同，并且逻辑上相邻的元素啊，它的物理位置上也一定相邻。那么，基于这两套，我们就能够保证什么？和一维数组一样，都可以进行什么随机存取，
所以一维数组它为什么能够进行随机存取呢？那么本质上也是因为它逻辑上相邻的元素。物理位置上一定相邻，并且每个元素的类型相同，那么也就是说它们所占的空间也一定相同，所以这就是我们什么能够进行什么随机存取的原因。所以本题的正确选项就是c选项。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925195803431.png" alt="image-20240925195803431" style="zoom:50%;" />

## 3

好的本题讲解结束。呃，我们来看一下这道题，这道题最主要的就是线性表的一个存储结构上的一个关系，这道题很容易误选b，为什么呀？主要就是你。顺势存储和顺势存取之间是不是比较像呀？
所以你觉得可能就是一个b，然后直接就一选了，对不对？当你对这道题比较蒙的时候。但是实际上你要注意一下，随机存取和顺序存取的一个概念，我来给大家讲一下，在随机存取和顺序存取之间是一个什么样的关系？如果说这是一个结构，不管它是什么结构吧，我们就随便写一些数据进来，也不管这些结构之间是怎么联系的，不管你是链式呀还是顺序呀，我就不管你了那么。如果说你。
比如说你现在想要找到一个元素，你现在有一个数据，你想要知道它，比如说我告诉你，我想要知道第四个数据是谁，我想要知道它的结果，那么怎么办？如果说你是一个随机存取的结构，什么叫做随机存取啊？什么叫做顺序存取啊？我直接来解释，如果说你直接直接就能通过，我给了你一个四，你就给我找到直接找到。这个这就是你想要的，
这就叫做随机存取，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925200053820.png" alt="image-20240925200053820" style="zoom:50%;" />

如果说你想要找到四的，你得从头开始找见它，然后通过它找到二通过二找到三通过三找到四这个你，然后你才能把。四给我这个结果，那么你这个叫做顺序存取，那么为什么说这个名字呀？其实也好理解，大家这样想一下，随机存取什么叫做随机，就是你随机给我一个数，我都能立刻给你，结果这叫做随机存取。什么叫做顺顺序存取啊，
我不管你给我的是数是什么，我都只能按顺序一个一个存一个一个取，我才能够给你，结果这就是什么叫做随机存取一个，什么叫做顺序存取，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925200324238.png" alt="image-20240925200324238" style="zoom:50%;" />

然后我们来看一下。顺序存储结构，它是怎么存的呀？是不是这是一块儿内存，然后你一个数据在这儿，一个数据在这儿，你是不是紧贴着存取？你是不是紧贴着把它们放在了这里？也就是顺序存储对不对？也就是按顺序往下放对不对？
也就是说你直接地址就是相邻的每一块大小也固定了，那么我问你，你知道起始地址了，你知道每一块大小是多少了，然后我想要跟。你要第六块儿的数据在哪儿？你是不是直接起始地址加上六乘以这个大小？你是不是就能给我找到第六块儿在哪儿呀？是不是直接就找到了？所以说对于存储结构而言。顺序存储，它是一种随机存取，明白吧？选的是一个a，而什么是顺序存取啊？
顺序存取的存储结构更主要是在一个单链表，也就是链式存储结构之中出现。那么，这就是这道题主要的一个问题，大家掌握好

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925200450278.png" alt="image-20240925200450278" style="zoom:50%;" />

## 4

。我们来看这道题，那么这道题啊，其实就是考察了什么随机存取啊，它的一个定义那么顺序表具有随机存取，那么指的就是什么查找序号为I的元素的时间啊，与顺序表中的元素个数啊。是关的那么正确，选项就是c选项，那么AB啊，它说的是查找值为x啊，
那么不管是有序顺序表也好，还是无序顺序表也好，它要查找一个哎。特定的值的元素啊，那么它肯定是与什么元素个数n啊，肯定是有关系的，那么我们说的随机存取，比如说最典型的是一维数组对吧，比如说t啊等于AI，我要查找这个AI这个元素。它是和这个哎，一共有多少个元素n啊？它是没有关系的，因为我可以直接通过这个序号I啊，就定位到这个元素，
那么这叫随机顺序那么。为什么能够实现随机存取呢？那么就在于什么它这个顺序表啊，逻辑上相邻那么它物理上也相邻，并且什么每个元素都是在相同大小的存储空间，那么就能够做到。通过一个序号I，那么我们就能够定位到啊，它是具体啊，在哪个位置？所以正确选项就是c选项好的，本题将已结束。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925200802499.png" alt="image-20240925200802499" style="zoom:50%;" />

## 5

来，我们来看这道题，想要知道一个顺序表所占用的存储空间和什么无关，
我们是不是首先要弄明白它到底和什么有关呀？那么，一个顺序表，它到底占了多大的空间？是怎么得来的？是不是一个元素？它占了多大的空间？然后再乘以你一共有多少个这样的元素？你是不是就得到整？个顺序表你占了多大的空间呀？就是有多少个乘以一个占了多少就是这样，然后我们来看一下这个AC选项。这里的a表的长度就意味着刚才我们所说的它表中到底有多少个，而这个元素的类型我们知道，不同类型的元素，
它一个元素所占的空间是不？不一样的，甚至可以说是你元素是什么类型，你就直接决定了你一个元素占了多大。这句话没问题吧，所以说元素的类型直接决定了一个元素所占的空间，它们之间是画等号的。所以说AC选项就是我们一般所得出来的一个结论。那么，接下来就是BD选项，我们继续看一下b选项元素的存放顺序，那么这个肯定是和我们总共占了多大空间是没有关系的。为什么你到底是先放a再放b，你总共占了空间和你先放b再放a，你占的空间是不是肯定一样呀？
因为a和b是相似的元素，它们都是同一类，它们每一个都是同样的大小，同样的大小，然后乘个二在这里也同样如此，你里面装的不管是a还是b，你的空间都是一样的，对吧？所占用的存储空间大小和你的存放顺序是肯定无关的，那么接下来我们来看一下d选项d选项容易产生一些混淆。他说，元素中各自段的类型，那么有人就要疑问了，这个各自段是哪儿来的？这句话是什么意思呢？
我给大家来解释一下，它的意思是说我作为一个顺序表，我中间是不是一个一个的元素呀？但是我这一个一个元素是不是其实就是一个个类呀，而这一个类有可能是你自建的一个，比如说我自己建了一个类，这类中包含一个int一个string。然后或者还有别的一些，比如说字符之类的，叉r之类的，然后一系列我把这一组。它是一个元素，懂我意思吗？比如说我现在还是之前的那个例子，是个人信息，
而一条个人信息是不是存了很多呀？比如说int，比如说存的是电话号码。string比如说存的是嘉兴住址，还有别的差呀，存的乱七八糟的各种东西，它们合起来是我所需要的一条信息，而这一条信息是我一个顺序表所装的单位元素。那么，我的单位元素我可以自己起一个名，比如说起名person。这就是我的一个种类的一个名字，那么我们现在来看一下它符不符合之前我们所说的？很明显是符合的，对吧？
大小怎么来？还是这两条第一条顺序表中有多少个person×1个person，它占了多大的空间？那么，这就可以得出来，我们总共占的空间大小了，但是我们注意一下我这一个类里面是不是其实包含了很多个字段呀？而这每一个字段是不是都有自己的类型呀？那么我问你，假如说我现在只有int和string两种类型的话，我这个int我一改变，我把这个int也改变成string。或者改变成叉，也就是说我这个partisan这个类中有一个字段的类型发生了改变，那么什么改变了？
是不是单位元素所占的空间就改变了，为什么会改变？是不是因为我的单位元素所占的空间是等于？所有字段的各个类型的空间的之和呀。那么，你某一个改变了，你是不是势必影响了整个呀？所以说元素中各自段的类型是和这个单位元素所占的空间是有关系的，最后我们选的是一个b选项。那么，这道题我们就到这里。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925201449072.png" alt="image-20240925201449072" style="zoom:50%;" />

## 6

来，我们来看这道题。首先读题的时候注意，这里最常用的操作是存取第I个元素及其前驱和后继元素的值。注意，这里它并没有说按顺序存取第I个元素，然后再读它的前驱，然后再读它的后继，对吧？所以我可以随意调转顺序，对吧？所以说我直接把题意翻译成这样，就是你需要快速存取di- 1个di个和di+1个元素的值。没问题吧？那么如果你这么读一遍题的话，是不是和这样读题变得不一样了呀？
如果你在上面这里读题的话，你是不是会产生一种错觉？你首先需要找到第I个元素。然后去找第二个元素的前驱，然后去找第二个元素的后继呢，但实际上我们不需要这样对吧？我们直接找到第i- 1个，我们是不是就知道它是第I个元素的前驱？虽然这时候我们还没有找到第I个，对吧？也就是说在它没有提供一个顺序的情况下。你直接切入点，放在了第二个元素，然后去寻找如何从第二个元素找前找后，然后选择了b选项。
这个整体的思路就不对，一定要注意题，意b选项是这道题最容易混淆的一个地方。然后整道题有一个关键点，它所说的是最常用的操作，是存取怎么怎么怎么怎么样，它并没有说你当前结点是dx元素，对吧？也就是说，你无论如何，你都要从头去开始找，对吧？再加上题中又暗示了你这里提高效率，也就是说他想让你快速的找到第I个节点，对吧？
那么我们想一下。如果说你想选这个b选项，刚才我们所说的它是一个混淆视听的，非常容易误选的一个选项，那么我们来看一下b选项在什么时候适用呢？它会怎么表述呢？它会这样说。若某个线性表，它常用的操作是获得当前节点的前驱和后继元素的值，注意它要强调。你现在节点已经走到了你所获得的那个节点了，然后你想要获得前一个节点，这时候你是不是必须要用双向链表你才能往前走一步呀？一定要指明当前节点，你这里的这个双向链表才务必要派上用途。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925203307879.png" alt="image-20240925203307879" style="zoom:50%;" />

那么，我们回到这道题来看，他说，提高效率，然后第I个元素前序后继，就是di- 1个di个和I+1个。那么没有什么问题，它考的其实是一个随机存取的概念，而不是说你如何找前并且找后，也也就是这个考点导向是一个b选项。那么，实际考的电视随机存取的话，我们就比较好说了，你知道它考的是这个，你直接就能选出来是一个d选项，
因为只有顺序表，它是能够实现随机存取的。你直接就能获得di- 1个di个和di+1个元素的值，直接通过你的起始，加上你的下标就可以了，对吧？那么，这道题就讲到这里。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925203524620.png" alt="image-20240925203524620" style="zoom:50%;" />

## 7

来，我们来看这个题，我们先来看一下这个顺序表，顺序表是能够完美实现我们其中所说的两点。第一个是存取任意指定序号的元素。第二个是在最后进行插入删除。同时，
顺序表又是最简单，也就是最高效，也就是最节省时间的一个操作。我们来看一下为什么首先这是一个顺序表的一个物理上的一个结构。我们知道，顺序表在存储的时候，物理上的一个顺序就是它逻辑上的顺序，比如说我们从三开始。到八截止，这是我们记录的信息，那么它的顺序就是一个一个往下。这就是它的一个逻辑上的一个顺序，我们来进行一下逻辑上的编号，三这儿是零四，这儿是一二三四五。
假如说我们想要现在想要找到逻辑上是三号的一个，它的值想要读取这个值，那么我们直接拿起始的地址。加上你的编号，是不是就等于你想要的结果的地址呀？就能够找到这个值，就不需要进行其他的读取操作。然后我们再来看一下，如果说是一个链表的话。会是什么样的情况？如果是一个链表的话，这是我们的起始，我们想要读到第三号是在这里，对吧？因为是零一二三对吧？
想要读到这个地方的值，我们需要从起始开始，然后读下一个地址，一直往后读，对吧？一直读到这里为止，你总共读取了四次，你才读到你想要的对吧？而在这里，我们只进行了一次计算，加一次读取就可以了。所以说是更节省时间的。我们再看一下bcd是为什么不可以？bcd均是由链表进化而来的，进化这个词儿我说一下，
就是说它是由链表。一步一步增添了更多的功能而来，但是增添功能意味着更方便的同时，也意味着有时间和空间上的一些代价。我们来看一下他们是如何进化而来的，首先这是一个单链表，假设是从这里开始进化。首先，第一种进化。就是在尾节点上加了一个指回头节点的一个指针，它就进化成了我们的单循环链表，也就是d选项。然后我们再来看一下它另一种进化方式，还是这样的，对吧？
然后它在每一个指针都增添了一个指向前一个结点的指针，嗯，当然除了头指针对吧，它就构成了我们的b选项。叫做双链表。然后我们看一下c选项是如何进行这个进化的，首先它在b的基础上先增加一个循环二字，你看双链表，然后先进行一个循环。怎么循环呢？其实就跟单链表变成单循环链表是一样的，就是尾节点增添了一个指回头节点的，然后头节点也增添了一个指回来的，为什么要有一个指回来呢？因为它是双循环，
对吧？然后这时候我们就实现了这一步，然后再带一个头节点，就是额外有一个指针指向头节点，然后这个指针我们存着。然后我们随时就可以跳回头节点的位置，这就是bcd是如何从单链表进化而来的，那么单链表是不能实现随机存取的，那么这三个也就是不能实现随机存取的。嗯，这道题就这样。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925204309752.png" alt="image-20240925204309752" style="zoom:50%;" />

## 8

来，我们来看一下这道题。数组表示n个元素的一个线性表，然后时间复杂度为大o1的操作是什么？
我们来看一下这四个。首先，我们先定义一下整体，你是一个数组对不对？对于数组而言，实际上就是一个顺序存储，按顺序存放你的元素就行了，然后我们来看一下一二三四一。访问第I个节点，那么是不是直接按照数组而言，它是一个顺序存储，它是一个随机存取，你是不是直接就能找到第I个节点呀？通过起始地址。乘上一个每一块儿的大小，
加上一个通过起始地址，加上一个你是第几块儿乘以中间到底有每一块儿有多大，是不是就能够得到你第I个节点，你的具体的地址是在哪儿呀？然后第二个求第I个节点的直接前驱，那是不是就是让你求di- 1个节点啊？求di- 1个节点是不是又返回到上一个问题啊？也就是让你访问di- 1个节点对不对？那么是不是这也是没问题的？然后我们来看一下第二个，它说在最后一个节点后插入一个新的节点，是不是没问题？插进来了，没问题吧？直接大o1 OK，
所以说一和二是满足的，然后三删除第一个节点。这就麻了烦了，对不对？你想要删除第一个，你是不是得把第二个节点放在第一个第三个节点放在第二个第四个节点放在第三个，然后吧啦吧啦，直到第n个节点放在第n- 1个，然后你才能够完成这一步操作呀。所以说你这个复杂度是不是一个大on，它是不符合的，然后第四个在第I个节点后插入一个节点是不是其实和第三个差不多？你在中间第I个节点处，后面要插入这个一个节点，你首先得把最后一个后移，
然后再把倒数第二个移到倒数第一个的位置，然后一直这样移，一直这样移，一直这样移，直到移到第I个节点后面的。是因为i- 1，然后往后移到i- 2之后，你di- 1的位置，你是不是才空了出来？你空了出来，你是不是才能够插进来啊？所以说对于它而言，它的一个复杂度也是wn。那么，我们是不是发现三和四都是不可以的？
一二和二是可以的，所以说我们选的是一个c选项呀。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925204905668.png" alt="image-20240925204905668" style="zoom:50%;" />

## 9

来，我们来看看这道题。这道题问的是其实还是考的是顺序表和链表的一个区别，对吧？然后核心的一个区别就是。顺序表是有一个随机存取的一个功效的，我们再来看一下各个选项是如何体现这一点的，首先第一个选项，它让你直接输出第I个元素的值。随机存取肯定是效率无敌高的，就是说你要读第I个元素的值，你只需要。I+1个你的起始地址，
然后减一就可以了，至于为什么减一，大家可以自己想一下，就是用特指想一想就可以了。然后这样就能直接计算得到第I个元素的地址，然后就能进行读取操作了，而在链表中是如何实现的呢？你需要依次读取第一，第二，一直到第I个。你得每一个往下读，你才能读到第I个元素的地址在哪？然后你才能获得它的值，然后我们再来看第二个小项。同样还是这个随机存取的一个特性，
如果说你想要交换第三个元素和第四个元素的值，在顺序表中，你能直接找到第三个和第四个元素的位置。然后直接对它进行交换操作就可以了，就是把第三个位置，然后先存一下，然后放入第四个元素的值，然后再把第四个元素的位置塞入，刚才我们存下来的第三个元素的值，我们就完成操作了。但是在链表中，我们需要依次读取第一个，得到第二个的地址，然后读第二个，得到第三个地址，
然后读第三个，得到第四个地址，然后再对第三和第四的数据。进行操作一二选项，它们同样考的都是这个随机存取的一个特性。然后第三个选项，由于它说的是顺序输出，所以说无论是顺序表还是链表都需要依次读取n个元素的值，各读一遍。所以说两者的时间复杂度是一样的，也就是效率是一样的，所以这道题我们选c。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925205624531.png" alt="image-20240925205624531" style="zoom:50%;" />

## 10

哈哈哈。来，我们来看一下这道题长度为n的一个顺序表，
你要删除第I个元素，我们来想一下，问你要移动几个元素，假设这个长度是n，然后你要删除di在这里。然后你要删除I，你是不是I这里直接没了，没了之后是不是从I+1到n这些个节点，每一个都要往前移啊，也就是n+1是要向前移一位n+2。I+2需要向前移一位I+3需要向前移一位，直到n需要向前移一位，其实就是问你从I+1到n中间一共整个有多少个元素，对不对？那么我问你。
从一到n有多少个元素？是不是n个那么你怎么算的？是不是n- 1+1啊？那么我问你，从I+1到n1共有多少个元素？是不是n-i+1再加一啊？没有问题吧，也就是说问你从二到n1共有多少个元素，你是不是n- 2加个一你得出来是一个I+1 i- 1个元素啊，为什么因为一到n是一个n个元素，所以二到n是I？是n- 1个元素，这时候你直接能通过逻辑算出来的，然后通过这个逻辑算出来的结果，你再通过这个算式来核验一下，
你核验一下这个算式得出来，这个算式之后你是n- 1个I+1，然后括起来整个再加个一。这是不是就能够得到整体的一个向前移动的操作步数呀，然后我们把它最后把它拆开n-i，然后这个键是键一+1消掉，所以就是n-i对不对？选的是一个c选项。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240925210339004.png" alt="image-20240925210339004" style="zoom:50%;" />