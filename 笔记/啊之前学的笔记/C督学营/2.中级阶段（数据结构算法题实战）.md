

## é¡ºåºè¡¨

### åˆå§‹åŒ–

### æ’å…¥

### åˆ é™¤

### æŸ¥æ‰¾

```c++
#include <stdio.h>

#define MaxSize 10
typedef int ElemType;
typedef struct {
    ElemType data[MaxSize];
    int length;
} SqList;


void InitList(SqList &L) {
    L.length = 0;
}


// é¡ºåºè¡¨ æ’å…¥éæ³•L.lengthå°±+1
// æ’å…¥å€’å™å¾€åç§» j = L.length; j >= i; j--

// é¡ºåºè¡¨ åˆ é™¤éæ³•L.length
// åˆ é™¤æ­£åºå¾€å‰ç§» j = i; j < L.length; ++j
bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) { // i>L.lengthæ˜¯å› ä¸ºä½ æ¯”å¦‚ç©ºæ•°ç»„ï¼Œä½ iå¯ä»¥æ˜¯1ï¼Œè¡¨æ˜æ’å…¥ç¬¬ä¸€ä¸ªä½ç½®ï¼Œä½†æ˜¯ä½ iä¸å¯ä»¥æ˜¯2ï¼Œè¿™æ ·å°±è·¨äº†ä¸€ä¸ªä½ç½®ç›¸å½“äº1æ˜¯ç©ºçš„
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }

    for (int j = L.length; j >= i; j--) { // æ³¨æ„æ’å…¥æ˜¯æŠŠå…ƒç´ å¾€åç§»åŠ¨
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

bool DeleteList(SqList &L, int i, ElemType &e) {
    if (i < 1 || i > L.length) { // åˆ é™¤çš„ä½ç½®ä¸åˆæ³•
        return false;
    }
    e = L.data[i - 1];

    for (int j = i; j < L.length; ++j) {
        L.data[j - 1] = L.data[j];
    }
    L.length--;
    return true;
}

int LocateElem(SqList L, ElemType e) {
    int i;
    for (i = 0; i < L.length; ++i) {
        if (L.data[i] == e) {
            return i + 1;
        }
    }
    return 0;
}

int main() {
    SqList L;
    InitList(L);

    for (int i = 1; i <= 5; ++i) {
        InsertList(L, i, i * 10);
    }

    int del = 0;
    DeleteList(L, 1, del);

    printf("%d", LocateElem(L, 20));
    return 0;
}
```

## é“¾è¡¨

##### å¤´æ’æ³•

åªå¯ä»¥ä»å‰å¾€åéå†ï¼Œå•é“¾è¡¨çš„èµ·å§‹ä½ç½®å¤´èŠ‚ç‚¹æ˜¯ä½ç½®0  ï¼Œ0æ˜¯å¤´èŠ‚ç‚¹ï¼Œå¤´èŠ‚ç‚¹æ˜¯ä¸å¯ä»¥è¢«åˆ é™¤çš„

Læ˜¯é“¾è¡¨çš„å¤´æŒ‡é’ˆï¼Œå¾€ç¬¬iä¸ªä½ç½®ï¼Œæ’å…¥å…ƒç´ ä¸ä¼šæ”¹å˜Lï¼Œæ‰€ä»¥ä¸ç®¡æ’åˆ°ç¬¬å‡ ä¸ªä½ç½®Lå¤´æŒ‡é’ˆæ˜¯ä¸ä¼šå˜çš„ï¼Œæ‰€ä»¥æ’å…¥å’Œåˆ é™¤ä¸éœ€è¦é€šè¿‡å¼•ç”¨çš„æ–¹å¼

å¤´æŒ‡é’ˆæ˜¯Lï¼Œå¤´èŠ‚ç‚¹æ˜¯ç¬¬ä¸€æ¬¡ç”¨mallocåˆ›å»ºçš„ç»“æ„ä½“èŠ‚ç‚¹

å¤´éƒ¨æ’å…¥ç®€å•ç‰ˆ

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;
//LNode*æ˜¯ç»“æ„ä½“æŒ‡é’ˆï¼Œå’ŒLinkListå®Œå…¨ç­‰ä»·çš„

void ListHeadInsert(LinkList &L) {
  // mallocé‚£é‡Œç”³è¯·åœ°å€ç”³è¯·çš„æ˜¯ç»“æ„ä½“å¤§å°çš„åœ°å€ï¼Œæ‰€ä»¥å¡«å…¥LNodeï¼Œè€Œä¸æ˜¯LNode\*æˆ–è€…LinkList
    L = (LNode *) malloc(sizeof(LNode)); // å¤´èŠ‚ç‚¹
    L->next = NULL;
    int x;
    LNode *s;//ç”¨æ¥æŒ‡å‘ç”³è¯·çš„æ–°ç»“ç‚¹
    scanf("%d", &x); // â“ä¸ºä»€ä¹ˆè¿™é‡Œéœ€è¦åŠ è¿™ä¸ª

    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;//sçš„nextæŒ‡å‘åŸæœ¬é“¾è¡¨çš„ç¬¬ä¸€ä¸ªç»“ç‚¹
        L->next = s;//å¤´ç»“ç‚¹çš„nextï¼ŒæŒ‡å‘æ–°ç»“ç‚¹
        scanf("%d", &x);
    }

}

void PrintList(LinkList L) {
    L = L->next;
    while (L != NULL) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n");
}
//å¤´æ’æ³•æ¥æ–°å»ºé“¾è¡¨
int main() {
    LinkList L; //Læ˜¯é“¾è¡¨å¤´æŒ‡é’ˆï¼Œæ˜¯ç»“æ„ä½“æŒ‡é’ˆç±»å‹
    ListHeadInsert(L);//è¾“å…¥æ•°æ®å¯ä»¥ä¸º3 4 5 6 7 9999,å¤´æ’æ³•æ–°å»ºé“¾è¡¨
    PrintList(L);//é“¾è¡¨æ‰“å°
    return 0;
}
```

![image-20230822210832944](/Users/yuebinghui/Documents/program/github/note/images/image-20230822210832944.png)

##### å°¾æ’æ³•

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void ListHeadInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
//    L->next = NULL; // âš ï¸è¿™ä¸ªå¥½åƒå¯æœ‰å¯æ— 
    int x;
    scanf("%d", &x);
    LNode *s, *r = L; // sæ˜¯ç”¨æ¥æŒ‡å‘ç”³è¯·çš„æ–°èŠ‚ç‚¹ï¼Œrå§‹ç»ˆæŒ‡å‘é“¾è¡¨çš„å°¾éƒ¨
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode)); // ä¸ºæ–°èŠ‚ç‚¹ç”³è¯·ç©ºé—´
        s->data = x;
        r->next = s; // ç»™å°¾èŠ‚ç‚¹çš„nextå±æ€§èµ‹å€¼ æ–°èŠ‚ç‚¹åœ°å€
        r = s;//ræŒ‡å‘æ–°çš„å°¾éƒ¨
        scanf("%d", &x);
    }
    r->next = NULL; // è®©å°¾èŠ‚ç‚¹çš„nextä¸ºNULL
}

void PrintList(LinkList L) {
    L = L->next;
    while (L != NULL) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n");
}

int main() {
    LinkList L;
    ListHeadInsert(L);
    PrintList(L);
    return 0;
}
```

![image-20230823165306926](/Users/yuebinghui/Documents/program/github/note/images/image-20230823165306926.png)

###### æŒ‰å€¼æŸ¥æ‰¾ LocateElem

###### æŒ‰ä½æŸ¥æ‰¾ GetElem

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void ListHeadInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
//    L->next = NULL; // âš ï¸è¿™ä¸ªå¥½åƒå¯æœ‰å¯æ— 
    int x;
    scanf("%d", &x);
    LNode *s, *r = L; // sæ˜¯ç”¨æ¥æŒ‡å‘ç”³è¯·çš„æ–°èŠ‚ç‚¹ï¼Œrå§‹ç»ˆæŒ‡å‘é“¾è¡¨çš„å°¾éƒ¨
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode)); // ä¸ºæ–°èŠ‚ç‚¹ç”³è¯·ç©ºé—´
        s->data = x;
        r->next = s; // ç»™å°¾èŠ‚ç‚¹çš„nextå±æ€§èµ‹å€¼ æ–°èŠ‚ç‚¹åœ°å€
        r = s;//ræŒ‡å‘æ–°çš„å°¾éƒ¨
        scanf("%d", &x);
    }
    r->next = NULL; // è®©å°¾èŠ‚ç‚¹çš„nextä¸ºNULL
}

void PrintList(LinkList L) {
    L = L->next;
    while (L != NULL) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n");
}

// æŒ‰ä½æŸ¥æ‰¾
LNode *GetElem(LinkList L, int SearchPos) {
    if (SearchPos < 0) {
        return NULL;
    }
    int i = 0;
    while (L && i < SearchPos) {
        L = L->next;
        i++;
    }
    return L;
}

// æŒ‰å€¼æŸ¥æ‰¾
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}

int main() {
    LinkList L;
    ListHeadInsert(L);
    PrintList(L);
    LNode *p = GetElem(L, 2);
    p = LocateElem(L, 999);
    if (p != NULL) {
        printf("%d", p->data);
    }
    return 0;
}
```

###### æ’å…¥å•ä¸ªå…ƒç´ æ“ä½œ ListHeadInsert

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void ListHeadInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
//    L->next = NULL; // âš ï¸è¿™ä¸ªå¥½åƒå¯æœ‰å¯æ— 
    int x;
    scanf("%d", &x);
    LNode *s, *r = L; // sæ˜¯ç”¨æ¥æŒ‡å‘ç”³è¯·çš„æ–°èŠ‚ç‚¹ï¼Œrå§‹ç»ˆæŒ‡å‘é“¾è¡¨çš„å°¾éƒ¨
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode)); // ä¸ºæ–°èŠ‚ç‚¹ç”³è¯·ç©ºé—´
        s->data = x;
        r->next = s; // ç»™å°¾èŠ‚ç‚¹çš„nextå±æ€§èµ‹å€¼ æ–°èŠ‚ç‚¹åœ°å€
        r = s;//ræŒ‡å‘æ–°çš„å°¾éƒ¨
        scanf("%d", &x);
    }
    r->next = NULL; // è®©å°¾èŠ‚ç‚¹çš„nextä¸ºNULL
}

void PrintList(LinkList L) {
    L = L->next;
    while (L != NULL) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n");
}

// æŒ‰ä½æŸ¥æ‰¾
LNode *GetElem(LinkList L, int SearchPos) {
    if (SearchPos < 0) {
        return NULL;
    }
    int i = 0;
    while (L && i < SearchPos) {
        L = L->next;
        i++;
    }
    return L;
}


// æŒ‰å€¼æŸ¥æ‰¾
LNode *LocateElem(LinkList L, int element) {
    while (L) { // å’ŒL !== NULLä¸€è‡´çš„ï¼Œå¯“æ„å°±æ˜¯åªè¦ä¸ºçœŸå°±ä¸€ç›´å¾ªç¯
        if (L->data == element) {
            return L;
        }
        L = L->next;
    }
    return NULL;
}
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}

// é“¾è¡¨ä¸­æ’å…¥å…ƒç´ 
bool ListFrontInsert(LinkList &L, int pos, int InsertVal) {
    LNode *p = GetElem(L, pos - 1);
    // å®¹é”™
    if (p == NULL) {
        return false;
    }
    LNode *q;
    q = (LNode *) malloc(sizeof(LNode));
    q->data = InsertVal;
    q->next = p->next;
    p->next = q;
    return true;
}

int main() {
    LinkList L;
    ListHeadInsert(L);
//    LNode *p = GetElem(L, 2);
//    p = LocateElem(L, 999);
//    if (p != NULL) {
//        printf("%d", p->data);
//    }
    ListFrontInsert(L, 4, 99);
    PrintList(L);
    return 0;
}
```

###### åˆ é™¤å…ƒç´ æ“ä½œ ListDelete

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

LNode *GetElem(LinkList L, int SearchPos);

void ListHeadFrontInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    L->next = NULL;

    int x;
    scanf("%d", &x);

    LNode *s;
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = x;
        s->next = L->next;
        L->next = s;
        scanf("%d", &x);
    }
}

void ListHeadTailInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    L->next = NULL;

    LNode *s, *r = L;
    int x;
    scanf("%d", &x);

    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL;
}

void PrintList(LinkList L) {
    L = L->next;
    while (L) {
        printf("%d", L->data);
        L = L->next;
        if (L) {
            printf(" ");
        }
    }
    printf("\n");
}

// åˆ é™¤ç¬¬iä¸ªä½ç½®çš„å…ƒç´ 
// åˆ é™¤æ—¶Læ˜¯ä¸ä¼šå˜å¾—ï¼Œæ‰€ä»¥ä¸éœ€è¦åŠ å¼•ç”¨
bool ListDelete(LinkList L, int i) {
    LNode *p = GetElem(L, i - 1); // æ‹¿åˆ°è¦åˆ é™¤çš„å‰ä¸€ä¸ªèŠ‚ç‚¹
    if (NULL == p) { // å®¹é”™
        return false;
    }
//    LNode *q = GetElem(L, i);
    LNode *q = p->next; // è¿™ä¸ªå’ŒğŸ‘†é‚£å¥è¯ç­‰åŒï¼Œä½†è¿˜æ˜¯è¿™å¥å¥½ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥æ‹¿åˆ°ä¸‹ä¸€ä¸ªèŠ‚ç‚¹äº†
     if (!q) {
        return false;
    }
    p->next = q->next;
    free(q);
    return true;
}

LNode *GetElem(LinkList L, int SearchPos) {
    if (SearchPos < 0) {
        return NULL;
    }
    int i = 0;
    while (L && i < SearchPos) {
        L = L->next;
        i++;
    }
    return L;
}

LNode *LocateElem(LinkList L, int element) {
    while (L) {
        if (L->data == element) {
            return L;
        }
        L = L->next;
    }
    return NULL;
}
LNode *LocateElem(LinkList L, ElemType e) {
    LNode *p = L->next;
    while (p && p->data != e) {
        p = p->next;
    }
    return p;
}

int main() {
    LinkList L;
//    ListHeadFrontInsert(L);
    ListHeadTailInsert(L);
    int p;
    ListDelete(L, 2);
//    LNode *p = LocateElem(L, 99);
//    LNode *p = GetElem(L, 4);

//    printf("%d\n", p);
    PrintList(L);
    return 0;

}
```

##### é“¾è¡¨çœŸé¢˜

![image-20230825080530827](/Users/yuebinghui/Documents/program/github/note/images/image-20230825080530827.png)

```c++
#include <stdio.h>
#include <stdlib.h>

typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;

void ListTailInsert(LinkList &L) {
    L = (LNode *) malloc(sizeof(LNode));
    L->next = NULL;
    int x;
    scanf("%d", &x);
    LNode *s, *r = L;
    while (x != 9999) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = x;
        r->next = s;
        r = s;
        scanf("%d", &x);
    }
    r->next = NULL;
}

void PrintList(LinkList L) {
    L = L->next;
    while (L) {
        printf("%3d", L->data);
        L = L->next;
    }
    printf("\n"); 
}

// æ‰¾é“¾è¡¨ä¸­é—´èŠ‚ç‚¹ï¼Œå¹¶è®¾ç½®å¥½L2é“¾è¡¨
void findMiddleNode(LinkList L, LinkList &L2) { // Lè¿™é‡Œä¸éœ€è¦å¼•ç”¨æ˜¯å› ä¸ºä¸éœ€è¦æ”¹å˜L
    L2 = (LNode *) malloc(sizeof(LNode));
    LNode *ppre, *pcur;
    ppre = pcur = L->next;

    while (pcur) {
        pcur = pcur->next;
        if (NULL == pcur) { // ä¸ºäº†é˜²æ­¢pcurä¸ºNULLï¼Œè¿è¡ŒNULL->nextç¨‹åºå´©æºƒ
            break;
        }
        pcur = pcur->next;
        if (NULL == pcur) {
            break;
        }
        // ä¸ºäº†ä½¿å¾—å¶æ•°ä¸ªï¼Œæ¯”å¦‚a1~a6ä¸­ï¼ŒæŒ‡å‘a3è€Œä¸æ˜¯a4èŠ‚ç‚¹ï¼ŒåŠ äº†ä¸Šé¢çš„åˆ¤æ–­
        // å› ä¸ºè™½ç„¶æ­¤æ—¶pcurå·²ç»ä¸ºNULLäº†ï¼Œä½†æ˜¯ä¸‹é¢çš„ä¸€è¡Œä»£ç è¿˜æ˜¯ä¼šæ‰§è¡Œï¼Œæ‰€ä»¥ä¸Šé¢breakæ‰äº†
        ppre = ppre->next;
    };
    L2->next = ppre->next; // è¿™é‡Œæ”¾å…¥ppreä¼šæœ‰é—®é¢˜ï¼Œåªæœ‰ä¸€ä¸ªå€¼ï¼Œæ”¾å…¥ppre->nextæ‰åˆå…¨éƒ¨çš„å€¼
    // åº”è¯¥å¯èƒ½æ˜¯å› ä¸ºå¦‚æœæ”¾ppreç›¸å½“äºæ”¾äº†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè€Œæ”¾ppre->nextï¼Œç›¸å½“äºæ”¾äº†æŒ‡é’ˆï¼Œç„¶åå°±ä¸²èµ·æ¥äº†
  // æ”¾éƒ½éƒ½æ˜¯ç»“ç‚¹ï¼Œæ˜¯ä¸è¿‡ä¸‹é¢è¿™è¡Œppre->next=NULLæŠŠåé¢çš„nextç»™åˆ‡æ–­äº†ï¼Œæ‰€ä»¥ä½ åªæœ‰ä¸€ä¸ªç»“ç‚¹
  // æ­£å¸¸ä½ å°±æ˜¯è¦æ‹¿ppre->nexté‡Œé¢çš„æŒ‡é’ˆç»“ç‚¹å‘¢
    ppre->next = NULL;
}

void reverse(LinkList L2) {
    LNode *r, *s, *t;
    r = L2->next; // æŒ‡å‘ç¬¬ä¸€ä¸ªæŒ‡é’ˆ
    if (NULL == r) { // åˆ¤æ–­ç¬¬ä¸€ä¸ªæ˜¯å¦ä¸ºç©ºï¼Œç©ºè¿”å›NULL
        return;
    }
    s = r->next;
    if (NULL == s) { // åˆ¤æ–­ç¬¬äºŒä¸ªæ˜¯å¦ä¸ºç©ºï¼Œç©ºè¿”å›NULL
        return;
    }
    t = s->next;
    while (t) {
        s->next = r;

        r = s;
        s = t;
        t = t->next;
    }
    s->next = r;
    L2->next->next = NULL;
    L2->next = s;
}

void merge(LinkList L, LinkList L2) {
    LNode *pcur, *p, *q;
    pcur = L->next; // è¿™ç›¸å½“äºé‡ç»„åçš„æ–°é“¾è¡¨çš„æŒ‡é’ˆ
    p = pcur->next; // æŒ‡å‘Lç¬¬äºŒä¸ªèŠ‚ç‚¹
    q = L2->next;// æŒ‡å‘L1ç¬¬ä¸€ä¸ªèŠ‚ç‚¹

    while (NULL != q && NULL != p) {
        pcur->next = q;//é¦–å…ˆæŠŠL2é‡Œçš„ç¬¬ä¸€é¡¹æ’åˆ°äº†æ–°é“¾è¡¨çš„ç¬¬äºŒä¸ªä½ç½®
        q = q->next; // ç„¶åæŠŠL2çš„qæŒ‡é’ˆåç§»

        pcur = pcur->next;//æŠŠæ–°é“¾è¡¨çš„æŒ‡é’ˆæŒ‡å‘æ–°æ’å…¥çš„é‚£ä¸ªèŠ‚ç‚¹,pcuræ°¸è¿œæŒ‡å‘æœ€åä¸€ä¸ªèŠ‚ç‚¹

        pcur->next = p;// æŠŠæ–°æ’å…¥çš„èŠ‚ç‚¹å’ŒLçš„ç¬¬äºŒä¸ªèŠ‚ç‚¹è¿èµ·æ¥
        p = p->next;// ç„¶åæŠŠLçš„pæŒ‡é’ˆåç§»

        pcur = pcur->next;//æŠŠæ–°é“¾è¡¨çš„æŒ‡é’ˆæŒ‡å‘æ–°æ’å…¥çš„é‚£ä¸ªèŠ‚ç‚¹,pcuræ°¸è¿œæŒ‡å‘æœ€åä¸€ä¸ªèŠ‚ç‚¹

    }
    if (NULL != q) {
        pcur->next = q;
    }
    if (NULL != p) {
        pcur->next = p;
    }
    free(L2);
}

int main() {
    LinkList L;
    ListTailInsert(L);
    PrintList(L);
    printf("--------------- ListTailInsert ğŸ‘†\n");
    LinkList L2 = NULL;
    findMiddleNode(L, L2);
    PrintList(L);
    PrintList(L2);
    printf("--------------- findMiddleNode ğŸ‘†\n");
    reverse(L2);
    PrintList(L);
    PrintList(L2);
    printf("--------------- reverse ğŸ‘†\n");
    merge(L, L2);
    PrintList(L);

    return 0;
}
```

![image-20230825080522605](/Users/yuebinghui/Documents/program/github/note/images/image-20230825080522605.png)

![image-20230825145943579](/Users/yuebinghui/Documents/program/github/note/images/image-20230825145943579.png)

![image-20230825145948516](/Users/yuebinghui/Documents/program/github/note/images/image-20230825145948516.png)

![image-20230825153755790](/Users/yuebinghui/Documents/program/github/note/images/image-20230825153755790.png)

![image-20230825153412501](/Users/yuebinghui/Documents/program/github/note/images/image-20230825153412501.png)

<video src="/Users/yuebinghui/Documents/picture/å±å¹•å½•åˆ¶2023-08-25 15.28.09.mov"></video>

ç¬¬10ç§’é‚£é‡Œæ˜¯é”™çš„ï¼Œä¸éœ€è¦è·³åˆ°5çš„ä¸Šé¢ï¼Œè€Œæ˜¯ ç›´æ¥åˆ°äº†6çš„ä¸Šé¢

åˆ°15ç§’é‚£é‡Œèµ°å®Œäº†ä¸€æ¬¡å¾ªç¯ï¼Œç„¶åå°±æ˜¯å¾ªç¯å¾€å¤ç›´åˆ°å¾ªç¯ç»“æŸ  

## æ ˆ

æˆ‘ä»¬å¯ä»¥ç”¨æ•°ç»„å®ç°æ ˆ,ä¹Ÿå¯ä»¥ç”¨é“¾è¡¨å®ç°æ ˆ,å¦‚æœç”¨å•é“¾è¡¨å®ç°æ ˆï¼Œå®ç°æ–¹æ³•æ˜¯é“¾è¡¨çš„å¤´æ’æ³•ï¼Œå…¥æ ˆæ—¶ä»é“¾è¡¨å¤´éƒ¨æ’å…¥ï¼Œå‡ºæ ˆæ—¶ä»é“¾è¡¨å¤´éƒ¨åˆ é™¤

```c++
/*
    æ ˆï¼šåè¿›å…ˆå‡º/å…ˆè¿›åå‡º
    æ ˆé¡¶
    å…¥æ ˆï¼šä»æ ˆé¡¶æ·»åŠ ä¸€ä¸ªå…ƒç´ 
    å‡ºæ ˆï¼šä»æ ˆé¡¶åˆ é™¤ä¸€ä¸ªå…ƒç´ 
    æ ˆæ˜¯ä¸€ä¸ªç»“æ„ä½“

    s.top = MaxSize-1 å’Œæ•°ç»„ç´¢å¼•ä¸€è‡´
    æ ˆä¸ºç©ºs.top=-1
 */

// é“¾æ ˆå‡ ä¹ä¸è€ƒ

#include <stdio.h>

#define MaxSize 50
#define ElemType int

typedef struct {
    ElemType data[MaxSize];
    int top;
} SqStack;

// InitStack åˆå§‹åŒ–æ ˆ
void InitStack(SqStack &S) {
    S.top = -1;//åˆå§‹åŒ–æ ˆï¼Œå°±æ˜¯S.top=-1,è®©æ ˆä¸ºç©º
}

// StackEmpty æ ˆæ˜¯å¦ä¸ºç©º
bool StackEmpty(SqStack S) {
    if (-1 == S.top) {
        return true;
    } else {
        return false;
    }
}

// Push å‹æ ˆ
bool Push(SqStack &S, ElemType x) {
    //åˆ¤æ–­æ ˆæ˜¯å¦æ»¡äº†
    if (S.top == MaxSize - 1) {
        return false;
    }
    S.data[++S.top] = x;//ç­‰ä»·äºS.top=S.top+1;   S.data[S.top]=x;
    return true;
}

//è·å–æ ˆé¡¶å…ƒç´ 
bool GetTop(SqStack S, ElemType &m) {
    if (StackEmpty(S)) {
        return false;
    }
    m = S.data[S.top];//æ‹¿æ ˆé¡¶å…ƒç´ 
    return true;
}

// Pop å¼¹æ ˆ
bool Pop(SqStack &S, ElemType &m) {
    if (StackEmpty(S)) {
        return false;
    }
    m = S.data[S.top--];//å‡ºæ ˆ åå‡å‡ç­‰ä»·äº å…ˆm=S.data[S.top];S.top=S.top-1;
    return true;
}


int main() {
    SqStack S;
    InitStack(S);
    bool flag;
    flag = StackEmpty(S);
    if (flag) {
        printf("stack is empty\n");
    }
    Push(S, 3);//å…¥æ ˆå…ƒç´ 3
    Push(S, 4);//å…¥æ ˆå…ƒç´ 4
    Push(S, 5);
    ElemType m;
    flag = GetTop(S, m);//è·å–æ ˆé¡¶å…ƒç´ 
    if (flag) {
        printf("get top %d\n", m);
    }
    flag = Pop(S, m);//å¼¹å‡ºæ ˆé¡¶å…ƒç´ 
    if (flag) {
        printf("pop element %d\n", m);
    }
    // è™½ç„¶ç»“æœéƒ½æ˜¯5,ä½†æ˜¯æ ˆæ˜¯æ ¹æ®topæ¥çš„ï¼Œè€Œä¸æ˜¯æ ¹æ®æ•°ç»„é‡Œçš„æ•°æ®
    return 0;

}
```

## é˜Ÿåˆ— Queue

å­˜å‚¨MaxSize - 1 ä¸ªå…ƒç´ 

å—é™çš„çº¿æ€§è¡¨

å…¥é˜Ÿï¼šæ’å…¥å…ƒç´ 

å‡ºé˜Ÿï¼šåˆ é™¤å…ƒç´ 

é˜Ÿå¤´ï¼šFront

é˜Ÿå°¾ï¼šRear

FIFO

å…ˆè¿›å…ˆå‡º

#### å¾ªç¯é˜Ÿåˆ—

å…¥é˜Ÿä¸€ä¸ªå…ƒç´ rear+1ï¼Œå‡ºé˜Ÿä¸€ä¸ªå…ƒç´ front+1

å…³é”®å­—ï¼šé‡å¤ä½¿ç”¨

å¾ªç¯é˜Ÿåˆ—ï¼šå¾ªç¯é˜Ÿåˆ—MaxSizeæ˜¯5ï¼Œä½†æ˜¯åªå¯ä»¥å­˜4ä¸ªå…ƒç´ 

![image-20231120173445918](/Users/yuebinghui/Documents/program/github/note/images/image-20231120173445918.png)

##### æ•°ç»„å®ç°

```c++
#include <stdio.h>

#define MaxSize 5
typedef int ElemType;
typedef struct {
    ElemType data[MaxSize];
    int front, rear;
} SqQueue;

void InitQueue(SqQueue &S) {
    S.front = S.rear = 0;
}

bool QueueEmpty(SqQueue S) {
    return S.front == S.rear;
}

bool DeQueue(SqQueue &S, int &DeleteVal) {
    // å¦‚æœä¸¤ä¸ªå¤´å°¾æ ‡è®°ç›¸ç­‰è®¤ä¸ºç©ºäº†ï¼Œfalseæ‰
    if (QueueEmpty(S)) {
        return false;
    }
    // âš ï¸ ä»å¤´å¼€å§‹å‡ºé˜Ÿ
    DeleteVal = S.data[S.front]; // å‡ºé˜Ÿå½“å‡ºåˆ°è¿™é‡ŒS.front =3æ—¶ï¼Œè¯´æ˜å‡ºå®Œäº†
    // æ‰§è¡Œä¸‹é¢å°±æ˜¯4äº†ï¼Œç„¶åå°±è¿›ä¸äº†è¿™ä¸ªå‡½æ•°äº†ï¼Œå› ä¸ºå¤´å°¾æ ‡è®°ç›¸ç­‰äº†
    S.front = (S.front + 1) % MaxSize;
    return true;
}

bool EnQueue(SqQueue &S, ElemType val) {
    //âš ï¸ æ¨¡è¿ç®—æ˜¯é«˜äºåŠ å‡çš„ï¼Œæ‰€ä»¥éœ€è¦åŠ æ‹¬å·
    // å½“èµ°åˆ°ç¬¬4ä¸ªçš„æ—¶å€™ï¼Œå†æ¬¡è°ƒç”¨ï¼Œ(4+1)%MaxSize == 0 ç„¶åå°±falseæ‰äº†ï¼Œæ‰€ä»¥åªå¯ä»¥åŠ å››ä¸ª
    if ((S.rear + 1) % MaxSize == S.front) {
        return false;
    }
    // åƒæ•°ç»„ä¸€æ ·ï¼Œä»0å¼€å§‹æ·»åŠ å…ƒç´ 
    S.data[S.rear] = val;
    S.rear = (S.rear + 1) % MaxSize;
    return true;
}


int main() {
    SqQueue S;
    InitQueue(S);
    bool ret1 = QueueEmpty(S);
    EnQueue(S, 1);
    EnQueue(S, 2);
    EnQueue(S, 3);
    EnQueue(S, 4);
    bool ret2 = EnQueue(S, 5);
    int val;
    DeQueue(S, val);
    DeQueue(S, val);
    DeQueue(S, val);
    DeQueue(S, val);


    return 0;
}
```

#### é“¾å¼é˜Ÿåˆ—

```c++
#include <stdio.h>
#include <stdlib.h>

// ç”¨é“¾è¡¨å®ç°é˜Ÿåˆ—
typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode;

typedef struct {
    LNode *front, *rear; //é˜Ÿå¤´ é˜Ÿå°¾
} LQueue;

void InitQueue(LQueue &L) {
    L.front = L.rear = (LNode *) malloc(sizeof(LNode));
    L.front->next = NULL;
}

// å…¥é˜Ÿ
void EnQueue(LQueue &L, ElemType val) {
    LNode *p = (LNode *) malloc(sizeof(LNode));
    p->data = val;
    p->next = NULL; // è¦è®©nextä¸ºNULL
    L.rear->next = p; //å°¾æŒ‡é’ˆçš„nextæŒ‡å‘æ–°ç”³è¯·çš„ç©ºé—´ï¼Œå› ä¸ºä»å°¾éƒ¨å…¥é˜Ÿ
    L.rear = p; // rearæŒ‡å‘æœ€æ–°çš„å°¾éƒ¨
}

bool DeQueue(LQueue &L, int &DeleteVal) {
    // åªå‰©ä¸‹ä¸€ä¸ªè¡¨å¤´äº†å°±ä¸åˆ äº†
    if (L.front == L.rear) { // é˜Ÿåˆ—ä¸ºç©º
        return false;
    }
    LNode *p = L.front->next; // æ‹¿åˆ°ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå­˜å…¥p
    DeleteVal = p->data; // è·å–è¦å‡ºé˜Ÿçš„å…ƒç´ å€¼
    L.front->next = p->next; // è®©pæ–­é“¾
    if (p == L.rear) { // åˆ¤æ–­é“¾è¡¨é‡Œæ˜¯å¦åªå‰©ä¸‹æœ€åä¸€ä¸ªèŠ‚ç‚¹äº† å› ä¸ºL.rearå§‹ç»ˆæ˜¯æŒ‡å‘æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„ å¦‚æœä¸ºçœŸï¼Œè¯´æ˜åªæœ‰ä¸€ä¸ªäº†
        L.rear = L.front;
    }
    free(p);
    return true;
}


int main() {
    LQueue L;
    InitQueue(L);
    EnQueue(L, 1);
    EnQueue(L, 2);
    EnQueue(L, 3);
    EnQueue(L, 4);
    EnQueue(L, 5);

    int val;
    DeQueue(L, val);
    DeQueue(L, val);
    DeQueue(L, val);
    DeQueue(L, val);
    return 0;
}
```

##### é“¾å¼å¾ªç¯é˜Ÿåˆ—çœŸé¢˜

![image-20230827171445027](/Users/yuebinghui/Documents/program/github/note/images/image-20230827171445027.png)

<video src="/Users/yuebinghui/Documents/picture/å¾ªç¯é˜Ÿåˆ—é“¾è¡¨çš„çœŸé¢˜.mov"></video>

```c++
#include <stdio.h>
#include <stdlib.h>

typedef int ElemType;
typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

void CircleLinkQueue(LinkList &front, LinkList &rear) {
    front = (LinkList) malloc(sizeof(LNode));
    rear = front;
    rear->next = front;
}

void EnQueue(LinkList front, LinkList &rear, ElemType InsertVal) {
    LNode *p;
    if (front == rear->next) { // æ»¡äº†ï¼Œéœ€è¦ç”³è¯·æ–°ç©ºé—´
        rear->data = InsertVal;
        p = (LNode *) malloc(sizeof(LNode));
        rear->next = p;
        p->next = front;
        rear = p;
    } else {
        rear->data = InsertVal;
        rear = rear->next;
    }
}

bool DeQueue(LinkList &front, LinkList rear, ElemType &DeleteVal) {
    if (front == rear) {
        return false;
    }
    DeleteVal = front->data;
    front = front->next;
    return true;
}

int main() {
    LinkList front, rear;
    CircleLinkQueue(front, rear);

    EnQueue(front, rear, 11);
    EnQueue(front, rear, 22);
    EnQueue(front, rear, 33);
    EnQueue(front, rear, 44);
    EnQueue(front, rear, 55);

    int val;
    DeQueue(front, rear, val);
    DeQueue(front, rear, val);
    DeQueue(front, rear, val);
    DeQueue(front, rear, val);
    bool a = DeQueue(front, rear, val);
    bool b = DeQueue(front, rear, val);


    return 0;
}
```

## æ ‘

#### äºŒå‰æ ‘ğŸŒŸğŸŒŸ

##### äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨

![image-20230828075514074](/Users/yuebinghui/Documents/program/github/note/images/image-20230828075514074.png)

![image-20230828075525620](/Users/yuebinghui/Documents/program/github/note/images/image-20230828075525620.png)

![image-20230828075532898](/Users/yuebinghui/Documents/program/github/note/images/image-20230828075532898.png)

##### äºŒå‰æ ‘å±‚æ¬¡å»ºæ ‘å®æˆ˜

<video src="/Users/yuebinghui/Documents/picture/äºŒå‰æ ‘å±‚æ¬¡å»ºæ ‘.mov"></video>



![image-20230829162048247](/Users/yuebinghui/Documents/program/github/note/images/image-20230829162048247.png)

##### å‰åºéå†ï¼ˆæ·±åº¦ä¼˜å…ˆéå†ï¼‰

##### ä¸­åºéå†

##### ååºéå†

<video src="/Users/yuebinghui/Documents/picture/å‰åºåç»­ä¸­åºéå†.mov"></video>

![image-20230829172928686](/Users/yuebinghui/Documents/program/github/note/images/image-20230829172928686.png)

```c++
// function.h å®šä¹‰ç»“æ„ä½“ï¼Œå¤´æ–‡ä»¶

#ifndef UNTITLED_FUNCTION_H
#define UNTITLED_FUNCTION_H

#endif //UNTITLED_FUNCTION_H

#include <stdio.h>
#include <stdlib.h>

typedef char BiTElemType;
typedef struct BiTNode {
    BiTElemType c;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

typedef struct LQueueNode {
    BiTree p;
    struct LQueueNode *next;
} LQueueNode, *LQueue;


```

```c++
// main.c
#include "function.h"

// å‰åºéå†
void PreOrder(BiTree t) {
    if (NULL != t) {
        printf("%c", t->c);
        PreOrder(t->lchild);
        PreOrder(t->rchild);
    }
}

// ä¸­åºéå†
void InOrder(BiTree t) {
    if (NULL != t) {
        InOrder(t->lchild);
        printf("%c", t->c);
        InOrder(t->rchild);
    }
}

// ååºéå†
void PostOrder(BiTree t) {
    if (NULL != t) {
        PostOrder(t->lchild);
        PostOrder(t->rchild);
        printf("%c", t->c);
    }
}

int main() {
    BiTree pnew;//ç”¨æ¥æŒ‡å‘æ–°ç”³è¯·çš„æ ‘ç»“ç‚¹
    BiTree tree = NULL;//treeæ˜¯æŒ‡å‘æ ‘æ ¹çš„ï¼Œä»£è¡¨æ ‘
    char c;
    LQueue phead = NULL, ptail = NULL, listpnew = NULL, pcur;
    while (scanf("%c", &c)) {
        if (c == '\n') {
            break;//è¯»å–åˆ°æ¢è¡Œå°±ç»“æŸ
        }
        //callocç”³è¯·çš„ç©ºé—´å¤§å°æ˜¯ä¸¤ä¸ªå‚æ•°ç›´æ¥ç›¸ä¹˜ï¼Œå¹¶å¯¹ç©ºé—´è¿›è¡Œåˆå§‹åŒ–ï¼Œèµ‹å€¼ä¸º0
        pnew = (BiTree) calloc(1, sizeof(BiTNode));
        pnew->c = c;
        listpnew = (LQueue) calloc(1, sizeof(LQueueNode));//ç»™é˜Ÿåˆ—ç»“ç‚¹ç”³è¯·ç©ºé—´
        listpnew->p = pnew;
        //å¦‚æœæ˜¯æ ‘çš„ç¬¬ä¸€ä¸ªç»“ç‚¹
        if (NULL == tree) {
            tree = pnew;//treeæŒ‡å‘æ ‘çš„æ ¹ç»“ç‚¹
            phead = listpnew;//ç¬¬ä¸€ä¸ªç»“ç‚¹å³æ˜¯é˜Ÿåˆ—å¤´ï¼Œä¹Ÿæ˜¯é˜Ÿåˆ—å°¾
            ptail = listpnew;
            pcur = listpnew;//pcurè¦æŒ‡å‘è¦è¿›å…¥æ ‘çš„çˆ¶äº²å…ƒç´ 
        } else {
            //è®©å…ƒç´ å…ˆå…¥é˜Ÿåˆ—
            ptail->next = listpnew;
            ptail = listpnew;
            //æ¥ä¸‹æ¥æŠŠç»“ç‚¹æ”¾å…¥æ ‘ä¸­
            if (NULL == pcur->p->lchild) {
                pcur->p->lchild = pnew;//pcur->på·¦å­©å­ä¸ºç©ºï¼Œå°±æ”¾å…¥å·¦å­©å­
            } else if (NULL == pcur->p->rchild) {
                pcur->p->rchild = pnew;//pcur->på³å­©å­ä¸ºç©ºï¼Œå°±æ”¾å…¥å³å­©å­
                pcur = pcur->next;//å½“å‰ç»“ç‚¹å·¦å³å­©å­éƒ½æœ‰äº†ï¼Œpcurå°±æŒ‡å‘ä¸‹ä¸€ä¸ª
            }
        }
    }

    //abcdefghij
    // å‰åºéå†
    PreOrder(tree);
    printf("---------\n");
    // ä¸­åºéå†
    InOrder(tree);
    printf("---------\n");
    // ååºéå†
    PostOrder(tree);
    printf("---------\n");
    return 0;
}

```

##### å±‚æ¬¡éå†ï¼ˆå¹¿åº¦ä¼˜å…ˆéå†ï¼‰

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231121175044068.png)

```c++
// å¤´æ–‡ä»¶
#ifndef INC_1_TREE_FUNCTION_H
#define INC_1_TREE_FUNCTION_H
#include <stdio.h>
#include <stdlib.h>

typedef char BiElemType;
typedef struct BiTNode{
    BiElemType c;//cå°±æ˜¯ä¹¦ç±ä¸Šçš„data
    struct BiTNode *lchild;
    struct BiTNode *rchild;
}BiTNode,*BiTree;

//tagç»“æ„ä½“æ˜¯è¾…åŠ©é˜Ÿåˆ—ä½¿ç”¨çš„
typedef struct tag{
    BiTree p;//æ ‘çš„æŸä¸€ä¸ªç»“ç‚¹çš„åœ°å€å€¼
    struct tag *pnext;
}tag_t,*ptag_t;

//é˜Ÿåˆ—çš„ç»“æ„ä½“ ï¼ï¼ï¼è¿™é‡Œé˜Ÿåˆ—çš„ç»“æ„ä½“å’Œtagç»“æ„ä½“éƒ½æ˜¯é˜Ÿåˆ—ï¼Œå…¶å®å¯ä»¥å¹¶ç”¨çš„
typedef BiTree ElemType;
typedef struct LinkNode{
    ElemType data;
    struct LinkNode *next;
}LinkNode;
typedef struct{
    LinkNode *front,*rear;//é“¾è¡¨å¤´ é“¾è¡¨å°¾,ä¹Ÿå¯ä»¥ç§°ä¸ºé˜Ÿå¤´ï¼Œé˜Ÿå°¾
}LinkQueue;//å…ˆè¿›å…ˆå‡º
void InitQueue(LinkQueue &Q);
bool IsEmpty(LinkQueue Q);
void EnQueue(LinkQueue &Q,ElemType x);
bool DeQueue(LinkQueue &Q,ElemType &x);

#endif //INC_1_TREE_FUNCTION_H

```

```c++
//
// queue.cpp æ–‡ä»¶ é˜Ÿåˆ—
//
#include "function.h"

//é˜Ÿåˆ—çš„åˆå§‹åŒ–ï¼Œä½¿ç”¨çš„æ˜¯å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨æ¥å®ç°çš„
void InitQueue(LinkQueue &Q)
{
    Q.front=Q.rear=(LinkNode*)malloc(sizeof(LinkNode));
    Q.front->next=NULL;
}
//åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
bool IsEmpty(LinkQueue Q)
{
    return Q.rear==Q.front;
}
//å…¥é˜Ÿ
void EnQueue(LinkQueue &Q,ElemType x)
{
    LinkNode *pnew=(LinkNode*)malloc(sizeof(LinkNode));
    pnew->data=x;
    pnew->next=NULL;//è¦è®©nextä¸ºNULL
    Q.rear->next=pnew;//å°¾æŒ‡é’ˆçš„nextæŒ‡å‘pnewï¼Œå› ä¸ºä»å°¾éƒ¨å…¥é˜Ÿ
    Q.rear=pnew;//rearè¦æŒ‡å‘æ–°çš„å°¾éƒ¨
}
//å‡ºé˜Ÿ
bool DeQueue(LinkQueue &Q,ElemType &x)
{
    if(Q.rear==Q.front)//é˜Ÿåˆ—ä¸ºç©º
    {
        return false;
    }
    LinkNode* q=Q.front->next;//æ‹¿åˆ°ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œå­˜å…¥q
    x=q->data;//è·å–è¦å‡ºé˜Ÿçš„å…ƒç´ å€¼
    Q.front->next=q->next;//è®©ä¸€ä¸ªç»“ç‚¹æ–­é“¾
    if(Q.rear==q)//é“¾è¡¨åªå‰©ä½™ä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œè¢«åˆ é™¤åï¼Œè¦æ”¹å˜rear
    {
        Q.rear=Q.front;
    }
    free(q);
    return true;
}

```

```c++
#include "function.h"

//å‰åºéå†ï¼Œä¹Ÿå«å…ˆåºéå†ï¼Œä¹Ÿæ˜¯æ·±åº¦ä¼˜å…ˆéå†
void PreOrder(BiTree p)
{
    if(p!=NULL)
    {
        printf("%c", p->c);
        PreOrder(p->lchild);//æ‰“å°å·¦å­æ ‘
        PreOrder(p->rchild);//æ‰“å°å³å­æ ‘
    }
}
//ä¸­åºéå†
void InOrder(BiTree p)
{
    if(p!=NULL)
    {
        InOrder(p->lchild);//æ‰“å°å·¦å­æ ‘
        printf("%c", p->c);
        InOrder(p->rchild);//æ‰“å°å³å­æ ‘
    }
}
//ååºéå†
void PostOrder(BiTree p)
{
    if(p!=NULL)
    {
        PostOrder(p->lchild);//æ‰“å°å·¦å­æ ‘
        PostOrder(p->rchild);//æ‰“å°å³å­æ ‘
        printf("%c", p->c);
    }
}

//å±‚åºéå†
//å±‚æ¬¡éå†,å±‚åºéå†ï¼Œå¹¿åº¦ä¼˜å…ˆéå†
void LevelOrder(BiTree T)
{
    LinkQueue Q;
    InitQueue(Q);
    BiTree p;//å­˜å‚¨å‡ºé˜Ÿçš„ç»“ç‚¹
    EnQueue(Q,T);//æŠŠæ ¹å…¥é˜Ÿ
    while(!IsEmpty(Q))
    {
        DeQueue(Q,p);
        putchar(p->c);//ç­‰ä»·äºprintf("%c",c);
        if(p->lchild)
        {
            EnQueue(Q,p->lchild);//å·¦å­©å­ä¸ä¸ºç©ºï¼Œå°±å…¥é˜Ÿå·¦å­©å­
        }
        if(p->rchild)
        {
            EnQueue(Q,p->rchild);//å³å­©å­ä¸ä¸ºç©ºï¼Œå°±å…¥é˜Ÿå³å­©å­
        }
    }
}

int main() {
    BiTree pnew;//ç”¨æ¥æŒ‡å‘æ–°ç”³è¯·çš„æ ‘ç»“ç‚¹
    BiTree tree=NULL;//treeæ˜¯æŒ‡å‘æ ‘æ ¹çš„ï¼Œä»£è¡¨æ ‘
    char c;
    ptag_t phead=NULL,ptail=NULL,listpnew=NULL,pcur;
    //abcdefghij
    while(scanf("%c",&c))
    {
        if(c=='\n')
        {
            break;//è¯»å–åˆ°æ¢è¡Œå°±ç»“æŸ
        }
        //callocç”³è¯·çš„ç©ºé—´å¤§å°æ˜¯ä¸¤ä¸ªå‚æ•°ç›´æ¥ç›¸ä¹˜ï¼Œå¹¶å¯¹ç©ºé—´è¿›è¡Œåˆå§‹åŒ–ï¼Œèµ‹å€¼ä¸º0
        pnew= (BiTree)calloc(1,sizeof(BiTNode));
        pnew->c=c;
        listpnew= (ptag_t)calloc(1,sizeof(tag_t));//ç»™é˜Ÿåˆ—ç»“ç‚¹ç”³è¯·ç©ºé—´
        listpnew->p=pnew;
        //å¦‚æœæ˜¯æ ‘çš„ç¬¬ä¸€ä¸ªç»“ç‚¹
        if(NULL==tree)
        {
            tree=pnew;//treeæŒ‡å‘æ ‘çš„æ ¹ç»“ç‚¹
            phead=listpnew;//ç¬¬ä¸€ä¸ªç»“ç‚¹å³æ˜¯é˜Ÿåˆ—å¤´ï¼Œä¹Ÿæ˜¯é˜Ÿåˆ—å°¾
            ptail=listpnew;
            pcur=listpnew;//pcurè¦æŒ‡å‘è¦è¿›å…¥æ ‘çš„çˆ¶äº²å…ƒç´ 
        }else{
            //è®©å…ƒç´ å…ˆå…¥é˜Ÿåˆ—
            ptail->pnext=listpnew;
            ptail=listpnew;
            //æ¥ä¸‹æ¥æŠŠç»“ç‚¹æ”¾å…¥æ ‘ä¸­
            if(NULL==pcur->p->lchild)
            {
                pcur->p->lchild=pnew;//pcur->på·¦å­©å­ä¸ºç©ºï¼Œå°±æ”¾å…¥å·¦å­©å­
            }else if(NULL==pcur->p->rchild)
            {
                pcur->p->rchild=pnew;//pcur->på³å­©å­ä¸ºç©ºï¼Œå°±æ”¾å…¥å³å­©å­
                pcur=pcur->pnext;//å½“å‰ç»“ç‚¹å·¦å³å­©å­éƒ½æœ‰äº†ï¼Œpcurå°±æŒ‡å‘ä¸‹ä¸€ä¸ª
            }
        }
    }
    printf("--------PreOrder----------\n");//ä¹Ÿå«å…ˆåºéå†ï¼Œå…ˆæ‰“å°å½“å‰ç»“ç‚¹ï¼Œæ‰“å°å·¦å­©å­ï¼Œæ‰“å°å³å­©å­
    PreOrder(tree);
    printf("\n--------InOrder------------\n");//å…ˆæ‰“å°å·¦å­©å­ï¼Œæ‰“å°çˆ¶äº²ï¼Œæ‰“å°å³å­©å­
    InOrder(tree);
    printf("\n--------PostOrder------------\n");//å…ˆæ‰“å°å·¦å­©å­ï¼Œæ‰“å°å³å­©å­ï¼Œæœ€åæ‰“å°çˆ¶äº²
    PostOrder(tree);
    printf("\n--------LevelOrder------------\n");
    LevelOrder(tree);
    return 0;
}

```

##### å…ˆåºéå†çœŸé¢˜ 2014å¹´

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231121173729500.png)

###### ä»£ç 

```c++
// function.h
// Created by yuebinghui on 2023/11/21.
//

#ifndef UNTITLED2_FUNCTION_H
#define UNTITLED2_FUNCTION_H

#endif //UNTITLED2_FUNCTION_H

#include <stdio.h>
#include <stdlib.h>

typedef int BiTElemType;
typedef struct BiTNode {
    BiTElemType c;
    BiTNode *lchild;
    BiTNode *rchild;
} BiTNode, *BiTree;

typedef struct LinkQueueNode {
    BiTree p;
    LinkQueueNode *next;
} LinkQueueNode;
```

```c++
// main.cpp
#include "function.h"

int PreOrder(BiTree T, int deep) {
    // é™æ€å˜é‡ï¼Œç±»ä¼¼äºå…¨å±€å˜é‡   åªä¼šåˆå§‹åŒ–ä¸€æ¬¡
    // é€’å½’å¥½éš¾ã€‚ã€‚ã€‚ã€‚
    static int wpl = 0;
    if (T) {
//        printf("%c", T->c);
        if (T->lchild == NULL && T->rchild == NULL) {
            // åˆ¤æ–­æ˜¯å¦æ˜¯å¶å­ç»“ç‚¹ï¼Œå¶å­ç»“ç‚¹æ‰è®¡ç®—wplå€¼
            wpl = wpl + T->c * deep;
        }
        PreOrder(T->lchild, deep + 1);
        PreOrder(T->rchild, deep + 1);
    }
    return wpl;
}


int main() {

    BiTree tree = NULL;
    BiTree treeNew;

    LinkQueueNode *front = NULL, *rear = NULL, *newQueueNode, *cur;


    char c;
    while (scanf("%c", &c)) {
        if (c == '\n') {
            break;;
        }

        treeNew = (BiTree) calloc(1, sizeof(BiTNode));
        treeNew->c = c;

        newQueueNode = (LinkQueueNode *) calloc(1, sizeof(LinkQueueNode));
        newQueueNode->p = treeNew;


        if (NULL == tree) {
            tree = treeNew;
            front = newQueueNode;
            rear = newQueueNode;
            cur = newQueueNode;
        } else {
            rear->next = newQueueNode;
            rear = newQueueNode;

            if (cur->p->lchild == NULL) {
                cur->p->lchild = treeNew;
            } else if (cur->p->rchild == NULL) {
                cur->p->rchild = treeNew;
                cur = cur->next;
            }
        }


        printf("%c\n", c);
    }

    int wpl = PreOrder(tree, 0);
    printf("%d\n", wpl);
// abcdefghij
    return 0;
}
```

## æŸ¥æ‰¾

#### é¡ºåºæŸ¥æ‰¾

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123142859693.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

typedef int ElemType;
typedef struct {
    ElemType *data;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int Len) {
    // ç”³è¯·ç©ºé—´è¦çœ‹ç”³è¯·ä»€ä¹ˆçš„ç©ºé—´ï¼Œè¿™é‡Œåˆšåˆšæ”¾ SSTable,ä½ ç»™int ç±»å‹çš„dataèµ‹å€¼ç»“æ„ä½“å¹²é¸¡æ¯›
    ST.data = (ElemType *) malloc(sizeof(ElemType) * ST.TableLen);
    ST.TableLen = Len + 1;
    srand(time(NULL));
    for (int i = 1; i < ST.TableLen; i++) {
        ST.data[i] = rand() % 100;
    }
}

void PrintSSTable(SSTable ST) {
    for (int i = 1; i < ST.TableLen; i++) {
        printf("%3d", ST.data[i]);
    }
    printf("\n");
}

ElemType SearchPos(SSTable ST, int key) {
    ST.data[0] = key;
    int i;
    for (i = ST.TableLen - 1; key != ST.data[i]; --i);
    return i;
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);
    PrintSSTable(ST);
    int key;
    scanf("%d", &key);
    int pos = SearchPos(ST, key);
    printf("%d", pos);
}
```

#### æŠ˜åŠæŸ¥æ‰¾ / äºŒåˆ†æŸ¥æ‰¾

åŠ¨ç”»

https://www.cs.usfca.edu/~galles/visualization/Search.html

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123143127843.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123143415899.png)

![image-20230901155811294](/Users/yuebinghui/Documents/program/github/note/images/image-20230901155811294.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
typedef int ElemType;
typedef struct {
    ElemType* elem;//æ•´å‹æŒ‡é’ˆ
    int TableLen;//å­˜å‚¨åŠ¨æ€æ•°ç»„é‡Œè¾¹å…ƒç´ çš„ä¸ªæ•°
}SSTable;

//initè¿›è¡Œäº†éšæœºæ•°ç”Ÿæˆï¼ŒæŠ˜åŠæŸ¥æ‰¾æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨å“¨å…µ
void ST_Init(SSTable& ST, int len)
{
    ST.TableLen = len;
    ST.elem = (ElemType*)malloc(sizeof(ElemType) * ST.TableLen);
    int i;
    srand(time(NULL));//éšæœºæ•°ç”Ÿæˆ
    for (i = 0; i < ST.TableLen; i++)
    {
        ST.elem[i] = rand() % 100;
    }
}
void ST_print(SSTable ST)
{
    for (int i = 0; i < ST.TableLen; i++)
    {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}
//å®ç°äºŒåˆ†æŸ¥æ‰¾
int BinarySearch(SSTable L, ElemType key)
{
    int low=0;
    int high=L.TableLen-1;
    int mid;
    while(low<=high)//low<=highï¼Œå¯ä»¥è®©midæ—¢èƒ½å–åˆ°lowï¼Œä¹Ÿèƒ½å–åˆ°high
    {
        mid=(low+high)/2;
        if(key>L.elem[mid])//å¦‚æœç›®æ ‡å€¼å¤§äºä¸­ä½æ•°
        {
            low=mid+1;
        } else if(key<L.elem[mid])
        {
            high=mid-1;
        }else{
            return mid;
        }
    }
    return -1;
}
//å‡½æ•°åä¸­å­˜å‚¨çš„æ˜¯å‡½æ•°çš„å…¥å£åœ°å€ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œæ˜¯å‡½æ•°æŒ‡é’ˆç±»å‹
//leftæŒ‡é’ˆå’ŒrightæŒ‡é’ˆæ˜¯æŒ‡å‘æ•°ç»„ä¸­çš„ä»»æ„ä¸¤ä¸ªå…ƒç´ 
//qsortè§„å®šå¦‚æœleftæŒ‡é’ˆæŒ‡å‘çš„å€¼å¤§äºrightæŒ‡é’ˆæŒ‡å‘çš„å€¼ï¼Œè¿”å›æ­£å€¼ï¼Œå°äºï¼Œè¿”å›è´Ÿå€¼ï¼Œç›¸ç­‰è¿”å›0
int compare(const void *left, const void *right)
{
    return *(int*)left-*(int*)right;
    //return *(ElemType*)right - *(ElemType*)left;//ä»å¤§åˆ°å°æ’åº
}
//äºŒåˆ†æŸ¥æ‰¾
int main() {
    SSTable ST;
    ST_Init(ST,10);//åˆå§‹åŒ–ï¼Œéšæœº10ä¸ªå…ƒç´ 
    ST_print(ST);
    qsort(ST.elem,ST.TableLen,sizeof(ElemType),compare);//æ’åº
    ST_print(ST);
    ElemType key;
    printf("please input search key:\n");
    scanf("%d",&key);
    int pos=BinarySearch(ST,key);
    if(pos!=-1)
    {
        printf("find key %d\n",pos);
    }else{
        printf("not find\n");
    }
    return 0;
}
```

#### äºŒå‰æ’åºæ ‘ï¼ˆäºŒå‰æŸ¥æ‰¾æ•°ï¼‰

åŠ¨ç”»

https://www.cs.usfca.edu/~galles/visualization/BST.html

![](/Users/yuebinghui/Documents/program/github/note/images/image-20230901160833093.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123151003365.png)

```c++
#include <stdio.h>
#include <stdlib.h>


typedef int KeyType;
typedef struct BSTNode{
   KeyType key;
   struct BSTNode *lchild,*rchild;
}BSTNode,*BiTree;

// ç‹é“ä¹¦ä¸Šçš„é€’å½’å†™æ³•ï¼Œä»£ç ç®€å•ï¼Œä½†æ˜¯ç†è§£æœ‰éš¾åº¦
int BST_Insert1(BiTree &T,KeyType k)
{
    if(NULL==T)
    {  //ä¸ºæ–°èŠ‚ç‚¹ç”³è¯·ç©ºé—´ï¼Œç¬¬ä¸€ä¸ªç»“ç‚¹ä½œä¸ºæ ‘æ ¹ï¼Œåé¢é€’å½’å†è¿›å…¥çš„ä¸æ˜¯æ ‘æ ¹ï¼Œæ˜¯ä¸ºå¶å­ç»“ç‚¹
        T=(BiTree)malloc(sizeof(BSTNode));
        T->key=k;
        T->lchild=T->rchild=NULL;
        return 1;//ä»£è¡¨æ’å…¥æˆåŠŸ
    }
    else if(k==T->key)
        return 0;//å‘ç°ç›¸åŒå…ƒç´ ï¼Œå°±ä¸æ’å…¥
    else if(k<T->key)//å¦‚æœè¦æ’å…¥çš„ç»“ç‚¹ï¼Œå°äºå½“å‰ç»“ç‚¹
        //å‡½æ•°è°ƒç”¨ç»“æŸåï¼Œå·¦å­©å­å’ŒåŸæ¥çš„çˆ¶äº²ä¼šå…³è”èµ·æ¥ï¼Œå·§å¦™åˆ©ç”¨äº†å¼•ç”¨æœºåˆ¶
        return BST_Insert1(T->lchild,k);
    else
        return BST_Insert1(T->rchild,k);
}

//54,20,66,40,28,79,58
//éé€’å½’çš„åˆ›å»ºäºŒå‰æŸ¥æ‰¾æ ‘
int BST_Insert(BiTree& T,KeyType k)
{
    BiTree TreeNew= (BiTree)calloc(1,sizeof(BSTNode));//æ–°ç»“ç‚¹ç”³è¯·ç©ºé—´
    TreeNew->key=k;//æŠŠå€¼æ”¾å…¥
    if(NULL==T)//æ ‘ä¸ºç©ºï¼Œæ–°ç»“ç‚¹ä½œä¸ºæ ‘çš„æ ¹
    {
        T=TreeNew;
        return 1;
    }
    BiTree p=T,parent;//pç”¨æ¥æŸ¥æ‰¾æ ‘
    while(p)
    {
        parent=p;//parentç”¨æ¥å­˜pçš„çˆ¶äº²
        if(k>p->key)
        {
            p=p->rchild;
        }else if(k<p->key)
        {
            p=p->lchild;
        }else{
            return 0;//ç›¸ç­‰çš„å…ƒç´ ä¸å¯ä»¥æ”¾å…¥æŸ¥æ‰¾æ ‘ï¼Œè€ƒç ”ä¸ä¼šè€ƒç›¸ç­‰å…ƒç´ æ”¾å…¥é—®é¢˜
        }
    }
    //æ¥ä¸‹æ¥è¦åˆ¤æ–­æ”¾åˆ°çˆ¶äº²çš„å·¦è¾¹è¿˜æ˜¯å³è¾¹
    if(k>parent->key)//æ”¾åˆ°çˆ¶äº²å³è¾¹
    {
        parent->rchild=TreeNew;
    }else{//æ”¾åˆ°çˆ¶äº²å·¦è¾¹
        parent->lchild=TreeNew;
    }
    return 1;
}
//æ ‘ä¸­ä¸æ”¾
void Creat_BST(BiTree& T,KeyType* str,int len)
{
    int i;
    for(i=0;i<len;i++)
    {
        BST_Insert(T,str[i]);//æŠŠæŸä¸€ä¸ªç»“ç‚¹æ”¾å…¥äºŒå‰æŸ¥æ‰¾æ ‘
    }
}

void InOrder(BiTree T)
{
    if(T!=NULL)
    {
        InOrder(T->lchild);
        printf("%3d",T->key);
        InOrder(T->rchild);
    }
}

BiTree BST_Search(BiTree T,KeyType k,BiTree &parent)
{
    parent=NULL;
    while(T!=NULL&&k!=T->key)
    {
        parent=T;
        if(k>T->key)
        {
            T=T->rchild;
        }else{
            T=T->lchild;
        }
    }
    return T;
}



//äºŒå‰æ’åºæ ‘æ–°å»ºï¼Œä¸­åºéå†ï¼ŒæŸ¥æ‰¾
int main() {
    BiTree T=NULL;//æ ‘æ ¹
    KeyType str[7]={54,20,66,40,28,79,58};//å°†è¦è¿›å…¥äºŒå‰æ’åºæ ‘çš„å…ƒç´ å€¼
    Creat_BST(T,str,7);
    InOrder(T);//ä¸­åºéå†äºŒå‰æŸ¥æ‰¾æ ‘æ˜¯ç”±å°åˆ°å¤§çš„
    printf("\n");
    BiTree search,parent;
    search=BST_Search(T,40,parent);
    if(search)
    {
        printf("find key %d\n",search->key);
    }else{
        printf("not find\n");
    }
    return 0;
}
```

#### äºŒå‰æ’åºæ ‘åˆ é™¤

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123155808350.png)

```c++
#include <stdio.h>
#include <stdlib.h>


typedef int KeyType;
typedef struct BSTNode{
   KeyType key;
   struct BSTNode *lchild,*rchild;
}BSTNode,*BiTree;

// ç‹é“ä¹¦ä¸Šçš„é€’å½’å†™æ³•ï¼Œä»£ç ç®€å•ï¼Œä½†æ˜¯ç†è§£æœ‰éš¾åº¦
int BST_Insert1(BiTree &T,KeyType k)
{
    if(NULL==T)
    {  //ä¸ºæ–°èŠ‚ç‚¹ç”³è¯·ç©ºé—´ï¼Œç¬¬ä¸€ä¸ªç»“ç‚¹ä½œä¸ºæ ‘æ ¹ï¼Œåé¢é€’å½’å†è¿›å…¥çš„ä¸æ˜¯æ ‘æ ¹ï¼Œæ˜¯ä¸ºå¶å­ç»“ç‚¹
        T=(BiTree)malloc(sizeof(BSTNode));
        T->key=k;
        T->lchild=T->rchild=NULL;
        return 1;//ä»£è¡¨æ’å…¥æˆåŠŸ
    }
    else if(k==T->key)
        return 0;//å‘ç°ç›¸åŒå…ƒç´ ï¼Œå°±ä¸æ’å…¥
    else if(k<T->key)//å¦‚æœè¦æ’å…¥çš„ç»“ç‚¹ï¼Œå°äºå½“å‰ç»“ç‚¹
        //å‡½æ•°è°ƒç”¨ç»“æŸåï¼Œå·¦å­©å­å’ŒåŸæ¥çš„çˆ¶äº²ä¼šå…³è”èµ·æ¥ï¼Œå·§å¦™åˆ©ç”¨äº†å¼•ç”¨æœºåˆ¶
        return BST_Insert1(T->lchild,k);
    else
        return BST_Insert1(T->rchild,k);
}

//54,20,66,40,28,79,58
//éé€’å½’çš„åˆ›å»ºäºŒå‰æŸ¥æ‰¾æ ‘
int BST_Insert(BiTree& T,KeyType k)
{
    BiTree TreeNew= (BiTree)calloc(1,sizeof(BSTNode));//æ–°ç»“ç‚¹ç”³è¯·ç©ºé—´
    TreeNew->key=k;//æŠŠå€¼æ”¾å…¥
    if(NULL==T)//æ ‘ä¸ºç©ºï¼Œæ–°ç»“ç‚¹ä½œä¸ºæ ‘çš„æ ¹
    {
        T=TreeNew;
        return 1;
    }
    BiTree p=T,parent;//pç”¨æ¥æŸ¥æ‰¾æ ‘
    while(p)
    {
        parent=p;//parentç”¨æ¥å­˜pçš„çˆ¶äº²
        if(k>p->key)
        {
            p=p->rchild;
        }else if(k<p->key)
        {
            p=p->lchild;
        }else{
            return 0;//ç›¸ç­‰çš„å…ƒç´ ä¸å¯ä»¥æ”¾å…¥æŸ¥æ‰¾æ ‘ï¼Œè€ƒç ”ä¸ä¼šè€ƒç›¸ç­‰å…ƒç´ æ”¾å…¥é—®é¢˜
        }
    }
    //æ¥ä¸‹æ¥è¦åˆ¤æ–­æ”¾åˆ°çˆ¶äº²çš„å·¦è¾¹è¿˜æ˜¯å³è¾¹
    if(k>parent->key)//æ”¾åˆ°çˆ¶äº²å³è¾¹
    {
        parent->rchild=TreeNew;
    }else{//æ”¾åˆ°çˆ¶äº²å·¦è¾¹
        parent->lchild=TreeNew;
    }
    return 1;
}
//æ ‘ä¸­ä¸æ”¾
void Creat_BST(BiTree& T,KeyType* str,int len)
{
    int i;
    for(i=0;i<len;i++)
    {
        BST_Insert(T,str[i]);//æŠŠæŸä¸€ä¸ªç»“ç‚¹æ”¾å…¥äºŒå‰æŸ¥æ‰¾æ ‘
    }
}

void InOrder(BiTree T)
{
    if(T!=NULL)
    {
        InOrder(T->lchild);
        printf("%3d",T->key);
        InOrder(T->rchild);
    }
}

BiTree BST_Search(BiTree T,KeyType k,BiTree &parent)
{
    parent=NULL;
    while(T!=NULL&&k!=T->key)
    {
        parent=T;
        if(k>T->key)
        {
            T=T->rchild;
        }else{
            T=T->lchild;
        }
    }
    return T;
}

//è¿™ä¸ªä¹¦ä¸Šæ²¡æœ‰äºŒå‰æ’åºæ ‘åˆ é™¤ä»£ç --è€ƒå¤§é¢˜æ²¡é‚£ä¹ˆé«˜
void DeleteNode(BiTree &root,KeyType x)
{
    if(NULL==root)
    {
        return;
    }
    if(root->key>x)//å½“å‰ç»“ç‚¹å¤§äºè¦åˆ é™¤çš„ç»“ç‚¹ï¼Œå¾€å·¦å­æ ‘æ‰¾
    {
        DeleteNode(root->lchild,x);
    }else if(root->key<x)//å½“å‰ç»“ç‚¹å°äºè¦åˆ é™¤çš„ç»“ç‚¹ï¼Œå¾€å³å­æ ‘æ‰¾
    {
        DeleteNode(root->rchild,x);
    }else{//æ‰¾åˆ°äº†è¦åˆ é™¤çš„ç»“ç‚¹
        if(root->lchild==NULL)//å·¦å­æ ‘ä¸ºç©ºï¼Œå³å­æ ‘ç›´æ¥é¡¶ä¸Šå»
        {
            BiTree tempNode=root;
            root=root->rchild;
            free(tempNode);
        }else if(root->rchild==NULL)//å³å­æ ‘ä¸ºç©ºï¼Œå·¦å­æ ‘ç›´æ¥é¡¶ä¸Šå»
        {
            BiTree tempNode=root;
            root=root->lchild;
            free(tempNode);
        }else{//ä¸¤è¾¹éƒ½ä¸ä¸ºç©º
            //ä¸€èˆ¬çš„åˆ é™¤ç­–ç•¥æ˜¯å·¦å­æ ‘çš„æœ€å¤§æ•°æ® æˆ– å³å­æ ‘çš„æœ€å°æ•°æ®
            // ä»£æ›¿è¦åˆ é™¤çš„èŠ‚ç‚¹(è¿™é‡Œé‡‡ç”¨æŸ¥æ‰¾å·¦å­æ ‘æœ€å¤§æ•°æ®æ¥ä»£æ›¿ï¼Œæœ€å¤§æ•°æ®æ˜¯å·¦å­æ ‘çš„æœ€å³ç»“ç‚¹)
            BiTree tempNode=root->lchild;
            while(tempNode->rchild!=NULL)
            {
                tempNode=tempNode->rchild;
            }
            root->key=tempNode->key;//æŠŠtempNodeå¯¹åº”çš„å€¼æ›¿æ¢åˆ°è¦åˆ é™¤çš„å€¼çš„ä½ç½®ä¸Š
            DeleteNode(root->lchild,tempNode->key);//åœ¨å·¦å­æ ‘ä¸­æ‰¾åˆ°tempNodeçš„å€¼ï¼ŒæŠŠå…¶åˆ é™¤
        }
    }
}

//äºŒå‰æ’åºæ ‘æ–°å»ºï¼Œä¸­åºéå†ï¼ŒæŸ¥æ‰¾
int main() {
    BiTree T=NULL;//æ ‘æ ¹
    KeyType str[7]={54,20,66,40,28,79,58};//å°†è¦è¿›å…¥äºŒå‰æ’åºæ ‘çš„å…ƒç´ å€¼
    Creat_BST(T,str,7);
    InOrder(T);//ä¸­åºéå†äºŒå‰æŸ¥æ‰¾æ ‘æ˜¯ç”±å°åˆ°å¤§çš„
    printf("\n");
    BiTree search,parent;
    search=BST_Search(T,40,parent);
    if(search)
    {
        printf("find key %d\n",search->key);
    }else{
        printf("not find\n");
    }
    DeleteNode(T,40);//åˆ é™¤æŸä¸ªç»“ç‚¹
    InOrder(T);
    printf("\n");
    return 0;
}
```

## æ’åº

## äº¤æ¢æ’åº

### å†’æ³¡æ’åº

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231123163507500.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}

void Swap(ElemType &a, ElemType &b) {
    int temp = a;
    a = b;
    b = temp;
}

// 64 94 95 79 69 84 18 22 12 78
// 12 64 94 95 79 69 84 18 22 78 å¤–å±‚å®Œæˆä¸€æ¬¡å¾ªç¯åï¼Œæœ€å°å€¼åˆ°äº†æœ€å‰é¢
void BubbleSort(int arr[], int len) {
    bool flag;
    for (int i = 0; i < len - 1; ++i) { // iæœ€å¤šè®¿é—®åˆ°8
        flag = false; //å…ƒç´ æ˜¯å¦å‘ç”Ÿäº¤æ¢çš„æ ‡å¿—
        for (int j = len - 1; j > i; j--) {
//            if (arr[j - 1] > arr[j]) { // æŠŠæœ€å°çš„å…ƒç´ æ”¾åœ¨äº†å‰é¢
            if (arr[j - 1] < arr[j]) { // æŠŠæœ€å¤§çš„å…ƒç´ æ”¾åœ¨äº†å‰é¢
                Swap(arr[j - 1], arr[j]);
                flag = true; // å¦‚æœè¿™è½®forå¾ªç¯æ²¡æœ‰è¿›å…¥è¿™ä¸ªifè¯´æ˜å…¨éƒ¨æœ‰åº
            }
        }
        if (!flag) { 
            return;// è¿™é‡Œç›´æ¥ç»“æŸï¼Œreturn æ‰
        }
    }
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    int arr[10] = {0, 22, 55, 33, 77, 44, 88, 99, 66, 11};

    Print(ST);

//    memcpy(ST.elem, arr, sizeof(arr));
    BubbleSort(ST.elem, 10);

//    ST.elem
    Print(ST);

    return 0;
}
```

### å¿«é€Ÿæ’åº ğŸŒŸ

å¿«é€Ÿæ’åº partition å‡½æ•°æ‰§è¡Œè¿‡ç¨‹

<video src="/Users/yuebinghui/Documents/ç¬”è®°/æ•°æ®ç»“æ„ â“è¡¨ç¤ºä¸ä¼šçš„/å±å¹•å½•åˆ¶2023-11-27 13.18.45.mov"></video>

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231126113624693.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}


// pivot
// partition
int partition(ElemType *A, int low, int high) {
    ElemType pivot = A[low]; // æ‹¿æœ€å·¦è¾¹çš„ä½œä¸ºåˆ†éš”å€¼ï¼Œå¹¶ä¸”å­˜å‚¨ä¸‹æ¥
    while (low < high) {
        while (low < high && pivot <= A[high]) { // ä»åå¾€å‰éå†æ‰¾åˆ°ä¸€ä¸ªæ¯”åˆ†éš”å€¼å°çš„
            high--;
        }
        A[low] = A[high]; // æŠŠæ¯”åˆ†éš”å€¼å°çš„æ”¾åˆ°A[low]ä½ç½®ä¸Š
        while (low < high && pivot >= A[low]) { // // ä»å‰å¾€åéå†æ‰¾åˆ°ä¸€ä¸ªæ¯”åˆ†éš”å€¼å¤§çš„
            low++;
        }
        A[high] = A[low]; // æŠŠæ¯”åˆ†éš”å€¼å¤§çš„æ”¾åˆ°A[high]ä½ç½®ä¸Šï¼Œå› ä¸ºåˆšæ‰A[high]å…ƒç´ å·²ç»æ”¾åˆ°äº†A[low]ä½ç½®ä¸Š
    }
    A[low] = pivot; // æŠŠåˆ†éš”å€¼æ”¾åˆ°æœ€ålowçš„ä½ç½®ï¼Œå¦‚æœå·¦è¾¹æˆ–è€…å³è¾¹æœ‰å…ƒç´ ï¼Œåˆšå¥½å·¦è¾¹éƒ½æ¯”å®ƒå°ï¼Œå³è¾¹éƒ½æ¯”å®ƒå¤§
    return low; // è¿”å›åˆ†éš”å€¼ä½ç½®æ‰€åœ¨çš„ä¸‹æ ‡
}


// ElemType *A ä¸ ElemType A[]æ˜¯ç­‰ä»·çš„ éƒ½æ˜¯ä¸€ä¸ªå†…å­˜åœ°å€
//void QuickSort(ElemType *A, int low, int high) {
void QuickSort(ElemType A[], int low, int high) {
    if (low < high) {
        ElemType pivotIndex = partition(A, low, high); //pivotIndex ç”¨æ¥å­˜åˆ†éš”å€¼çš„ä½ç½®
        QuickSort(A, low, pivotIndex - 1); // å‰ä¸€åŠç»§ç»­é€’å½’æ’å¥½
        QuickSort(A, pivotIndex + 1, high);
    }
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    int arr[10] = { 22, 55, 33, 77, 44, 88, 99, 66, 11};

    Print(ST);

//    memcpy(ST.elem, arr, sizeof(arr));

//    ST.elem
    QuickSort(ST.elem, 0, 9); //æ³¨æ„è¿™ä¸ªä½ç½®æ˜¯n-1ï¼Œä¹Ÿå°±æ˜¯9ï¼Œå› ä¸ºå‡½æ•°é‡Œå–äº†highçš„ä½ç½®ï¼Œå³æ•°ç»„çš„æœ€åä¸€ä½
    Print(ST);

    return 0;
}
```

## æ’å…¥æ’åº

### ç›´æ¥æ’å…¥æ’åº

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}

void InsertSort(ElemType *A, int n) {
// ä»1å¼€å§‹ 1~nä¹Ÿæ˜¯æ‰§è¡Œäº†n-1æ¬¡
    for (int i = 1; i < n; ++i) {
        // åªæœ‰åé¢çš„ä¸€ä¸ªå…ƒç´ æ¯”å‰é¢çš„ä¸€ä¸ªå…ƒç´ å°ï¼Œæ‰è¿›å…¥å†…å±‚å¾ªç¯ï¼Œå› ä¸ºæ¯ä¸€æ¬¡éå†éƒ½æ˜¯å°†å¸¦æ’åºçš„å…ƒç´ æ’å…¥åˆ°å·²ç»æ’å¥½åºçš„ä½ç½®
        if (A[i] < A[i - 1]) {
            // å°†ç¬¬iä¸ªå…ƒç´ æš‚å­˜åˆ°tempï¼Œå³å¾…æ’å…¥çš„å…ƒç´ 
            int j, temp = A[i];
// åˆ¤æ–­iå‰é¢é‚£ä¸ªå…ƒç´ ï¼Œå¦‚æœiå‰é¢çš„é‚£ä¸ªæˆ–é‚£äº›å…ƒç´ æ¯”tempå¤§ï¼Œé‚£ä¹ˆå°±æŠŠä»–ä»¬ä¾æ¬¡åç§»
            for (j = i - 1; j >= 0 && A[j] > temp; j--) {
                A[j + 1] = A[j];
            }
            // æœ€åæŠŠtempå…ƒç´ æ’å…¥åˆ°å±äºå®ƒçš„åˆé€‚ä½ç½®
            A[j + 1] = temp;
        }
    }
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    int arr[10] = {22, 55, 33, 77, 44, 88, 99, 66, 11};

//    Print(ST);

    memcpy(ST.elem, arr, sizeof(arr));

//    ST.elem
    InsertSort(ST.elem, 10);

    Print(ST);

    return 0;
}
```

### æŠ˜åŠæ’å…¥æ’åº

### å¸Œå°”æ’åº

## é€‰æ‹©æ’åº

### ç®€å•é€‰æ‹©æ’åº

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231127150443296.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}

void Swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

void SelectSort(ElemType *A, int n) {
    int min, i, j;

    for (i = 0; i < n - 1; i++) { //å¦‚æœnæ˜¯10ï¼Œæœ€å¤š 0ï½8
        min = i;  //è®¤ä¸ºç¬¬iä¸ªä½ç½®æœ€å°
        for (j = i + 1; j < n; j++) { // //å¦‚æœnæ˜¯10ï¼Œæœ€å¤š9
            if (A[j] < A[min]) {
                min = j;
            }
        }
// éå†å®Œæ¯•ï¼Œå¦‚æœæ‰¾åˆ°æœ€å°çš„å€¼çš„ä½ç½®åï¼Œäº¤æ¢ï¼Œè¿™æ ·æœ€å°å€¼å°±è¢«æ”¾åˆ°äº†ç¬¬iä¸ªä½ç½®ï¼Œå³æœ€å‰é¢
        if (i != min) {
            Swap(A[i], A[min]);
        }
    }
}

int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    int arr[10] = {0, 22, 55, 33, 77, 44, 88, 99, 66, 11};

//    Print(ST);

    memcpy(ST.elem, arr, sizeof(arr));

//    ST.elem
    SelectSort(ST.elem, 10);

    Print(ST);

    return 0;
}
```

### å †æ’åº

Cè¯­è¨€ç£å­¦è¥é‡Œè€å¸ˆçš„ä»£ç ï¼Œè¯¾æœ¬çš„ä»£ç åœ¨ç¬”è®°é‡Œ

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

typedef int ElemType;
typedef struct {
    ElemType *elem;
    int TableLen;
} SSTable;

void InitSSTable(SSTable &ST, int len) {
    ST.TableLen = len;
    ST.elem = (ElemType *) malloc(ST.TableLen * sizeof(ElemType));
    srand(time(NULL));
    for (int i = 0; i < ST.TableLen; ++i) {
        ST.elem[i] = rand() % 100;
    }
}

void Print(SSTable ST) {
    for (int i = 0; i < ST.TableLen; ++i) {
        printf("%3d", ST.elem[i]);
    }
    printf("\n");
}

void Swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

void AdjustDown1(ElemType A[], int k, int len) {
    int dad = k; // çˆ¶äº²çš„ä¸‹æ ‡
    int son = k * 2 + 1; // å·¦å­©å­çš„ä¸‹æ ‡

    while (son < len) { // å‡å¦‚sonå·²ç»æ˜¯9äº†ï¼Œ9<10æ‰€ä»¥å¯ä»¥è¿›è¿™ä¸ªå¾ªç¯ å› ä¸ºä¸‹æ ‡ä¸º9çš„å…ƒç´ éœ€è¦å’Œå’Œçˆ¶å…ƒç´ æ¯”è¾ƒ
        if (son + 1 < len && A[son] < A[son + 1]) { // å› ä¸ºä¸€å…±ä¸‹æ ‡åªåˆ°9ä¸èƒ½son++äº†ï¼Œæ‰€ä»¥åŠ äº†son + 1 < len ä¸è®©è¿›å…¥è¿™ä¸ªåˆ¤æ–­ï¼Œ
            // é’ˆå¯¹åªæœ‰å·¦å­©å­çš„æƒ…å†µ
            son++;
        }
        if (A[son] > A[dad]) { // å¦‚æœå­©å­æ¯”çˆ¶äº²å¤§å°±äº¤æ¢
            Swap(A[son], A[dad]); // åªæ¢äº†å€¼ï¼Œä½†æ˜¯ç´¢å¼•æ²¡æ¢
            dad = son; // ç„¶åå†æŠŠå„¿å­å½“ä½œçˆ¶äº²ï¼Œçœ‹çœ‹å®ƒçš„å„¿å­éœ€è¦ä¸éœ€è¦äº¤æ¢
            son = dad * 2 + 1;
        } else { // ä¸éœ€è¦ç›´æ¥è·³å‡ºå¾ªç¯
            break;
        }

    }
}

void HeapSort1(ElemType A[], int len) {
    int i;
    // è¿™ä¸ªå°±æ˜¯æŠŠå †è°ƒæ•´ä¸ºå¤§æ ¹å †
    for (i = len / 2 - 1; i >= 0; i--) {
        AdjustDown1(A, i, len); // å † éœ€è¦è°ƒæ•´å…ƒç´ çš„çˆ¶ç»“ç‚¹ æ•°ç»„é•¿åº¦
    }
    // ğŸ‘†å·²ç»æŠŠå…ƒç´ è°ƒæ•´ä¸ºäº†å¤§æ ¹å †

    Swap(A[0], A[len - 1]); // ç¬¬ä¸€ä½å’Œæ•°ç»„çš„æœ€åä¸€ä½è¿›è¡Œäº¤æ¢

    for (int j = len - 1; j > 1; j--) { // len-1 = 9 j>1 å¯ä»¥æ‰§è¡Œåˆ°2 9~2æ‰§è¡Œäº†8æ¬¡ 9ä¸ªå…ƒç´ äº¤æ¢8æ¬¡æœ‰åºï¼ŒæŒºåˆç†æŠŠ j--æ¯æ¬¡æ•°ç»„é•¿åº¦-1
        AdjustDown1(A, 0, j);// å°†è°ƒæ•´å‰©ä½™å…ƒç´ ä¸ºå¤§æ ¹å † 0ä¼ å…¥çš„æ˜¯éœ€è¦è°ƒæ•´å…ƒç´ çš„ä¸‹æ ‡ï¼Œå³çˆ¶ç»“ç‚¹ä¸‹æ ‡   jæ˜¯æ•°ç»„ç°æœ‰çš„é•¿åº¦
        Swap(A[0], A[j - 1]); // ä¸‹æ ‡ä¸º0çš„å…ƒç´ å€¼ å’Œ ä¸‹æ ‡ä¸ºé•¿åº¦-1çš„å³æœ€åä¸€ä¸ªå…ƒç´ äº’æ¢ä½ç½®
    }
}


int main() {
    SSTable ST;
    InitSSTable(ST, 10);

    Print(ST);
    int arr[10] = {3, 87, 2, 93, 78, 56, 61, 38, 12, 40};
    memcpy(ST.elem, arr, sizeof(arr));
// HeapSort(ST.elem, 9); ç‹é“ä¹¦ä¸Š0å·å…ƒç´ æ²¡æœ‰å‚ä¸æ’åº å°±æ˜¯æ•°æ®æ˜¯ä»1å¼€å§‹å­˜çš„

    HeapSort1(ST.elem, 10); // æ•°ç»„åä¸ªé‡Œéƒ½å­˜äº†å…ƒç´ 

//    ST.elem
    Print(ST);

    return 0;
}
```

## å½’å¹¶æ’åº

å½’å¹¶æ’åºæ˜¯å¤–éƒ¨æ’åº

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231129151019334.png)

çœ‹ä¸æ‡‚â“

```c++
#include <stdio.h>

#define N 7
typedef int ElemType;

void Print(ElemType A[]) {
    for (int i = 0; i < N; ++i) {
        printf("%3d", A[i]);
    };
    printf("\n");
}

void Merge(ElemType A[], int low, int mid, int high) {
    static ElemType B[N];
    int i, j, k;
    for (i = low; i <= high; i++) {
        B[i] = A[i];
    }
    k = low;
    for (i = low, j = mid + 1; i <= mid && j <= high;) {
        if (B[i] < A[j]) {
            A[k++] = B[i++];
        } else {
            A[k++] = B[j++];
        }
    }
    while (i <= mid) {
        A[k++] = B[i++];
    }
    while (j <= high) {
        A[k++] = B[j++];
    }
}

void MergeSort(ElemType A[], int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid); // æ’åºå¥½å‰ä¸€åŠ
        MergeSort(A, mid + 1, high); // æ’åºå¥½åä¸€åŠ
        Merge(A, low, mid, high); //åˆå¹¶
    }
}

// å½’å¹¶æ’åº
int main() {
    ElemType A[N] = {49, 38, 65, 97, 76, 13, 27}; // æ•°ç»„7ä¸ªå…ƒç´ 
    MergeSort(A, 0, 6);
    Print(A);
    return 0;
}
```