各位同学大家好，从这个小节开始，我们会学习单链表相关的内容，那之前我们学习了<u>线性表这种逻辑结构</u>。然后用了几个小节来学习了顺序表，那<u>**顺序表**就是用**顺序存储，这样的存储结构**实现的**线性表**</u>。而这个小节之后的内容，我们会学习怎么用链式存储的，这种存储结构来实现线性表。那用链式存储实现的线性表，我们统称为链表，而链表又可以具体分为单链表，双链表，循环链表和静态链表。这个小节我们先学习单链表，
怎么定义？也就是说怎么用代码实现一个单链表在之后还会用几个小节来介绍基于单链表这种存储结构。怎么实现线性表所要求实现的那些基本操作

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920195835698.png" alt="image-20240920195835698" style="zoom:50%;" />

好？那这个小节中，我们首先会介绍什么是单链表，然后会用代码定义一个单链表。单链表可以有两种实现方式，分别是带头结点的和不带头结点的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920195901638.png" alt="image-20240920195901638" style="zoom:50%;" />

## 什么是单链表

好的，先来看第一个问题，什么是单链表？其实经过绪论的学习，大家看到这张图就知道单链表是什么意思了。<u>单链表当中的这样一个结点，它需要存放数据元素，</u><u>同时还需要包含一个指向下一个结点的指针。由于每一个结点，它只包含这样的一个指针，所以它才叫单链表</u>。

那经过之前的学习，我们知道顺序表它的优点是可以随机存取，并且存储密度高，但是它也存在缺点，由于各个数据元素要求在物理上是连续存放的。所以如果用顺序表的方式来实现这种线性结构的话，那就会要求使用大片的连续空间。如果要拓展这个顺序表的容量的话，那是很不方便的，

而单链表就可以很好的解决这个问题，单链表中的各个节点在物理上可以是离散存放的，所以当我们要拓展单链表的长度的时候。其实只需要在呃内存当中随便抠一小块区域，把它作为存放新节点的区域就可以了，因此采用这种链式存储的方式的话，那改变容量会很方便。

不过呢，如果采用这种方式的话，那么我们要找到某一个位序的节点，那么我们只能从第一个节点开始，利用这个指针的信息依次往后寻找，直到找到我们想要的那个节点。也就说<u>单链表这种实现方式不支持随机存取</u>

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920200053564.png" alt="image-20240920200053564" style="zoom:50%;" />

### 数据域

### 指针域

好的，那接下来看一下怎么用代码定义一个单链表？不难看出，我们的单链表是由这样一个一个的节点组成的，而一个节点当中，它需要有一片空间，是用于存放数据元素的，还需要有另一片空间，是存放指向下一个节点的指针。所以我们可以定义一个struct类型的结构体，用于表示一个节点，
那这个节点当中有一个叫data的变量，用于存放这个数据元素，我们把它称之为数据域。
另外，还需要定义一个指向下一个结点的指针，这个指针变量的名字叫next，我们把这个变量称为指针域。

好了，那有了这个结构体的定义之后，如果我们想要往这个单链表当中增加一个新的节点的话，那么我们是不是就可以用malloc函数来申请一片存储这个结点的空间，并且用指针p来接收malloc函数的返回值，让它指向这个结点的起始地址。

之后是不是就可以设计一些代码逻辑，把p结点插入到这个单链表当中？

好，那按照我们这儿的这种写法，以后当我们想要定义一个。一个新的节点的时候，或者想要定义一个指向节点的指针的时候，是不是都得写这种struct LNode struct LNode？也就是说，每次都得带上struct这个关键字。那这么写有点麻烦，所以我们的教材里边使用了type define这个C语言的关键字，用这个关键字可以把这个数据类型给重命名。把它的名字稍微缩短一些，把它简化，其实我们在之前的小结中也用过type define这个关键词，只不过我们一直没有强调而已。那结合这个小节的内容，希望能够让跨考的同学们啊，真正的理解这个关键字，它的用法

其实用法很简单，就是在你的代码里先写一个这个关键字，然后后面跟一个你想要重命名的数据类型。接下来空一格，然后写入你想要给它取的另一个别名，比如说你可以把int这种数据类型给它取一个别的名字，叫做整数汉语拼音，是不是超亲切？

当然，你也可以用下面的这种方式，把指向int型变量的指针，把它重新命名为整数指针。好，那加了这两行代码之后，以前你定义一个int型的变量，还有指向int型的指针是不是这样的方式定义的？而现在你可以用这样的方式来定义。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920200657930.png" alt="image-20240920200657930" style="zoom:50%;" />

## typedef

同样的道理，我们是不是可以把struct LNode这种数据类型给它取一个别名，
就叫LNode把它名字缩短一点？那这样的话之后，你在写代码的时候，就不需要再带struct。就直接LNode就可以了，这样的话，你写代码是不是更简洁一些？好，那我们在这儿是先定义了一个struct LNode。然后再单独写了这样的一个语句来把它重命名，但是我们的教材里边用了一种更简洁的方式。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920201216175.png" alt="image-20240920201216175" style="zoom:50%;" />

课本中的这段代码其实等价于你自己先定义一个叫做struct Lode的一个数据类型。然后你把struct LNode把它重命名为LNode，并且用linklist来表示这是一个指向。struct  LNode的指针。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920201501869.png" alt="image-20240920201501869" style="zoom:50%;" />

那当我们要表示一个单链表的时候，是不是我们只需要声明一个所谓的头指针L，这个头指针指向了单链表的第一个结点，而由于各个结点是用这个next指针。把它们一个一个连起来的，所以是不是我们只要找到了第一个结点，那就相当于我们其实已经找到了整个单链表。好，那既然L这个指针，它是指向了某一个结点，那我们是不是定义L的时候可以用这样的方式来定义啊？LNode \*，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920201655692.png" alt="image-20240920201655692" style="zoom:50%;" />

而根据这个地方的重命名，其实我们的LNode \* L是不是又可以等价于linklist L？那这两种声明方式从效果上来看，其实是一模一样的，
只不过采用后面这种方式来声明投指针的话，那代码可读性会更强一点，

## LNode \* L和Linklist的区别

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920201931125.png" alt="image-20240920201931125" style="zoom:50%;" />

看一个例子，大家就明白了。我们在之后会学习一个基本操作，叫getElem，就是说把L这个链表当中的第i个节点给取出来。并且return返回，那注意它在这段代码里面既使用了LNode \*，也使用了Linklist。虽然这两种表示方式本质上它们是等价的，但是在这个函数当中，它最终要return，要返回的是第i个结点。所以它的这个返回值的类型，它把它定义为了LNode \*，其实它是想强调说我返回的，这是一个结点。

而这个参数L，它想强调的其实是这是一个单链表，我要从这个单链表当中找到它的第i个结点。所以虽然这儿其实可以用LNode \* L这样的方式来定义L这个参数。但是由于这个地方，它想强调的并不是说L它是一个结点，而是要把它看成一个单链表，因此它才使用了这样的命名方式。

这个大家可以好好体会一下，因为我们的课本当中很多示例代码，这两种表示方式都会出现。如果这个地方没理解的话，
那大家在看代码的时候可能会觉得很懵，为什么有的地方用左边这种方式，而有的地方用右边这种方式？其实主要就是在这个代码当中，它想强调的点是不一样的，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920202203865.png" alt="image-20240920202203865" style="zoom:50%;" />

比如大家可以看一下自己的课本，这个头插法，建立单链表，它里边就使用到linked list。也使用到了air node新。所以这个小细节还是值得注意的。在我们之后学习的一些数据结构当中，比如说像树这种数据结构，它也会采用类似这样的重命名的方式和方法。所以这个地方希望大家好好体会好，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920202655757.png" alt="image-20240920202655757" style="zoom:50%;" />

## 不带头结点的单链表

那接下来我们来看一下怎么初始化一个单链表，我们先看不带头结点的单链表。首先声明一个指向单链表的指针L，那其实本质上这个指针它是指向某一个节点的，对吧？只不过这地方我们想强调的是，它指向的是一个单链表。所以我们用linklist这个别名来定义好，那执行这一句之后，内存当中会开辟一小片空间呃，用于存放这个头指针L。

好，那再往后执行，我们这儿的初始化函数，这个初始化函数很简单，就是把L的值设为null用，这样的方式表示当前它是一个空表。做这个操作是为了防止这小片内存当中以前有遗留的脏数据，另外当我们传入这个指针变量的时候，我们是传入了它的引用。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920203643975.png" alt="image-20240920203643975" style="zoom:50%;" />

因为如果没有这个引用符号的话，那么在这个函数里边修改的所谓的l其实是这个头指针l的一个复制品。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920203709803.png" alt="image-20240920203709803" style="zoom:50%;" />

好，那对于这种不带头节点的单链表判断它是否为空的依据，就是看它的这个头指针L此时是不是等于null如果等于null的话，说明此时是空的。当然，这段代码还可以，写的更简洁一些，直接return L=null，因为这个条件判断它的运算结果本身就是true或者FALSE，所以你直接把它return就可以了。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920203749272.png" alt="image-20240920203749272" style="zoom:50%;" />

### 代码

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

bool InitList(LinkList &L) {
    L = NULL;
    return true;
}

int main() {
    LinkList L;
    InitList(L);

    return 0;
}
```



## 带头结点的单链表

好，那这是不带头结点的情况，接下来来看带头结点的情况，前面的步骤一样，先声明一个指针L指向一个单链表。在它的初始化函数当中，会用malloc申请一片空间，可以存得下这样的一个结点。并且把malloc返回的地址赋给L，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920204604958.png" alt="image-20240920204604958" style="zoom:50%;" />

也就是说头指针L是指向了这个结点，接下来需要把L这个指针指向的结点当中next。这个指针域把它设为none，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920204759313.png" alt="image-20240920204759313" style="zoom:50%;" />

也就是这个样子，那这个头结点是不存储数据的。我们加这个头结点只是为了之后在实现某一些基本操作的时候会更方便一些，好，那对于这种带头结点的单链表要判断它是否为空的话。那我们要判断的就是这个头结点的next指针域，它是否等于none？如果它等于none的话，那它就是空的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920204855388.png" alt="image-20240920204855388" style="zoom:50%;" />

### 代码

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *Linklist;

bool InitList(Linklist &L) {
    L = (LNode *) malloc(sizeof(LNode));
    if (L == NULL) {
        return false;
    }
    L->next = NULL;
    return true;
}


int main() {
    Linklist L;
    InitList(L);
    return 0;
}
```



好，那单链表的这两种实现方式有什么区别呢？简单来说就是如果不带头结点的话，写代码会更麻烦一些，如果带头结点的话，那。写代码会更方便一些，
所以大多数情况下我们都会用带头节点的这种方式来实现我们的代码。而为什么这样？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920205258758.png" alt="image-20240920205258758" style="zoom:50%;" />

我们会用下一小节用具体的代码，让大家亲自感受一下，在这个小节中，我们只需要知道，如果不带头结点的话，那么头指针它所指向的。下一个结点，这个结点就是实际用于存放数据的结点，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920205344723.png" alt="image-20240920205344723" style="zoom:50%;" />

而如果带头结点的话，那么头指针它所指向的这个结点。把它称为头结点，这个头结点是不存放实际的数据元素的，只有这个头结点之后的下一个结点。
才会用于存放数据。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920205447104.png" alt="image-20240920205447104" style="zoom:50%;" />

好的，那这个小节中我们学习了怎么定义一个单链表？单链表其实就是用链式存储的方式实现了线性结构。各个数据元素的先后关系是用节点里边的指针域来表示的，然后需要注意单链表的实现方式，分为带头节点和不带头节点那两种实现方式，它们呃，对于空表的判断条件是不一样的。另外，对于C语言基础不太好，还有跨考的同学，希望大家通过这个小节能够呃理解type define这个关键字，它到底是什么意思？然后之后看代码的时候呃，
要注意什么地方应该用link list，什么地方应该用air node新这样的方式，虽然它们俩是等价的。希望大家在刚开始学习这部分内容的时候，把这些细节给理解透彻了，这样之后的理解吸收速度才会越来越快。好的，那以上就是这个小节的全部内容。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240920205607371.png" alt="image-20240920205607371" style="zoom:50%;" />