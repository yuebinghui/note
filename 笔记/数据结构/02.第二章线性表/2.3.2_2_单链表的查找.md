各位同学大家好，在这个小节中我们会学习单链表的查找操作，怎么实现分为按位查找和按值查找，那在这个小节中我们探讨的所有的代码都是基于。带头节点的这种单链表不带头节点的单链表应该怎么实现？有什么区别？这也是大家应该主动思考的问题。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240922205208128.png" alt="image-20240922205208128" style="zoom:50%;" />

好，那首先来看，按位查找怎么实现？那所谓按位查找，就是你要找到l这个单链表当中的第i个节点，把这个节点给返回好，那上一小节中，我们在按位插入和按位删除这两个基本操作里边。其实已经实现了按位查找相关的代码逻辑，
只不过上一小节当中，我们是找到第i减一个结点。那代码是不是类似的？如果我们要找的是第i个节点的话，把这个地方改成i不就行了。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240922205415062.png" alt="image-20240922205415062" style="zoom:50%;" />

好，那所以要找到一个单链表l当中的第二个节点就很简单了。首先要判断一下这个I的值是否小于零，如果小于零的话，那返回一个null，因为我们这儿讨论的是带头结点的这种情况，所以我们可以把头结点认为是第零个结点。因此，如果此次传入的参数I=0的话，那么首先经过上面这一系列执行p指针会指向头结点。
而j的值等于0I的值，此时也是零，所以这个条件是不满足的，因此会直接跳过这个循环，直接返回当前p指向的这个结点，也就是返回这个头结点。好，那这是一种极端情况，再来看另一种极端情况，如果I的值大于链表的实际长度，比如说I=8的话，那么来分析一下这个代码，首先这个p它是指向了头结点。然后j的值刚开始是零好，第一轮循环之后p指针指向下一个结点j的值变为一，
第二轮循环p再往后指一个结点j的值变为二。第三轮循环p指向第三个结点，然后j的值变成三，第四个循环是这样，第五个循环是这样子。好，那接下来是不是循环的这个条件不满足，于是循环结束返回p指针，此时指向的这个值，也就是返回一个n。所以你看，当I值不合法的时候，它最终返回的值就是一个null。因此，如果别人调用你这个基本操作的话，
那它是不是只需要判断一下此次的返回值是不是等于null？它就可以知道这次的按位查找操作到底是否执行成功了，那这些边界情况都是我们在写程序的时候必须考虑到的，要让我们的这个算法具有健壮性。好，那接下来如果I=3的话，那这个分析起来也是一样的，即便是初学者，只要耐下性子来，肯定可以分析出这个代码执行的过程。那很显然，按位查找这个操作，它的平均时间复杂度应该是on这个数量级，那所谓平均情况就是指我们此次输入的这个I值。它取得合法范围内的任何一个数字的概率都等可能的这种情况，
那具体的算法其实和顺序表的按位查找那种分析的方法是一样的，这儿就不再赘述。那王道书里给的按位查找它的代码，实现和我们这儿有一点点不同，但是实现的最终效果都是一样的。课本里面的这个代码，首先是把j的值设为一，也就是说p结点，它刚开始并不是指向第零个结点，而是指向了第一个数据结点。然后接下来才判断，如果I的值等于零的话，那给它返回l，也就是给它返回头结点，那之后的处理逻辑都是一样的，
让p指针依次往后移。然后j的值也依次递增。那大家可以暂停来理解一下，这段代码好，那既然我们在这儿实现了按位查找的基本操作，那上一小节当中按位插入和按位删除是不是就可以直接调用我们的基本操作来实现？因为在这两个地方，我们都是要找到第i- 1个结点嘛，所以在这个地方，大家应该又可以体会到这种封装，或者说实现一些基本操作，它有什么好处了？当我们把一些常用的功能封装起来之后，我们可以避免重复代码，并且我们的代码会更简洁，
而且更易维护。那代码更简洁，很容易理解，更易维护是什么意思呢？好来想一下，如果我们没有实现这个基本操作，而是按照之前的那种方式来找到第二减一个结点的话，那么在插入这个函数里边，我们需要写一份这个代码。在删除这个函数里边，我们还需要再写一份这个代码，那假设某一天你发现你写的这一段代码，它本身逻辑就是有问题的，有bug的。那这个时候你要维护你的这个代码，
是不是你既要修改这个函数里边的，也需要修改这个函数里边的？而如果你把最常用的这些操作都把它封装成函数，封装成一个基本操作的话，那么如果你发现你的基本操作代码实现有问题，那你只要改了这个get a limp函数里面的代码，是不是所有的？的地方都会受到影响，就都可以得到修正，所以写代码不多的同学可以好好体会一下啊，这儿提到的这些思想。虽然考试不考，但是这些东西肯定是大家以后能够用到的好，那如果再加上我们上个小节当中实现的这个后插操作的话，我们的这个按位插入是不是只需要调用这样的两个函数就可以完成了？
第一个函数找到了第i- 1个结点，也就是此次要插入的这个位置的前驱结点。然后第二个函数会在这个前驱节点之后插入数据元素e那上一小节当中，当我们在实现后插操作的时候，我们在这儿对p指针进行了一个判断。如果p指针等于none的话，会返回一个FALSE。不知道有没有同学注意到，可能在学上一小节的时候，也许会有同学有疑问，会觉得说怎么可能有人在调用这个函数的时候给你。故意传入一个空指针呢。写这段代码有必要吗？但是如果在左边这种情况下，这个条件判断就会显得十分重要。
因为刚才我们说了，如果说此次传入的这个I值不合法的话，那么get all这个函数的返回值应该是会返回一个none，对吧？所以p指针有可能是指向null的，那接下来你再往这个函数里传入p指针的话，是不是就说明其实这种情况是有可能发生的？当p=null的时候，说明第i- 1个结点是不存在的。在这种情况下，直接返回一个FALSE表示后插操作失败。那这个按位插入的操作，直接return这个函数的返回值，也就是说它也会返回一个FALSE，那是不是就意味着这个按位插入也失败了？
所以你看尽可能的提高代码的健壮性，其实是很有必要的，不要觉得这些边边角角的判断很麻烦。这些边界情况才是我们的程序最容易出bug的地方。那希望大家好好体会封装和健壮性的重要性好，那接下来我们要学习怎么实现按值插入，也就是给你一个数据元素e，然后看一下在你的这个单列表当中有没有哪个结点的值是等？等于e的那这个代码很简单，那我们假设这个我们这儿的所谓I li m tap，它是int型的变量。然后这次传入的e这个变量，它等于八的话，那首先会让一个p指针指向头结点的，下一个结点。
也就是指向第一个数据结点之后进行while循环，此时p不等于null是满足的，并且p这个结点的数据域它的值。不等于e的值，也就是不等于八，因此会让p指针指向下一个节点，接下来要进行第二轮循环。但是由于p节点当中存储的这个数据。它的值和e的值是相等的，所以循环条件不满足，因此会执行之后的依据，也就是return这个p指针。因此，会跳出循环，把这个p结点给返回，
这样的话，我们就找到了一个和给定的元素值相等的结点。好，再来看一个不能找到结点的情况，如果e的值此次传入的是六的话，那么和刚才一样，通过这个while循环的执行p指针会一次一次的往后移。一直移到最后面这个位置，当p指向n的时候，这个条件得不到满足，于是跳出y循环，然后返回p。也就是返回一个null那当这个函数的调用者接收到null的时候就说明并不存在数据域等于六的结点。好，那刚才我们是假设这个allen type数据元素的类型是int类型，
那我们对struct类型的呃相等的判断是不是就不能用这个操作符？这一点我们在之前的小节中强调过，大家可以再回忆一下如何比较两个struct类型，它是否相等。这儿就不再重复好，那由于按值查找操作，只能从第一个节点开始用这个循环依次的往后扫描p指针，所以很显然这个算法它的时间复杂度应该是on这个数量级。那这是暗值查找好，最后我们再来看一下怎么求一个单链表的长度，其实实现的核心是不是一样的？就是让这个p指针依次往后移，然后我们用一个变量依次累加来记录这个表到底有多长。最后再返回这个值，那大家可以快速的思考一下，
如果不带头结点的话，怎么统计这个表的长度代码的实现，会不会有哪些不同？那由于求表长这个操作也需要用while循环，让p指针从头到尾依次扫描，因此它的时间复杂度肯定也是on这个数量级。好，那这个小节我们学习了，怎么实现单链表的查找操作，分为按位查找和按值查找，然后如果要求单链表的长度的话，其实核心的代码和上面的这两个查找操作是一样的。最重要的就是要会写那个循环，让p指针从头到尾依次扫描各个节点，那大家学了单链表的按位查找之后，
可以回忆一下。顺序表的按位查找它是怎么实现的？由于单链表不具备随机访问的特性，所以对单链表的查找操作，它只能依次的从头往后扫描。因此，时间复杂度肯定都是on，当然这儿我们指的是平均情况和最坏情况。好的，那以上就是这个小节的全部内容。