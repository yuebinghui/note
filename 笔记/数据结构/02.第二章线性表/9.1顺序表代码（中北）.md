概念也要看看，不过后面看把，要记忆的

学姐有王道电子书，可以要下

学习一个题目，最好要会画出它的手动过程，这样你记忆代码逻辑根号记忆

记住length是顺序表当前有多少个元素 maxsize是顺序表可以放多少个元素

第二章所有的代码都要掌握，会写

第二章都会考到，第二章不管考哪个学校都是重点，学姐的第二章里有一部分王道的课后题

# 线性表

## 线性表的顺序表示-顺序表

###### 顺序表的初始化和插入

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    return true;
}

// i是位序 从1开始
// 数组下标从0开始
// 比如MaxSize 是10
// 比如要插入的i是3

bool InsertList(SqList &L, int i, ElemType e) {
    // 这里小于1是因为位序从1开始，不能比1小
    /*
        i > L.length+1 是因为比如我数组有5个元素，L.length为5，我索引是 0 1 2 3 4
        比如插入一个100，位序是8，那么如果没有 i > L.length+1 这个条件，就会把100插入到索引为7的位置
        值   1 2 3 4 5 空 空 100 空 空
        索引 0 1 2 3 4 5  6  7   8  9
        就会造成这样的空隙
        所以当一共有5个元素，此时索引是0~4，
        那么你位序最多插入的就是<=L.length的位置，即1 2 3 4 5
        也就是位序大于5就会产生空隙了，就不能插入
     */
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    // 我数组已经满了，就不插入元素了
    if (L.length >= MaxSize) {
        return false;
    }
    // j=L.length 就是第一次执行的时候，先把索引为L.length的位置里放入索引为L.length-1的元素
    for (int j = L.length; j >= i; j--) {
        // 就是把前一个元素数据放到后一个元素里
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    // 插入一个元素后length++
    L.length++;
    return true;
}

int main() {
    SqList L;
    InitList(L);


    return 0;
}
```

###### 1. 将两个有序顺序表合并为一个新的有序顺序表，并由函数值返回结果

就是函数返回类型那里，除了常见的int float bool 还可以返回自己自定义的struct结构类型数据

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927141858410.png" alt="image-20240927141858410" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// 将两个有序顺序表合并为一个新的有序顺序表，并由函数值返回结果
bool Merge(SqList L1, SqList L2, SqList &L3) {
    // 两个表相加的长度不可以大于 L3的最大长度，放不下
    if (L1.length + L2.length > L3.maxSize) {                        
        return false;
    }
    // i是L1的索引 j是L2的索引 k是L3的索引
    int i = 0, j = 0, k = 0;

    // 1️⃣遍历L1 和 L2，从0到length，就是遍历整个L1或者L2 哪个表Length短就先遍历完
    while (i < L1.length && j < L2.length) {
        // 拿L1和L2的第一个元素去作比较，哪个小哪个先放入L3
        if (L1.data[i] <= L2.data[j]) {
            // 先把L1的第i个元素放到L3的k的索引上，然后k++ i++
            L3.data[k++] = L1.data[i++];
        } else {
            // 先把L2的第j个元素放到L3的k的索引上，然后k++ j++
            L3.data[k++] = L2.data[j++];
        }
    }

    /*
     检查看L1是否没有遍历完成，没有的话，就把L1剩下的数据，都依次放到L3中
     下面的两个while循环只会执行其中一个，因为1️⃣处那里的条件就是以L1或者L2其中一个遍历完成为结束条件的
     */
    while (i < L1.length) {
        L3.data[k++] = L1.data[i++];
    }
    // 检查看L2是否没有遍历完成，没有的话，就把L2剩下的数据，都依次放到L3中
    while (j < L2.length) {
        L3.data[k++] = L2.data[j++];
    }
    // 最后把k赋值给L3的length
    L3.length = k;
    return true;
}

int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1, j = 1, k = 1; i <= 10; ++i) {
        if (i % 2 == 1) {
            InsertList(L1, j++, i);
        } else {
            InsertList(L2, k++, i);
        }
    }

//    print(L1);

//    print(L2);

    Merge(L1, L2, L3);
    print(L3);


    return 0;
}
```



不懂就自己画图理解

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927144014418.png" alt="image-20240927144014418" style="zoom:30%;" />

###### 2. 将顺序表L1中的数据分类，奇数放到L2中，偶数放到L3中

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 将顺序表L1中的数据分类，奇数放到L2中，偶数放到L3中
bool split(SqList L1, SqList &L2, SqList &L3) {
    int i, j, k;
    i = j = k = 0;

    // 遍历L1这个顺序表
    for (; i < L1.length; ++i) {
        //判断当L1的元素是奇数的时候
        if (L1.data[i] % 2 == 1) {
            // 赋值给L2并且让L2的索引++，后加加
            L2.data[j++] = L1.data[i];
        } else {
            // 如果是偶数，赋值给L3并且让L3的索引++，后加加
            L3.data[k++] = L1.data[i];
        }
    }

    L2.length = j;
    L3.length = k;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }

//    print(L1);
    split(L1, L2, L3);
//    print(L2);

    print(L2);
    print(L3);


    return 0;
}
```



<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927151502394.png" alt="image-20240927151502394" style="zoom:30%;" />

###### 3. L1，L2分别存放两个整数集合，实现L1与L2的交集存放在L3中

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// L1，L2分别存放两个整数集合，实现L1与L2的交集存放在L3中

// 方法1
void intersection(SqList L1, SqList L2, SqList &L3) {
    int i, j, k;
    i = k = 0;
    // 遍历L1这个顺序表
    for (; i < L1.length; i++) {
        for (j = 0; j < L2.length; j++) {
            if (L1.data[i] == L2.data[j]) {
                L3.data[k++] = L1.data[i];
            }
        }
    }
    L3.length = k;
}

// 方法2
//void intersection(SqList L1, SqList L2, SqList &L3) {
//    int i, j, k;
//    i = k = 0;
//
//    // 遍历L1这个顺序表
//    for (; i < L1.length; i++) {
//        // 重置j 不然在一次while循环进入条件的遍历后，j的值会j++ 加上去，当i=2进来的时候没有重置j为0会有问题
//        j = 0;
//        // 遍历L2这个顺序表 并且 找L2里与L1相等的元素，如果不等就j++，直到找到相等的，或者遍历完整个L2顺序表
//        while (j < L2.length && L1.data[i] != L2.data[j]) {
//            j++;
//        }
//        // 看上面的while循环是不满足 && 左右哪边的条件，如果是不满足右边的条件跳出循环的，说明有交集，就要赋值给L3
//        if (j < L2.length) {
//            L3.data[k++] = L1.data[i];
//        }
//    }
//    L3.length = k;
//}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

//    print(L1);
//    print(L2);
    intersection(L1, L2, L3);

    print(L3);
    return 0;
}
```

###### 4. 将顺序表L中所有奇数调整到表的左边，所有的偶数调整到表右边

从左往右找，找到不是奇数就停了，
从右往左找，找不到不是偶数就停了，
然后两个交换位置



结束条件有两种情况，第一种是i==j，不满足条件就跳出循环了，另一种是i>j这种情况，这两种情况都是结束

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928183811355.png" alt="image-20240928183811355" style="zoom:50%;" />



1处：
因为左边放的是奇数嘛，所以我找到偶数就停了
因为右边放的是偶数吗，所以我找到奇数就停了
然后把此时i 和 j 的索引的数据元素交换位置
然后换完后，我就i++ j++一下

然后再次循环，执行1处的步骤

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 方法2
void adjustOddEven(SqList L) {
    int i, j;
    ElemType x;
    i = 0;
    j = L.length - 1;
    while (i < j) {
        if (i < j && L.data[i] % 2 == 1) {
            i++;
        }
        if (i < j && L.data[j] % 2 == 0) {
            j--;
        }

        if (i < j) {
            x = L.data[i];
            L.data[i++] = L.data[j];
            L.data[j--] = x;
        }
    }
    printf("i=%d j=%d\n", i, j);
}

// 将顺序表L中所有奇数调整到表的左边，所有的偶数调整到表右边
void change(SqList &L) {
    int i, j; // 两个索引分别指向顺序表头尾
    ElemType x; // 用来临时存放数据的元素
    i = 0; // i指向顺序表头部
    j = L.length - 1; // j指向顺序表尾部

    do { // 先执行代码，再判断条件 当不满足i<j时停止循环
        while (i < j && L.data[i] % 2 == 1) { // 当前位置是奇数就继续看下一个位置，在偶数的时候停下
            i++;
        }
        while (i < j && L.data[j] % 2 == 0) { // 当前位置是偶数就继续看下一个位置，在奇数的时候停下
            j--;
        }
        /*
            i<j说明i是偶数，j是奇数，所以交换位置
            二者相等，的话同一个数字不需要换
         */
        if (i < j) {
            x = L.data[i];
            L.data[i++] = L.data[j];
            L.data[j--] = x;
        }
    } while (i < j);


}

int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

//    print(L1);
    change(L1);
    print(L1);

//    print(L2);

//    print(L3);
    return 0;
}
```

###### 5. 顺序表就地逆置

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928190955656.png" alt="image-20240928190955656" style="zoom:40%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 顺序表就地逆置
void Reverse(SqList &L) {
    int i, j; // 定义两个标记
    i = 0; // 指向表头
    j = L.length - 1; // 指向表尾
    ElemType x;
    while (i < j) { // 如果i++ j--两个慢慢靠近，j=i或者i>j停下
        x = L.data[i];
        L.data[i++] = L.data[j];
        L.data[j--] = x;
    }
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

    Print(L1);
    Reverse(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 6. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928192831811.png" alt="image-20240928192831811" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1);
void Reverse(SqList &L) {
    ElemType temp; // 暂存数据
    for (int i = 0; i < L.length / 2; ++i) { // 将数组对半掰开，只遍历一半 两两互换
        temp = L.data[i];
        L.data[i] = L.data[L.length - 1 - i];
        L.data[L.length - 1 - i] = temp;
    }
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

    Print(L1);
    Reverse(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 7. 对于长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，改算法删除线性表中所有值为x的数据元素

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928200845984.png" alt="image-20240928200845984" style="zoom:50%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 对于长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，改算法删除线性表中所有值为x的数据元素
void Delete_x(SqList &L, ElemType x) {
    int i, k;
    i = k = 0;
    // i删除前叫原表，k删除后叫新表，但其实都是在一个表里操作的，索引不同
    for (; i < L.length; ++i) {
        // 遍历原表，如果不等于x，就把不等于x的数存到索引为k的表里，就是换了个索引，还是在用一个表里
        // 如果匹配到x了，这个循环什么操作都不做
        if (L.data[i] != x) {
            //因为是在同一个表中操作的，所以空间复杂度就是O(1)，只不过是把原来的索引i变成了k
            L.data[k++] = L.data[i];
        }
    }
    L.length = k; //给顺序表赋值新表表长
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    int arr[10] = {1, 8, 3, 4, 5, 8, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_x(L1, 8);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 7.1 7.0的第二种解法

原表索引为i
k记录有多少个x元素
新表里存的是没有x元素的个数，所以就是L.length - k

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928203935481.png" alt="image-20240928203935481" style="zoom:50%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 对于长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，改算法删除线性表中所有值为x的数据元素
// 解法2
void Delete_x(SqList &L, ElemType x) {
    int i, k;
    i = k = 0;

    while (i < L.length) {
        if (L.data[i] == x) {
            k++; // k记录等于x的元素的个数
        } else {
            L.data[i - k] = L.data[i]; //当前元素前移k个位置
        }
        i++;
    }
    L.length = L.length - k; // 顺序表长度减去k
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    int arr[10] = {1, 8, 3, 4, 5, 8, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_x(L1, 8);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 8. 从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同

我让i=0，j=1，我要看i和j所指的元素是否相同，如果相同就删除一个，不同就往后走

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928204443301.png" alt="image-20240928204443301" style="zoom:50%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同
bool Delete_same(SqList &L) {
    if (L.length == 0) {
        return false;
    }
    int i, j; // i存储第一个不相同的元素，j作为工作指针
    for (i = 0, j = 1; j < L.length; j++) {
        // 如果i和j的值不相等了，就让i指针先往后移动一位，然后存入j的值
        // 如果i和j的值相等，那么就让j往后走，直到遇到不等的，再让i指针先往后移动一位，然后存入j的值
        if (L.data[i] != L.data[j]) { // 查找下一个与上一个元素不同的值
            L.data[++i] = L.data[j];
        }
    }
    L.length = i + 1;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_same(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 9. 从顺序表中删除其值在给定值s与t之间（要求s<t，包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行

就是s与t，比如我要删除值为2~7中间的所有元素，包含2和7，那么s就是2，t就是7

<video src="/Users/yuebinghui/Desktop/屏幕录制2024-09-29 15.46.35.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 从顺序表中删除其值在给定值s与t之间（要求s<t，包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行
bool Delete_s_t(SqList &L, ElemType s, ElemType t) {
    if (L.length == 0 || s >= t) {
        return false;
    }
    int i, k;
    i = k = 0;
    for (; i < L.length; i++) {
        if (L.data[i] >= s && L.data[i] <= t) { // 如果你L.data[i]在这个范围内我就不要你
            k++;
        } else { // 不在这个范围内的i项我才赋值给你 i-k
            L.data[i - k] = L.data[i]; // 当前元素，往前移动k个位置，因为我忽略了k个元素
        }
    }
    L.length -= k;// k是多少，说明有多少个在[s,t]区间内的元素，也说明删除了k个
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_s_t(L1, 2, 7);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 10. 从有序顺序表中删除其值在给定值s与t之间（要求s<t，包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行

我找到这个区间后，光把这个区间删除就好了



<video src="/Users/yuebinghui/Desktop/屏幕录制2024-09-29 16.52.49.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 闭区间即包含s t
// 从有序顺序表中删除其值在给定值s与t之间（要求s<t，包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行
bool Delete_s_t(SqList &L, ElemType s, ElemType t) {
    if (L.length == 0 || s >= t) {
        return false;
    }
    int i, j;
    // 找到第一个大于等于s的元素 因为要去掉[s,t]内的元素
    // 所以一会要覆盖掉这个等于s的元素
    for (i = 0; i < L.length && L.data[i] < s; i++);
    if (i >= L.length) return false;// 说明都比s小，不用删除
    // 找到第一个大于t的元素，要找到大于的元素
    // 因为下面要把[s,t]范围外的元素放到新表里
    for (j = i; j < L.length && L.data[j] <= t; j++);

    for (; j < L.length;) {
        L.data[i] = L.data[j];
        j++;
        i++;
    }
    L.length = i;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[7] = {1, 2, 3, 4, 5, 6, 7};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_s_t(L1, 3, 5);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

## 线性表的链式表示-链表