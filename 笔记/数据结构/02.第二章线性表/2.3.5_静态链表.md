各位同学大家好，在这个小节中我们会学习静态链表相关的内容，我们会介绍什么是静态链表，怎么用代码定义一个静态链表？并且会简单的介绍怎么实现静态链表相关的那些基本操作，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240924204948943.png" alt="image-20240924204948943" style="zoom:50%;" />

那首先来看一下什么是静态链表，那之前我们已经学过单链表。单链表中的各个节点，它是离散的分布在内存中的各个角落。每一个节点会存放一个数据元素，还有指向下一个节点的指针，也就是下一个节点在内存当中的存放地址。

而静态链表是要分配一整片的，连续的内存空间。各个数据元素存放在这一整片空间中的其中某些位置。静态链表中的每一个结点包含了数据元素，还有下一个结点的数组下标，来看一下什么意思？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240924205156902.png" alt="image-20240924205156902" style="zoom:50%;" />

在静态链表中，数组下标为零的这个结点。它充当了头结点的角色，也就是说，这个结点当中，它是不存放实际的数据元素的，而头结点的下一个结点，它是存放在数组下标为二的这个位置。也就是说，这个结点就是第一个数据结点，也就是位序为一的结点，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240924205442326.png" alt="image-20240924205442326" style="zoom:50%;" />

那再往后的结点就是数组下标为一的结点，也就是上面这个结点。
所以静态链表中的这个数组下标或者呃也有的地方把它称为游标，这个东西它充当的角色其实和单链表当中的指针。是差不多的，只不过指针是指明了具体的内存地址，而这个地方的游标只是指明了下一个元素，它的数组下标。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240924205600534.png" alt="image-20240924205600534" style="zoom:50%;" />

那单链表的表尾元素，它的next指针是指向null的，在静态链表当中，如果要表示这个结点，它是最后一个结点的话，那么它的这个游标的值。可以设为负一。这就表示，在这个结点之后，已经没有其他结点了。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240924205718332.png" alt="image-20240924205718332" style="zoom:50%;" />

好，那由于静态链表当中存放各个节点的这些空间，它们是连续的，所以如果说一个静态链表，它的这个数据元素占四个字节游标也占四个字节。也就是说，这一整个的呃节点，它需要占八个字节的话，那假设静态链表的起始存放地址是这个地址。那数组下标为二的那个结点，它的存放地址就应该是零号结点的存放地址，加上每一个结点的大小乘以。接下来要寻找的这个节点的啊，数组下标。
那用这样的方式，是不是就可以把静态链表当中的游标，或者说数组下标把它映射成某一个数组下标所对应结点的？实际存放地址。那这就是静态链表的一个基本原理。好，那怎么用代码定义一个静态链表呢？其实应该很容易想到我们可以定义一个结构体啊，叫做node，然后每一个node，也就是每一个节点里边。它包含了一个数据元素data，还包含了下一个节点的游标，或者说数组下标。那这个数组下标可以用一个int型来表示。
好，那这是静态链表的一个结点，那我们需要的是多个连续存放的结点，那我们可以用数组的方式来定义，来声明它。就像这样，我们定义一个数组a，这个数组a有max size，也就是有十个数组元素，然后每一个数组元素的类型都是。draft node也就是我们上面定义的这样的一个节点，所以用这样的方式声明一个数组的话，那么这个数组a其实就是占用了内存当中这样的一整片连续的存储空间。那这是我们自己比较容易想到的一种定义方法，我们的课本当中给了另外一种写法，
课本上给的这种代码的写法还挺少见的，我刚开始看的时候也没弄明白它这个是什么意思？它这用了type define，然后在这个部分说明了你的struct结构体里边包含了哪些字段，一个data和一个next。然后后面跟了一个看起来像是数组的一个东西。后来我自己写了一些代码之后，发现它这种定义方式其实就等价于说你先定义一个结构体，这个结构体的名字叫struct node。然后你再把这个结构体struct node用type define，给它重命名。不过这个地方，它跟的是一个看起来像是一个数组的东西，用这儿给出的这种写法，你之后用s link list去定义一个呃变量a的话。
那么，当你声明这个变量a的时候，其实这儿的a你是声明了一个数组，这个数组的元素个数有max size这么多，也就是有十个元素。而每一个数组元素就是这样的一个struct node，也就是你这定义的这样的一个结构体，它等价于你用这样的方式声明a这个数组。反正我问了身边好几个经常用CC加加的同学，很少有人见过这样的一种定义方式啊，这儿希望大家可以暂停来体会一下。诶，那为什么课本中要用这样的方式来定义静态链表，用我们熟悉的这种数组的方式来定义静态链表，难道它不香吗？
其实这个地方和我们之前学习单链表的时候提到过的linked list，还有air node星是完全相通的，因为其实我们在这个地方想定义的所谓的a这个东西。它是一个静态链表，但是如果用下面的这种方式来定义a的话，那么我们从代码的这个角度来看，会觉得说a它看起来是一个呃node型的数组。而上面的这种定义方式，虽然效果上和下面这种是等价的，不过上面这种定义方式，你一看这个代码，你就知道a这个东西，它是一个静态链表。所以这个地方这种比较少见的type define的用法，也希望大家能够了解它的原理是什么？
我写了一小段程序验证过刚才的那种猜想。这我用了，我们比较容易想到的那种方法来定义了一个struct node，里面包含了两个int型的变量，然后下面这个地方我用了课本中的那种方式。使用了type define，然后后面跟了一个类似于数组一样的东西。max size的值是十，然后在这个函数里边首先声明了一个struct node，也就是一个结点x。然后在这个地方打印输出一个结点的大小，也就是用size off关键字，然后可以看到一个结点，它是八个字节这么大。然后在这个地方，
我们用我们比较熟悉的方式定义了一个数组a，这个数组a的大小是max size，也就是有十个元素，然后每一个元素，它就是一个struct node。那由于每一个元素的大小是八个字节，所以数组a的大小用size off测出来就应该是80个字节这么大小。然后在最后这个地方，我声明了一个变量b这个b的类型是s link list，然后也用size of测出了b的大小啊，发现它也是80，也就说它和a是一样的。所以这就说明，当我们声明这个变量b的时候，其实它在背后它是一个大小为十的数组，
并且数组元素每一个数组元素是这样的一个struct。其中包含了一个data和一个next，那由于每个int型的变量都是四个字节。所以这样的一个struct，它应该是八个字节的大小，和我们这测出来的结果是一样的。那这小段程序的这个运行结果就证明了刚才提出的那种猜想。好，那现在我们已经声明了一个静态链表，接下来来看一下这个静态链表相关的一些基本操作，应该做一些什么事情？首先声明了它之后肯定需要对它进行初始化。那么，我们在单链表当中初始化一个单链表的时候，需要把这个头节点的next指针指向那，
所以对应到这个静态链表里面的话，我们在初始化的时候肯定需要把。这个头结点也就是a0这个结点的next，把它设为负一，因为负一其实等价于n嘛，就是它没有指向任何一个元素。好，那在静态链表当中，如果我们要查找某一个位序的结点的话，那我们肯定只能从这个头结点出发，通过这个游标记录的这些线索。依次的往后寻找后一个结点，然后直到找到我们想要的那个结点为止。所以在这种静态链表当中，如果你要找到某一个位序的结点的话，
那么时间复杂度应该是on这个数量级。注意，我们这儿说的是某一个位序的节点，而不是某一个数组下标的节点。位序指的是各个节点在逻辑上的顺序，而这儿的数组下标其实只是反映了各个节点在物理。以上的一个顺序。好，那这是查找操作，接下来看一下，如果要在位序为I的这个地方插入一个结点的话。那不难想到，第一步肯定是要找到一片空闲的空间，用来存放这个新的节点，对吧？
所以像这个图当中，四五七八九这些地方都是空闲的，所以可以按照某一种算法，比如说从上到下扫描啊，或者从下到上扫。扫描之类的就是找到一个此时空闲的节点，用于存放此次要存入的这个新的数据元素。第二步，既然要插入位序为I的结点，那么我们肯定需要把位序为i- 1的这个结点。它的后向指针或者说它的游标。给改了这个，其实和单链表很类似，比如说在左边这种情况下，此时已经有四个数据元素了，
那假设我们要插入位序为五的数据元素。也就是说，要在表尾插入一个新的数据元素，假设是在这个位置，那这个位置作为新的表尾，那按照第二步，我们是不是需要找到它的前驱节点，也就是第四个元素。把它的后项指针next改成四，也就是指向我们这个新结点的存放位置，然后接下来还需要把我们新结点的next。设成负一那这儿我们只是简单的提一个思路，感兴趣的同学可以自己动手实现一下代码诶，那细心的同学可能会发现刚才我们找一个空结点的时候。我们是直接用肉眼的方式就可以看到这几个地方，
他们是没有存数据的，但是从计算机的视角来看，其实内存当中的任何一个地方肯定都会有数据，只不过这些数据是脏数据而已。所以，为了让计算机识别出哪些节点，它此时暂时没有存放数据。其实，我们还应该在初始化的时候，把这些空闲节点的next把它设置为某一个特殊的值，比如说你可以设置为负二。那这样的话，你写代码的时候是不是只需要判断一下，如果它是负二的话，那么就说明此时这个结点是空闲的。
你就可以用这个节点来存放新的数据元素。所以刚才讲初始化的时候，其实我们还漏了这样的一个步骤，你要在初始化的时候把这些空闲的节点给它标记出来。好，那相应的在删除一个节点的时候，除了你要修改这些游标，这些东西之外，你是不是也需要把此次删除的那个节点把它的next给它设置为负二？用这样的方式表示，这个节点中，此时已经没有数据了，已经被回收了好。那静态链表相关的内容，我们就提这么多啊，
这个考点其实考的不是特别多，并且很少考察它的代码实现。只不过我们想通过静态链表的这些地方啊，再给大家慢慢的补充这些语言相关的一些知识点。至少你要能看得懂书上给的这种代码，它在背后到底是一个什么样的逻辑，什么样的意思？好，那总结一下静态链表呢，它其实就是用数组的这种方式实现的一个链表。虽然说静态链表的这个存储空间，它是一整片的连续存储空间，但是在这一片空间内，各个逻辑上，相邻的数据元素也可以在物理上不相邻。
各个元素之间的先后关系，这种逻辑关系是用呃这儿的游标，或者说数组下标来表示的。那在静态链表中，如果你要增加或者删除一个数据元素的话，你并不需要像顺序表那样大量的移动元素，你只需要修改相关节点的游标就可以。那静态链表和单链表一样，它也不能支持随机存取，每次只能从头结点，依次往后开始查找，另外还有一个缺点。静态链表，它的容量是固定的，不变的，
只要你声明了一个静态链表，那么它所能存放的最大容量就已经被定死了。不可以拓展。所以静态链表现在用的相对来说少一些，就早期的一些不支持指针的低级语言会用静态链表，这样的方式实现和单链表同样的功能。另外，如果在你的这个应用场景当中，数据元素的数量几乎是固定不变的，在这种情况下，用静态链表还是比较合适的。比如说大家之后学习操作系统的文件管理那一章的时候，会学到一个东西，叫做文件分配表fat。其实本质上fat它就是一个静态链表现在大家还没有学到这个地方，
所以可以先在你的操作系统的课本上做一个笔记。等你学到文件管理的时候，可以再回头来体会一下静态链表，它到底有什么作用？好的，那以上就是这个小节的全部内容。