各位同学大家好，经过上一小节的学习，相信大家已经能够动手用代码定义一个顺序表，并且能够知道顺序表应该怎么完成初始化的工作？那当一个顺序表刚开始被建立的时候，它其实是一个空表，也就是说里边并没有存任何的数据元素。

那这小节中，我们会学习顺序表的两个基本操作，我们会分别介绍怎么用代码实现这个基本操作，并且会分析。啊，这个代码的时间复杂度好，

## 顺序表的基本操作

### 插入

那首先要学习的是插入这种基本操作，<u>插入操作要实现的事情是往线性表l当中的第I个位置上插入指定的元素e。那这儿第I个位置指的是位序，也就是从一开始的</u>

那假设我们用静态分配方式实现了一个顺序表，那么这个顺序表总共可以存十个元素。假设在某一个时刻，这个数据结构当中包含了这样的五个数据元素，那这些数据元素在内存当中就应该是这么存放的，会占用顺序表的前五个位置。那由于存放了五个数据元素，所以此时这个顺序表的长度应该是五。此时，如果要进行一个插入操作，往这个线性表的第三个位置插入一个数据元素c的话，那逻辑上来看，进行这个操作之后c就变成了b的后继结点。d的前驱节点，由于我们的这个线性表是用顺序表的方式实现的，
所以需要用存储位置上的相邻关系来体现这种数学元素之间的逻辑关系。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917192135825.png" alt="image-20240917192135825" style="zoom:50%;" />

因此，如果要在第三个位置插入元素c的话，那么需要把后面的这三个元素都依次往后移，然后再把c这个元素插到第三个位置。所以如果我们在顺序表的第二个位置插入一个元素的话，那么这个顺序表当中第二个位置以及第二个位置以后的那些数据元素都得往后移一位。接下来看一下怎么用代码实现这个事情，这个小节中我们写的代码都是基于静态分配的，这种呃顺序表来实现的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917192434571.png" alt="image-20240917192434571" style="zoom:50%;" />

好来看一下，我们在这儿定义了一个顺序表，这个顺序表当中存放的数据元素都是int类型，也就是存放一个一个的整数。然后这个地方我们用函数实现了插入操作，
在main函数里我们会声明一个顺序表，并且对它进行初始化的操作，并且这个地方我们省略了一些代码，这些代码会往顺序表当中啊，存入一些数据。假设此时存入了一二四五六这样的几个数据元素，所以此时顺序表的长度应该是五好，接下来会调用我们这儿的这个函数来实现插入操作。这个函数实现的事情是往第三个位置插入数据元素三好，那之前我们说过，首先要把后续的这些数据元素都分别往后移，对吧？所以在这儿我们使用了一个。

for循环，刚开始j这个变量的值等于顺序表的长度，也就是等于五
那只要j大于等于I，也就是只要它大于等于三的话，这个循环就会一直继续。呃，每一轮循环结束之后j的值会减一
好，那首先来看一下第一次执行这个循环里边的语句的时候j的值是五对吧？所以这句代码做的事情是把data 4的数据把它放到data 5这个位置，也就是把这个数据元素往后挪一位。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917193330685.png" alt="image-20240917193330685" style="zoom:50%;" />

好，那执行了这一句之后j的值是不是会进行减减的操作，这就变成了四对吧？所以下一轮循环做的事情是会把data 3这个数据元素把它放到data 4这个位置。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917193504005.png" alt="image-20240917193504005" style="zoom:50%;" />

所以第二轮循环会把五这个数据元素往后挪一位，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917193519858.png" alt="image-20240917193519858" style="zoom:50%;" />

那第三轮循环也是一样的，会把四这个数据元素往后挪一位。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917193533310.png" alt="image-20240917193533310" style="zoom:50%;" />

跨考的同学可以自己一步一步分析一下啊，这个循环它到底是怎么执行的？它最后停在了什么地方？好，那这个循环结束之后，我们就可以往第三个位置插入我们的。数据元素，也就是三这个数字，这个地方大家一定要注意，我们这儿的函数参数I表示的是这个线性表的位序，它是从一开始的。但是实际对应到我们的数组的时候，数组的下标是从零开始的，所以我们要把数据元素放在第三个位置，实际上应该是要把它放在数组下标为二的那个地方。
这个自己做题写代码的时候一定要注意

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917193610944.png" alt="image-20240917193610944" style="zoom:50%;" />

好，那接下来由于多了一个数据元素，所以顺序表的长度length就应该加一。那到此为止，我们是不是就实现了插入这个基本操作？我们可以让我们的队友让其他人很方便的通过我们的这个函数来使用，我们自己定义的数据结构。不过，要提醒大家的是，如果你的队友在使用你给他定义的这个函数的时候，他传入的参数出现了一些问题的话，那么这段代码的运行就会出错。比如此时，你的队友调用了你的这个函数，他想往第九个位置插入三这个数据元素，
大家可以自己暂停分析一下这个代码怎么运行？当这段代码运行完了之后，三这个数据元素会被插到八这个位置，但是中间这个地方空了。这其实是不正确的，对吧？我们的顺序表当中，它的各个数据元素一定是必须一个一个相邻的存放的。所以你看这段代码，其实它是不够健壮的，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917194210356.png" alt="image-20240917194210356" style="zoom:50%;" />

怎么避免这个问题呢？很简单，我们只需要一个条件判断的语句，可以判断一下这个I的值是否合法，那I的合法值。
应该是多少呢？应该是从一开始，然后到length+1结束，对吧？如果此时有人想往顺序表的第九个位置插入元素的话。那由于这个I的值已经超出了它的合法范围，所以我们就不应该进行后续的这一系列操作。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917194523732.png" alt="image-20240917194523732" style="zoom:50%;" />

好，那再想一下，除了I的值不合法之外。

是不是当你的顺序表如果已经存满了的时候，其他人想要再插入数据，你也应该把它拒绝掉，对吧？所以当别人调用你定义的这个基本操作的时候，你还应该在代码里边检查，此时这个顺序表是否已经存满了？如果存满了，那么就不应该往里边继续插入数据好，那大家站在使用者的角度来考虑，如果。你定义的这个基本操作，让其他人使用，其他人想插入某一个数据元素，但是此时由于某些条件不满足，你又不能让他插入这个数据元素的话。那调用你这个函数的那个人，他是不是应该得到你的这个代码的某一些反馈，至少他得知道他这次调用的这个插入操作到底是？操作成功了，还是失败了，对吧？

所以其实在实际写代码的时候，除了这个代码逻辑本身要正确之外，其实大家还应该有一种意识，就是你的这个代码。让别人用起来用的很爽，那可以怎么做呢？我们可以让你的这个插入操作，返回一个布尔型的变量。

刚开始需要先进行I这个值的合法性判断，如果I这个值小于一或者大于length+1的话，那么说明此次他想要插入的这个位置本身就不合法。那在这种情况下，给它返回一个FALSE，那这样的话，这个函数的调用者在接收到FALSE这个返回值的时候，他是不是就可以知道哎，此次调用失败了。然后他就可以根据你的这个反馈去检查他自己的代码是不是出现了问题，对吧？好，

那另一个条件，如果此时这个顺序表已经存满了，那在这种情况下，这次的插入操作也应该是失败的，所以也。也需要返回一个FALSE，

那这两个条件都满足之后才可以进行，刚才我们说的那一系列的操作就是先把后续的那些元素都依次往后移。
最后，再把此次想要插入的那个元素插入到相应的那个位置，再插入成功之后再给调用者返回一个true。给他一个反馈，那用这样的方式定义一个插入操作是不是使用者使用起来也很爽？同时这个代码也有健壮性啊。那这么写的代码就是好代码。

按照这样的代码逻辑，如果此时顺序表已经满了，但是还有人调用了你这个函数，想要插入一个数据元素的话，那。他的这个操作就会被拒绝好，所以虽然这段代码逻辑非常简单，但是大家可以体会一下，
如果你自己啊，此时真的是在进行一个团队开发一个大型的项目的话。那么，你的这个代码怎么让别人用起来爽？并且别人用你的代码还不容易出错？这些思想意识应该是从刚开始学习的时候啊，就引起大家的注意的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917194856526.png" alt="image-20240917194856526" style="zoom:50%;" />

## 插入操作的时间复杂度

好的，那接下来我们来快速的分析一下，插入这种基本操作，它的时间复杂度是怎么样？那在绪论中我们学到过呃，要分析时间复杂度的话，应该关注这一段代码当中。最深层循环的啊，
这个语句在插入操作当中，只有这个for循环，所以我们来看一下这个for循环，循环的次数和问题规模n之间的关系。这儿的问题规模n指的是线性表的表长，或者说这个顺序表的表长好，那之前提到过时间复杂度分为最好最坏和平均这样的三种情况，对吧？那什么情况下，时间复杂度会最低呢？如果此时我们把数据元素插入到顺序表表尾的位置的话，那其他数据元素是不需要移位的。也就是for循环的次数是零次，那这种肯定是执行最快的一种情况，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917195405899.png" alt="image-20240917195405899" style="zoom:50%;" />

也就是当I=length+1，
就意味着此次我们是要插入到。这个顺序表的最后面那个位置，这种情况下是不是代码是这么执行的，一直往下执行这个for循环是不是就不用循环？而其他的这些语句都只需要执行一次，所以这种情况下只需要常数级的时间就可以完成这个操作。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917195459827.png" alt="image-20240917195459827" style="zoom:50%;" />

那最好的另一个极端是最坏，如果此时我们是要把新元素插入到表头的位置的话，那么就需要把原有的这n个元素全部都往后移动。也就是for循环会循环n次，所以最坏时间复杂度应该是大on这样的数量级。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917195742775.png" alt="image-20240917195742775" style="zoom:50%;" />

好，最后再来看平均时间复杂度怎么算呢？我们假设如果此次要插入的新元素插入到任何一个位置的概率都是相同的。也就是说，
此次传入的这个参数I取得一二三，一直到length+1取得这个合法范围内的任何一个数字的概率都是相同的。也就是总共有n加一个位置，是是新元素，有可能插入的，因此这个元素插入到任何一个位置的概率都应该是n加一分之一这么多。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240917195854650.png" alt="image-20240917195854650" style="zoom:50%;" />

好，那假设此次要插入的是第一个位置的话，那根据之前的分析是不是需要把后面的n个元素先全部循环的往后移位，对吧？因此I=1的时候需要循环n次，而当I=2的时候，除了第一个元素之外，后面的n- 1个元素都需要依次往后移一位。所以就需要进行n- 1次循环，
那再往后的话，以此类推，当I=n+1，也就是此次我要插入到表尾的位置的时候。那在这种情况下，循环的次数应该是零次。好，那由于I取得每一个值的概率都是相同的，所以也就意味着需要循环n次的概率是p这么多，需要循环n- 1次的概率也是p。以此类推，我们把p这个因子提出来，然后p的值是n+1嘛，然后里边的这些一一直加到n，其实就是一个简单的等差数列求和。
最后得到的结果是二分之n，这么多也就意味着平均来看，这个循环的次数应该是需要平均循环二分之n次。那相应的平均时间复杂度就应该是大o的二分之n这么多，那再一化简就应该是大on这样的一个时间复杂度。所以这是最好最坏和平均这样的三种情况，好，那接下来我们再来看一下顺序表的删除操作怎么实现，如果要删除一个元素的话，那么我们需要把这个元素后面的那些元素都依次往前移。移一位，同时要把length的值减一那用代码实现的话就是这个样子。这个删除操作当中有三个参数，第一个是要删除哪个顺序表，第二个是要删除这个顺序表当中的第几个数据元素。
第三个参数，注意它是一个引用型的参数，用这个参数把此次删除的数据元素返回。好来看一下具体的过程，假设通过之前的一系列执行，已经建立了一个这样的顺序表，它里边存了总共六个数据元素。好，那如果此时想要使用这个基本操作，删除一个数据元素的话，那首先需要定义一个和你的顺序表当中存储的这些数据元素。同类型的一个变量，那我们的这个顺序表当中存储的数据元素类型都是int类型。所以我们定一个int型的变量e，并且给它设置一个初始值负一，
那声明了这个变量e就意味着内存当中会开辟一小片的空间。用于存放e这个变量相关的数据，由于我们给它设了一个初始值，所以这片区域里边存储的数据内容。是负一这个值。好，接下来调用删除这个基本操作，要删除l这个顺序表当中的第三个元素，然后把此次删除的那个元素用e这个变量给返回。那首先在我们的这个删除操作当中，我们进行了一个I的合法值的判断，因为此时可以被删除的数据元素肯定是已经存在的。这些数据元素当中的某一个对吧？所以如果I的值落在了这个区间之外的话，那么就应该给它return一个FALSE。
也就是给这个函数的使用者一个反馈，告诉他你的这个删除操作失败了，所以在这个地方，我们用一个if语句来接收这个函数的返回值。如果他此次返回了FALSE的话，那说明我们的这次调用就已经调用失败了，那由于此时想要删除的是第三个元素。呃，所以这个I的值是合法的，因此接下来会执行下面的这一句，这句代码会把此次要删除的这个数据元素的值把它复制到e这个变量所对应的这个内存区域当中。好，那接下来就是执行一个for循环，把后面的这些数据元素依次往前移。一位最后lens的值减一，
也就是从六变成了五。那由于这个删除操作成功了，所以会给啊这个函数的调用者返回一个true，也就是这个if的条件是满足的，所以接下来会执行这个print语句。打印出这样的一个结果。好，那大家值得注意的是，这样的两个地方，首先我们定义的这个删除操作e这个变量，它是引用型的变量。我们加了这个引用符号，由于加了这个引用符号，所以在这个函数里边处理的这个变量e。其实和main函数里边定义的这个变量e在内存当中，
其实对应的是同一份数据。而如果这个e变量不是引用型，把这个引用符号去掉的话，那么在main函数里边，它声明了一个局部与main函数的变量e。并且又调用了这个删除的函数，那由于这个参数不是引用类型的，所以这个函数里边它所处理的这个变量e。其实是脉函数里边这个变量e的一个复制品，这两个变量虽然名字都是e，但是在内存当中它们对应的其实是不同的两份数据。所以如果我们没有加这个引用符号的话，那这个函数里边把此次删除的数据元素的值赋给变量e，其实是赋给了这个位置，对吧？
而my函数里边的这个变量e，其实它的值依然是保持负一没变，所以如果这个参数去掉引用符号的话。那么，在这个地方打印的e的值应该还是保持负一对吧？所以在刚开始学习数据结构的时候，一定要注意理解啊这些。加了引用符号的参数，为什么它要加引用符号？当然，包括前面l这个参数也就这个顺序表。它的前面也加了引用符号，如果这个参数l不加引用符号的话，那么main函数里边定义的这个顺序表l其实。是对应的这一份，
这一坨数据对吧？如果去掉这些引用符号，那么在这个删除函数里边处理的所谓的这个l。其实应该是这一堆数据的一个复制品，同样的道理，在这一堆数据的复制品上面执行一系列删除相关的这些逻辑操作。但是返回my函数之后，my函数里边定义的这个顺序表l，其实它的数据依然是没变的，对吧？好，所以这是大家需要注意的一个地方，另一个地方跨考的同学需要注意我们在进行删除操作的时候，把这些元素依次的往前移。第一位是先移动前面的元素，
再移动后面的元素是这样的一个移动方式，这是for循环里边的逻辑。但是在我们的插入操作当中，当我们需要把元素往后移的时候，我们是先把后面的元素先往后移，然后再移前面的元素。这个问题跨考的同学要注意好，那接下来我们来分析删除操作的时间复杂度同样的啊，在这个问题当中，所谓的问题规模n指的是。线性表或者说顺序表的表长，那其实删除操作和插入操作是非常类似的，如果我们删除的是最后一个元素的话，那么其余的元素是不需要移动位置的，也就是这个for循环的循环次数。
是零次，因此如果我们删除的是最后一个元素的话，那这就是最好的情况，只需要在常数集的时间内就可以啊运行结束。那最坏的情况应该是删除表头元素，这种情况下需要把后续的n- 1个元素全部依次往前移一格。而每移动一个元素，就会多一次循环，所以如果I=1，也就删除第一个元素，删除表头元素的话，那么循环次数就应该是n- 1次。所以最坏的情况，时间复杂度应该是on这个数量级的，最后再来看平均情况，
同样的，我们假设删除任何一个元素的概率是相同的。然后I的合法值范围应该是一到lens，也就是一到n，因为总共有n个元素嘛，你要删的肯定是这n个元素当中的其中一个。并且删除每一个元素的概率都是n分之一，这么多我们用p来表示。好，那如果I=1删除的是第一个元素的话，那么需要循环n- 1次，如果删除的是第二个元素的话，那么需要把第二个元素之后的。n- 2个元素都依次往前移，一位也就是需要循环n- 2次，
那之后的以此类推。如果I=n，也就是此次删除的是最后一个数据元素的话，那么循环的次数就应该是零次。因此，需要循环n- 1次n- 2次呃，一直到循环一次，循环零次，它们的概率都是p。那我们把循环的次数和呃每一种循环次数发生的概率p进行一个相乘相加，就可以得到一个平均情况下的啊循环次数。二分之n减一，那二分之n减一应该是on这样的一个数量级，所以删除操作的平均时间复杂度也是on这么多好，那这个小节我们学习了怎么实现顺序表的插入和删除这两个基本操作？
由于顺序表要求逻辑上相邻的元素在物理上也相邻，所以如果我们想要在某一个位置插入一个新元素的话，那么它之后的那些元素都得呃依次后移。同理，如果删除某个数据元素的话，那么那么后面那些数据元素都得依次前移，当然大家在写代码的时候别忘了更改length，这个值length表示的是。呃，顺序表当中此时存放了几个数据元素，那大家在做题或者考试的时候一定要注意审题，有的题目可能是告诉你说要删除第二个。数据元素而有的题目也有可能告诉你，说是要删除数组下标为I的数据元素，那位序是从一开始的，
而数组下标是从零开始的，所以做题的时候一定要注意这个小细节。别在这种地方丢分，另外你写的这个代码要有健壮性，所以你需要对一些必要的条件进行判断。在学习之后的一系列算法，甚至是在以后大家呃实际实习工作的时候都一定要注意这个问题，你的代码一定要足够健壮，同时还要能够让别人很方便的使用。那跨考的同学可能在写移动数据元素的for循环的时候，也许会出现问题，建议写代码写的很少，甚至没有写过代码的同学自己在稿纸上写一遍。实现这个插入和删除操作，然后最后大家一定一定要注意理解为什么有的参数是要加引用的，
为什么有的没有？那像代码健壮性，还有参数加引用这些问题，我们会在之后的讲解当中提的越来越少，所以同学们一定要在刚开始接触这些简单代码的时候。就把这些很重要的问题一遍一遍的理解，把它捋清楚，真正的吸收内化好的，那么以上就是这个小节的全部内容。