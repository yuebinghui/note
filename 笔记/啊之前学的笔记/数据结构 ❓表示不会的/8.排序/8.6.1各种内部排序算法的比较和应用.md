## 8.6 各种内部排序算法的比较及应用

### 8.6.1 内部排序算法的比较

前面讨论的排序算法很多,对各种排序算法的比较是考研常考的内容。
一般基于三个因素进行对比：时空复杂度、算法的稳定性、算法的过程特征。

#### ***从时间复杂度看：***

**<u>简单选择排序、直接插入排序和冒泡排序</u>** <u>平均情况下</u>的时间复杂度都为**O(n²)**，且实现过程也较为简单，

但<u>**直接插入排序和冒泡排序 **</u><u>最好情况下</u>的时间复杂度可以达到**O(n)**，

而**<u>简单选择排序</u>**则<u>与序列的初始状态无关</u>。

**<u>希尔排序</u>**作为<u>插入排序的拓展</u>，对较大规模的数据都可以达到很高的效率，但目前未得出其精确的渐近时间。

**<u>堆排序</u>**利用了一种称为堆的数据结构，可以在线性时间内完成建堆，且在 **O(nlog₂n)**内完成排序过程。

**<u>快速排序</u>**基于分治的思想，<u>虽然最坏情况下</u>的时间复杂度会达到 **O(n²)**，但**<u>快速排序</u>**的<u>平均性能</u>可以达到 **O(nlog₂n)**，在实际应用中常常优于其他排序算法。

**<u>归并排序</u>**同样基于分治的思想，<u>但由于其分割子序列与初始序列的排列无关</u>，因此它的最好、最坏和平均时间复杂度均为**O(nlog₂n)**。

#### ***从空间复杂度看：***

**<u>简单选择排序、插入排序、冒泡排序、希尔排序和堆排序</u>**都仅需借助<u>常数个辅助空间</u>。

**<u>快速排序</u>**需要借助一个递归工作栈，<u>平均大小</u>为 **O(log₂n**），<u>当然在最坏情况下</u>可能会增长到 **O(n)**。

**<u>2 路归并排序</u>**在合并操作中需要借助较多的辅助空间用于元素复制，大小为 **O(n)**，虽然有方法能克服这个缺点，但其代价是算法会很复杂而且时间复杂度会增加。

#### ***从稳定性看：***

**<u>插入排序、冒泡排序、归并排序和基数排序</u>**是稳定的排序方法，

而**<u>简单选择排序、快速排序、希尔排序和堆排序</u>**都是不稳定的排序方法。

平均时间复杂度为 **O(nlog₂n）**的**<u>稳定排序算法只有归并排序</u>**,对于不稳定的排序方法,只需举出一个不稳定的实例即可。对于排序方法的稳定性,读者应能从算法本身的原理上去理解,而不应拘泥于死记硬背。

#### ***从过程特征看：***

采用不同的排序算法，在一次循环或几次循环后的排序结果可能是不同的，考研题中经常出现给出一个待排序的初始序列和已经部分排序的序列，问其采用何种排序算法。这就要对各类排序算法的过程特征十分熟悉，

如冒泡排序和堆排序在每趟处理后都能产生当前的最大值或最小值，

而快速排序一趟处理至少能确定一个元素的最终位置等。

表 8.1 列出了各种排序算法的时空复杂度和稳定性情况，其中空间复杂度仅列举了平均情况的复杂度，由于希尔排序的时间复杂度依赖于增量函数，所以无法准确给出其时间复杂度。



![](/Users/yuebinghui/Documents/program/github/note/images/image-20231115195759685.png)



![](/Users/yuebinghui/Documents/program/github/note/images/image-20231115200858055.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231115195841877.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231116144404411.png)

趟是什么呀？一趟就是指在你一次排序的过程中，你对整个列的所有元素。 都进行了一次操作

初始状态的4*3种影响：

所谓的4： 4种被影响内容：        ①算法复杂度②比较次数③移动次数④排序趟数所谓的

3: 3种影响的情况:             随着初始有序度的增加,      上述比较内容①增加②不变③减少。 

🌟 随着初始有序度的增加, 上述4种内容增加只有唯一一个特例：快速排序

🌟 算法复杂度与初始状态无关的有:选择排序、堆排序、归并排序、基数排序。

🌟 元素总比较次数与初始状态无关的有:选择排序、基数排序。

🌟 元素总移动次数与初始状态无关的有:归并排序、基数排序。

🌟 排序趟数与初始状态有关的有:快排、冒泡排序。

🌟 一趟算法确定一个最终位置   所有以“选最值,作为基础逻辑的算法自然可以,包括1.简单选择排序、堆排序和冒泡排序。还有一个特例: 快排。每次确定最终位置的不是最值而是基准元素的值。



 