##### 11. 按递增次序输出带头结点的单链表和各结点的数据元素

下面的视频，执行了一轮while循环，在87 88行重置指针后就没再录屏了，可以自己画画

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-05 16.40.16.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

void min_delete(LinkList &L) {
    LNode *pre = L, *p = L->next, *q; // pre为最小结点的前驱结点的指针
    while (L->next != NULL) { // 循环到仅剩头结点
        while (p->next != NULL) { // 就是p指针指到最后一个结点就不执行下面的语句了
            // p的下一个结点的数据 和 pre的下一个结点的数据比较
            // 比p比pre还小，你p就是更小的，放入pre，标记最小结点的前驱
            if (p->next->data < pre->next->data) {
                pre = p; // 记住当前最小结点的前驱结点
            }
            p = p->next;
        }
        printf("pre->next->data=%d\n", pre->next->data); // 输出最小值结点的数据
        q = pre->next; // 删除值最小的结点，释放结点空间
        pre->next = q->next;
        free(q);

        // 重置pre 和 p的指针，循环执行上面代码
        pre = L;
        p = L->next;
    }
    free(L); // 释放头结点
}

int main() {
    int A1[] = {25, 10, 7, 15, 30};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
//    print(L2);

    min_delete(L1);
    // print(L1); // 这里不可以调用这个 链表L1已经在min_delete被释放，但在print(L1)语句中仍然尝试访问已经释放的内存。

//    print(L3);


    return 0;
}
```

##### 12. 将一个带头结点的单链表A 分解成两个带头结点的单链表A和B，使得A表中含有原表中序号为奇数的元素，而B表中含有原表中序号为偶数的元素，且保持其相对顺序不变.

就是可以有多种情况，
比如A里为序号为偶，B里为序号为奇
比如A里为序号为奇，B里为序号为偶
比如A里为值为偶，B里为值为奇
比如A里为值为奇，B里为值为偶

序号就第一个结点，第二个结点
用i取余来判断，序号是奇数还是偶数，![image-20241007153424972](/Users/yuebinghui/Documents/program/github/note/images/image-20241007153424972.png)

用当前结点的值取余，判断是奇数还是偶数![image-20241007153602127](/Users/yuebinghui/Documents/program/github/note/images/image-20241007153602127.png)

如果是根据值的奇数偶数来分的话，那么就不需要i了，直接把if 判断改成判断p->data的奇偶性就好了

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 16.16.16.mov"></video>

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 16.12.15.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

LinkList separate_create(LinkList &L1) {
    int i = 0; // 记录表A中结点的序号
    LinkList L2 = (LNode *) malloc(sizeof(LNode)); // 创建L2的头结点
    L2->next = NULL; // L2表的初始化
    LNode *L1r, *L2r; // 尾插法需要的指针，用来指向表尾的最后一个结点
    LNode *p; // p 为工作指针 指向第一个结点
    L1r = L1;
    L2r = L2;

    p = L1->next; // p为链表的工作指针，指向待分解的第一个结点
    L1->next = NULL; // 置L1表为空

    while (p != NULL) {
        i++;
        if (i % 2 == 0) { // 如果序号是偶，就让结点放到L2表的后面
            L2r->next = p; // 在L2表表尾插入新结点
            L2r = p; // L2r指向队尾
        } else { // // 如果序号是奇，就让结点放到L1表的后面
            L1r->next = p;// 在L1表表尾插入新结点
            L1r = p;// L1r指向队尾
        }
        p = p->next; // 后移一个结点，重复上面的操作，直到指针指向NULL
    }
    // 表的最后一个结点指向NULL
    L1r->next = NULL;
    L2r->next = NULL;
    return L2;
}

int main() {
    int A1[] = {1, 2, 40, 50, 60};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    LinkList L2 = separate_create(L1);
    print(L1);
    print(L2);

//    print(L3);


    return 0;
}
```

##### 13. 设A={a1,b1,a2,b2, ... ab,bn}，将A拆分成两个单链表，A={a1,a2...an} b={b1,b2...bn}

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 16.49.14.mov"></video>

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-07 16.57.10.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// 不带头结点的链表建立
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

LinkList separate_create(LinkList &L1) {
    LinkList L2 = (LNode *) malloc(sizeof(LNode)); // 创建L2的头结点
    L2->next = NULL; // L2表的初始化
    LNode *p = L1->next; // p 为工作指针 指向第一个结点
    LNode *q; // q指向p的下一个结点，防止断链用的
    LNode *L1r = L1;
    LNode *L2r = L2;

    while (p != NULL) {
        L1r->next = p; // 因为链表第一位是L1的表，所以先放L1的
        L1r = p; // L1r是尾插法的必备指针，永远指向表尾
        p = p->next; // 后移一位工作指针
        if (p != NULL) { // 如果p还是结点，不是NULL，就准备链接L2的结点
            q = p->next; // 就让q指向p的下一个结点，防止断链
            p->next = L2r->next; // 让p当前结点指向L2的next
            L2r->next = p; // 让L2r的最后一位结点链接当前结点
            L2r = p;// L2r是尾插法的必备指针，永远指向表尾
            p = q; // 后移一位工作指针
        }
    }
    L1r->next = NULL;
    return L2;
}

int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    LinkList L2 = separate_create(L1);
    print(L1);
    print(L2);

//    print(L3);


    return 0;
}
```

##### 14. 删除单链表中数值相同的元素（重复元素）有序

如果题目没说是否有头结点，默认有

如果无序呢
就是假如p指向第一个元素，那么我是不是需要另一个指针把p后面的所有元素遍历一遍
先让q指向p的next，然后判断p和q是否相同

![image-20241007181822015](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181822015.png)

如果不用，那么我让q继续往后走

![image-20241007181847331](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181847331.png)

如果一样了，那么我就把，此时的q给free掉

![image-20241007181915935](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181915935.png)

如果你要把q free掉，是不是前面需要加一个前驱了
因为如果我先删除5，那么我需要先找到5的前驱，如果不先标记，我就没法找5的前驱

![image-20241007182006742](/Users/yuebinghui/Documents/program/github/note/images/image-20241007182006742.png)


P是第一次的时候，就拿这个Q便利整个列表，然后P再往后移一次，然后再拿Q遍历整个列表。