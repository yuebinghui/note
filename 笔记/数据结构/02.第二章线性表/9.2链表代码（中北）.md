# 线性表的链式表示-链表

##### 头结点和头指针的关系

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20241004110258475.png" alt="image-20241004110258475" style="zoom:45%;" />

##### 插入节点操作

![image-20241004125543587](/Users/yuebinghui/Documents/program/github/note/images/image-20241004125543587.png)

![image-20241004125606015](/Users/yuebinghui/Documents/program/github/note/images/image-20241004125606015.png)

##### 删除结点操作

![image-20241004130723638](/Users/yuebinghui/Documents/program/github/note/images/image-20241004130723638.png)

![image-20241004130739882](/Users/yuebinghui/Documents/program/github/note/images/image-20241004130739882.png)

##### 采用头插法建立单链表

![image-20241004131156196](/Users/yuebinghui/Documents/program/github/note/images/image-20241004131156196.png)

##### 采用尾巴插法建立单链表

![image-20241004131251253](/Users/yuebinghui/Documents/program/github/note/images/image-20241004131251253.png)

##### 1. 设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点

![image-20241004150657842](/Users/yuebinghui/Documents/program/github/note/images/image-20241004150657842.png)

![image-20241004150735371](/Users/yuebinghui/Documents/program/github/note/images/image-20241004150735371.png)

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20241004151203928.png" alt="image-20241004151203928" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
//void print(LinkList L) {
//    while (L->next != NULL) {
//        L = L->next;
//        printf("%d\n", L->data);
//    }
//printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 2, 3, 4, 5, 6, 7};
//    int size = sizeof(A) / sizeof(int);
//
//    L = (LNode *) malloc(sizeof(LNode));
//    LNode *s, *r;
//    r = L;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        r->next = s;
//        r = s;
//    }
//}

// 不带头结点的链表建立
void print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}


void Delete_x(LinkList &L, ElemType x) {
    LNode *p; // p指向待删除结点
    if (L == NULL) { // 递归出口
        return;
    }

    if (L->data == x) { // 若当前L结点数据域为x
        p = L; // p存下这个要删除结点的指针
        L = L->next; // 让L指向下一个结点
        free(p); // 删除p
        Delete_x(L, x);
    } else { // 若当前L结点数据域 不 为x，直接后移一位结点
        Delete_x(L->next, x);
    }
};


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);
    Delete_x(L,4);
    print(L);
    return 0;
}
```

##### 2.设L为带头结点的单链表，编写算法从尾到头反向输出每个结点的值

递归的话就是因为我去调用，首先我去，假如是。调用的时候它就12345。

![image-20241004152108798](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152108798.png)

那么我。第一下的时候就把一放进去，
然后二放进去
3
4
5
直到我放完之后，然后我开始去算它的时候，

![image-20241004152119768](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152119768.png)

那就是54321。
反向输出的时候用递归，

![image-20241004152135836](/Users/yuebinghui/Documents/program/github/note/images/image-20241004152135836.png)

那就是直接把它，
你看它不断的递归，
那就是放进去。然后。
直到它为空，我就开始输出，
那输出的时候就是反向输出的。

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// 带头结点的链表建立
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L) {
    int A[] = {1, 2, 3};
    int size = sizeof(A) / sizeof(int);

    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }
}

// 不带头结点的链表建立
//void print(LinkList L) {
//    while (L != NULL) {
//        printf("%d\n", L->data);
//        L = L->next;
//    }
//    printf("\n");
//}
//
//void TailInsertList(LinkList &L) {
//    int A[] = {1, 4, 3};
//    int size = sizeof(A) / sizeof(int);
//
//    LNode *s, *r;
//
//    for (int i = 0; i < size; ++i) {
//        s = (LNode *) malloc(sizeof(LNode));
//        s->data = A[i];
//        if (i == 0) {
//            L = s;
//            r = L;
//        } else {
//            r->next = s;
//            r = s;
//        }
//
//    }
//    r->next = NULL;
//}


void print_reverse(LinkList L) {
//    if (L->next) { // 或者是这样
// 你有next我下面才可以执行L->next，不然就L->next已经是null了，再调用就会有问题
// 比如我1 2 3 3个结点，调用到3的时候，3的next就已经是Null了，就不执行if里的代码了，所以函数就不会print_reverse(NULL)
// 如果是if(L!=NULL)那么if里就会执行这样的代码print_reverse(NULL)，下面的L->data就会有问题了
    if (L->next != NULL) {
        print_reverse(L->next); // 递归遍历每个结点
    }
    printf("L->data=%d\n", L->data);
};


int main() {
    LinkList L;
    TailInsertList(L);
    print(L);

    // 如果L是个空指针就不打印了
    if (L != NULL) {
        // 不需要打印头结点的数据域，因为头结点的数据域不存储数据
        print_reverse(L->next);
    }

    print(L);
    return 0;
}
```

##### 3.从单链表中删除自第i个元素起的共len个元素（不带头结点）

不带头结点的话要做特殊处理
如果是带头结点，那么只有else里的语句，if里的语句就没用了



特殊处理的步骤，删除i开始，len个 i为1，len为3

<video src="/Users/yuebinghui/Documents/program/github/note/笔记/数据结构/代码步骤视频/屏幕录制2024-10-04 16.59.26.mov"></video>







##### 4.删除不带头结点单链表中所有值为x的结点（非递归）