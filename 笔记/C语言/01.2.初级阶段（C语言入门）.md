

### 数据类型

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240816105838170.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240816105948439.png)

#### 常量

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817093227287.png)

#### 变量

 

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817093912197.png)

#### 整体int

##### 整形常量

```c++
#include <stdio.h>
// 符号常量
#define PI 8+2 // 不需要加分号

int main() {
    //因为PI是常量，所以不可以下面这样写
    // PI = 1;
  
    // 调试数显类似蓝色条的背景说明程序还没有运行到这一行

    int num = PI * 2; // PI是原封不动，直接替换的效果，直接放到这里的，所以 8 + 2 * 2 = 12
    printf("%i\n", num);

    return 0;
}
```

##### 整形变量

```c++
#include <stdio.h>

int main() {

    int num = 2; // num就是一个整型变量 大小是4字节
    printf("%d\n", num);
    printf("num size=%lu\n", sizeof(num));// sizeof可以用来计算某个变量的空间大小

    return 0;
}
```

#### 浮点形float

##### 浮点形常量

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010144536007.png)

$e^{-3}$就等于$10^{-3}$

按这个方法来就好

```c++
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

int main() {

    double d2 = 1e3;
    printf("%f\n", d2);

    double d3 = 1.8e-3;
    // 1.8e-3 = 0.18e-2 因为我数字除了10，后面的e就需要乘以10
    // 10的-3次幂乘以10就是同底数幂相乘，指数相加就是 -3 + 1 = -2
    printf("%f\n", d3);

    double d4 = -123e-6;
    // -123e-6 = 0.123e-3 因为我数字除了1000，后面的e就需要乘以1000
    // 10的-6次幂乘以1000就是同底数幂相乘，指数相加就是 -6 + 3 = -3
    printf("%f\n", d4);

    double d1 = -.1e-3;
    printf("%f\n", d1);


    return 0;
}  
```

```c++
#include <stdio.h>

int main() {

    double d1 = 1.8e-3; // 0.001800
    double d2 = -123e-6; // 0.000123
    double d3 = -.1e-3; // 0.0001
    double d4 = -.123e-4; // 0.0000123
    double d5 = -1.23e-2; // 0.0123
    double d6 = -45.121e-3; // 0.045121
    long double d7 = -415.12231e-10; // 0.000000041512231

    /*
     * 综上得出结论这个如何转化
     * e后面的数字表示的
     *  如果是没有小数点往后添几个零
     *  如果是有小数点往后移动几位
     *  比如 1.8e3 这个就是小数点往后移动1位 + 后面添两个0
     *  1800
     *  比如 45.121e3 这个就是小数点往后移动3位
     *  45121
     *
     * -e后面的数字表示的正好相反
     *  如果是没有小数点往前移动几位小数点，如果移动到了最前面成了 0.xxx 就往0.后补0
     *  如果是有小数点往前移动几位小数点，如果移动到了最前面成了 0.xxx 就往0.后补0
     *  比如 1.8e-3 这个就是小数点往前移动1位，然后0.后补了两个0
     *  0.0018
     *  比如 45.121e-3 这个就是小数点往前移动2位,然后0.后补了一个0
     *  0.045121
     * */

    printf("%f\n", d1);
    printf("%f\n", d2);
    printf("%f\n", d3);
    printf("%f\n", d4);
    printf("%f\n", d5);
    printf("%f\n", d6);
    printf("%Lf\n", d7);

// printf("num size=%lu\n",sizeof(d1));// sizeof可以用来计算某个变量的空间大小

    return 0;
}
```

##### 浮点形常量

```c++
#include <stdio.h>

int main() {

    float f = 323e-3; // 浮点型变量大小为4字节
    printf("f=%f\n", f);

    printf("num size=%lu\n", sizeof(f));// sizeof可以用来计算某个变量的空间大小

    return 0;
}
```

#### 字符

字符型char  字符型：需要单引号包裹，只可以有一个字符，不能为空字符

##### 字符型常量

注意1放到字符里也是字符型

还有空格也可以放到字符里

\n 表示一个字符

![image-20230920154107653](/Users/yuebinghui/Documents/program/github/note/images/image-20230920154107653.png)

##### 字符型变量

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817102433367.png)

```c++
#include <stdio.h>

int main() {

    char c = 'A'; // 字符型变量大小为1字节
    printf("c=%c\n",c); // 以字符形式输出
    printf("d=%d\n",c); // 以数值形式输出

    printf("c=%c\n",c+32);
    printf("d=%d\n",c+32);

    printf("c size=%lu\n",sizeof(c));// sizeof可以用来计算某个变量的空间大小

    return 0;
}


```

只不过char的大小是一个字节
它里边存的是一个字节的这个数值啊，这大家注意的好。
也就是说你给它赋的是单引号的字符a，实际它里边存的值是多少呢？存的不是a，而是a的ASCII的值，即65

##### ASCII 表

![image-20240817102652632](/Users/yuebinghui/Documents/program/github/note/images/image-20240817102652632.png)







#### 字符串变量（C语言并没有提供）

##### 字符串常量

![image-20230920154233356](/Users/yuebinghui/Documents/program/github/note/images/image-20230920154233356.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819105107500.png)

# -------一个视频结束的分割线-------

### 混合运算

##### 类型强制转换

```c++
#include <stdio.h>

// 场景
// 整数型进行除法运算时，如果运算结果为小数，那么存储浮点数时一定要进行强制类型转换
int main() {
    int i = 5;
// float f = i / 2; // 这里做的是整型运算，因为左右操作数都是整型 f=2.000000
// i 是左操作数 2 是右操作数
  // (float) 这个是强制类型转换运算符，此时并不是说变量i的类型成为float了
    float f = (float) i / 2; // f=2.500000
    printf("f=%f", f);

    return 0;
}
```



### printf用法

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817105048490.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817105444727.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817105738740.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817105817405.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817105831580.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240817110157810.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010164342283.png)

```c++
#include <stdio.h>

int main() {
    // 练习printf
    // %c 字符
    // %d 带符号整数
    // %f 浮点数
    // %s 一串字符
    // 默认右对齐
    printf("字符=%c、带符号整数=%d、浮点数=%10.2f、字符串=%s \n",'n',-10,12.1,"我爱你");

    int i = 10;
    float f = 96.3;
    /*
     * %-3d 表示占位三个 左对齐
     * %5.2f 表示占位5个 保留两位小数
     * */
    printf("student number=%-3d,score=%5.2f\n",i,f);

    i = 100;
    f = 98.21;
    /*
     * %3d 表示占位三个 默认右对齐
     * */
    printf("student number=%3d,score=%5.2f\n",i,f);

    // printf 输出进制
    int num = 123;
    num = 0173;
    num = 0x7b;
    printf("%o\n",num); // 173 八进制
    printf("%d\n",num); // 123 十进制
    printf("%x\n",num); // 7b  十六进制


    return 0;
}
```

# -------一个视频结束的分割线-------

### 进制转换

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818093717848.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818094328554.png)

#### 十进制 0-9

#### 二进制 0-1

![image-20231010160058285](/Users/yuebinghui/Documents/program/github/note/images/image-20231010160058285.png)

#### 八进制 0-7

#### 十六进制 0-9 a-f 

10代表a 15代表f

#### 十进制转二进制

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010161734108.png)

因为int 是4个字节，所以需要给前面补零，补24个0

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818094629539.png)

#### 十进制转八进制

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010162618837.png)

#### 十进制转十六进制

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010162654311.png)

#### 二进制转十六进制

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818095447869.png)

![image-20231010163332706](/Users/yuebinghui/Documents/program/github/note/images/image-20231010163332706.png)

#### 二进制转八进制

![image-20231010163753061](/Users/yuebinghui/Documents/program/github/note/images/image-20231010163753061.png)

#### 二进制转十进制

![image-20231010165206668](/Users/yuebinghui/Documents/program/github/note/images/image-20231010165206668.png)

从右往左依次

```c++
//.... 2**3 + 2**2 + 2**1 + 2**0
// 依次有多少位加多少位，然后把位上面位1的加起来，最后的值就是十进制的值

// 上图就是 64+32+16+8+2+1 = 123
```



#### 八进制转十进制

![image-20231010164101370](/Users/yuebinghui/Documents/program/github/note/images/image-20231010164101370.png)

### 单步调试

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818100316263.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818100307028.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818100701659.png)

而下图内存视图里的，7b确在前面

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818100833168.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818101353317.png)



###### printf没有二进制输出，int i = ?;问号这里也不可以赋值为二进制，没有二进制一说

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010164840224.png)



![image-20231010153722248](/Users/yuebinghui/Documents/program/github/note/images/image-20231010153722248.png)

![image-20231010153728227](/Users/yuebinghui/Documents/program/github/note/images/image-20231010153728227.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010160106815.png)

#### 算进制转换的题可以用本机的计算器来验证

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818101753945.png)



# -------一个视频结束的分割线-------



### scanf用法

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818102116251.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818102440737.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010172018669.png)

你了解一下就行了，考研它不会考这个实际呢scanf？我们往标准输入里边输入的内容呢，实际全都是字符串，你这里写%d%f%s%c不同的这个类型呢，实际是scanf函数的，要根据这个类型。把它读到的字符串，比如你输的是一二三，实际也是字符串，ABC也是一个字符串，

他根据你输入的%什么的不同类型，比如是%d，就把你输的一二三呢，给它转成整型，放到了这个变量里面。

这里写%d%f%s%c不同的这个类型的目的是scanf就知道了。他把那个标准输入里边的字符串，给它转成什么类型，存到这个变量里边好这个呢，基本上没有C语言书籍，上面会写，

![image-20240818103042386](/Users/yuebinghui/Documents/program/github/note/images/image-20240818103042386.png)

好，接着这个后面呢，那必须是一个变量的取地址，
那为什么呢？因为呢，它将从标准输入里边读取的这个数据呢。scanf呢，它读取标准输入里边的数据呢，它读取完，比如它读到一二三，把它变成整形数以后呢，它是要放到一个空间里边的，那这个时候呢，取地址才对应的是一个空间啊，

这是大家注意的。好scanf的话。标准输入内的内容呢？需要放到某个变量。空间里因此变量，必须取地址。啊，要记住啊。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818103259325.png)

###### 阻塞

我给大家演示一下什么叫阻塞，好我运行啊，

你可以看到。这时候这个程序，它就卡在这里了啊，这就是阻塞，也就是说卡着等你输，如果它不阻塞的话，你想想。程序运行的速度呢？那是非常快的，他要是读标准输入的时候不卡住，那你想。你的手速跟得上吗？是吧？它一下子都运行到最后了，你的手速跟不上了，

你还没输。程序就运行完了，因此呢，它就会卡住啊，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818103528095.png)

我给大家先演示一下啊，比如我现在输入个123啊，你输输入任何整个数就可以，你一回车。你看到它就读到了这个变量I里边，它就可以输出，你可以看到I=123，

这就是读取标准输入的一个效果啊，我给大家演示了。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818103605086.png)

假如我现在要读一个字符，读到我们的这个这个。变量c里面是吧？
那这个时候我就再写一个呗，好，你可以看到我再写一个scanf读字符的时候，百分号c是吧？那这个时候呢，我把这个字符百分号c取地址c好，我读字符那我接着呢printf 百分号c因为字符输出要用百分号c来输出嘛，是吧？好，

我们来运行，我们来看一下大家要的这个效果是吧？好，那我这个时候我输一个十吧。好，我一回车。哎，这个第二个scanf呢，它都没有卡住，我本来想输一个，我想输一个字符a，让它显示字符a的，
它都没卡住。那这是为什么呢？那很多同学在这一点上呢，就非常疑惑啊

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818104334421.png)

### scanf原理

你不知道scanf它的原理是什么啊？好，那这个时候他为什么会在这里呢？根本就没有卡住呢，正常他在这里要卡住的，为什么他没有卡住？好，那我们前面教大家了一招。当你不明白什么东西的时候。什么可以告诉你?

单步调试

好，那这个时候我就在这里加一个断点，那注意啊。再演示一个细节，你就比如有同学把断点加到5这儿好，我们现在点这个小虫子啊。有的同学把断点加到5这儿，他就跟我说，
老师，我这怎么不停到第5行啊？怎么一开始就跑到第七行了嘞？哎，就觉得这个奇怪是吧？怎么不跑到这个第五行啊啊是吧？或者断点的第五行怎么跑到第七行了？原因是当你定义一些变量的时候，你没有给它们赋值，实际这条语句呢，它是不需要得到执行的。
大家明白吧，就是你定义的变量的时候，这个编译器它会给这个变量呢，都分了这个地址啊，

就分好实际程序执行的第一句代码是7这里。所以你卡住的是7这里啊，这是大家注意的，不会卡在5这儿啊，这是很多同学有点疑惑

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818104642669.png)

如果说呢，我在这里赋了一个值，那他就会停下来啊，这道理那他就会停下来，你可以看到啊，这就是区别

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818104733565.png)

我点一下啊，好这个时候呢，有的同学在这里呢，他就发现呢这个按钮呢，都灰了。说老师，我是不是环境出问题了，实际不是这个时候呢，咱们得点到控制台这里呢，

来输你输了内容以后它才能走到下一句，你不输内容的时候，它这里灰色你点不了了，因为它阻塞了嘛

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818105023464.png)



![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818105158550.png)

好，我们现在呢？这个时候呢？我们i等于十这一点，那是毫无疑问的，因为我们已经读到了十。

但是呢，为什么这个scan f它不会卡住呢？我告诉你原因，
我先跟你说一下，假如这里有一个缓冲区啊，缓冲区大家不用觉得。很奇怪，这个就是标准输入缓冲区，它其实就是一段内存。这里是标准输入缓冲区。就是一段内存啊，就像变量有空间一样，它是一段内存。啊，就是有很多个字节，你可以往里边放东西啊，我可以直接告诉你它四零九六大小个字节。

好，这个时候呢，当你输了十。当你输了十啊，就说我们不是用键盘输入吗？其实你不仅仅输了十，你输了十以外，你还输了\n。就你往标准输入，里面不仅仅输了十你，你以为你输了十，实际你是输了十和杠n的，因为你当时输了十以后，你回车了

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818105435677.png)

这个时候呢scanf百分号d呢。这一句话呢，他只读走了这个十，因为它匹配整型数的嘛，那整型数只能匹配零到九，他就把这个标准输入缓冲区里边的这个是数值的部分呢，都就读走了。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818105540632.png)

但是，标准输入缓冲区里边现在并不是空的，它现在还剩余一个杠n。因此呢，

你看代码，我走到这儿，你看啊，我走到这儿，我这个时候再走一步的时候。它不会卡住，因为这个百分号c呢，它会读取在标准输入缓冲区里边所剩余的这个字符，这是一个字符啊，转义字符嘛，因为回车就是这个杠n嘛啊，就是你键盘上你按那个enter键。就是这个杠n好，这个时候。



![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818105710609.png)

你再执行的时候，你会发现我们的变量c里边，它得到的是一个杠n，因此它没有卡住啊啊，这就是原因，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818105755738.png)

他把杠n读走了，因此。你这个c等于你为什么什么都看不到呢？实际并不是看不到，而是它输出的是换行啊，它输出的是换行

就是c输出的换行，然后c后面这里还有个换行，
你看啊。我点继续啊。你看你看这个进程一结束，离这个你看第一个换行到这儿，第二个换行呢，到这儿，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818110031479.png)

如果把第10行注释掉的话，你看就变成了这样了，没有两个换行了，只剩一个了

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240818110208177.png)

那有的同学说那我怎么避免这个问题是吧？如果要避免这个问题呢，那我这里呢，已经给大家写了这个解决方案了。这个时候呢，你要把你在下一个scanf和上一个scanf之间呢，加一个fflush

你不想受上一个读取的那个影响。你只要用flash就可以了，stdin代表的意思就是标准输入缓冲区，而flash就是清空标准输入缓冲区的接口。你只要弄了这个，它就会卡住了啊，就这么简单好，

2处我们这时候呢，你就比如我在这里加个flash吧。这就是清空标准输入缓冲区。不管你里边还剩余多少字符，我不要了。

1处这个呢，是把标准输入缓冲区里面的十给读走了。整型都走了，还有杠n呢。

有了2处后，那这个时候你可以看到它就会卡住了啊。你看我先输一个十，你看它会卡住了吧

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819093324417.png)

那如果说我们是读浮点数怎么办呢？读浮点数的时候呢？是%f啊，我们现在来看一下啊。我现在呢，再来写一下。这个读浮点数。假如呢？我10这个地方呢？我不用fflash啊，我这回不用fflash。好，我先把这里改一下啊，

还是同样的一个例子，我把10 11 12这个先注释一下啊。

百分号f呢，那我这个时候呢，我这里写一个float f吧好，那这里也要取地址f。好，那当然了，浮点数的这个输出呢，就是我们的。f等于%f。

好，那我们现在呢？来看一下。有的同学说你这回怎么补fflash了，怎么原来%c的时候你要fflash，这时候你怎么不fflash了？好，我们来看一下我们这回为什么不fflash？一会给你解释原因。我先输一个20，你可以看到它竟然阻塞住了。好接着呢，我又输一个九十八点五。正常的浮点数
读了这个九十八点五，那为什么我们前面是百分号d，这里是百分号f，不需要fflash呢？

当时百分号c的时候需要flash呢？好原因很简单，我们来看一下原因呢，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819094211173.png)

因为scanf在读%d和%f和%s的时候会忽略，回车和空格

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819093715368.png)

忽略又是什么意思？好，我给大家演示一下啊。画图演示这个过程20杠n的确存在，这里边还是这样的。当我们这个整型数呢，它读了这个20以后呢，里边的确有杠n，这是没问题的，但是呢。当它走到这个scanf百分号f去匹配的时候，它在走到这里的时候，因为它是百分号f。这个时候杠n它是一个字符。我这里是匹配浮点数的

你是杠n作为一个转义字符，它不是浮点数，所以呢，我遇到它的时候。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819094517701.png)

当我一开始发现这个杠n呢。在这个缓冲区里边的时候，我走到这里的时候，这个scanf接口啊，它首先就会忽略嘛，它首先就会把这个杠n清空。然后呢，它才会阻塞。为什么scan f会卡住？它会卡住的原因是因为标准输入缓冲区是空的，所以它才会卡住，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819094541107.png)

如果标准输入缓冲区里面不空。它是不会卡住了，这是大家要注意的啊scanf会卡住呢，是因为标准输入缓冲区呢，是空的，所以它等着你往。你把数据呢，输入到那个标准输入缓冲区里边。好啊，所以呢，它会卡住，这就是忽略，

但是字符是不会忽略的，也就是%c不会忽略，这就是为啥%c不会卡住的原因

字符是不会忽略的啊，这是大家要注意的，因为百分号c它本来就可以匹配任何字符，无论是转义字符还是。这个其他这个ABC啊。当然，你输的一二三也是字符啊，这大家要注意的啊，好就是字符一和字符二和字符三啊，

###### 输入字符1，内存里存的是什么

再给大家演示一下啊，我输入一个字符一吧。

好，你可以看到这个时候，这个c它是字符一，但是它的值不是。不是数值一，字符一的数值是多少？是49

好给大家看一下ASCLL表

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819095204669.png)

#### 多种数据类型混合输入

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819095347647.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819095439395.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819095929114.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819100028258.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819100329423.png)

%f匹配到a，a不是浮点型，所以scanf报错了，所以ret返回值是2，只匹配了两个，一个%d一个%c

你怎么知道32是空格，因为ASCLL32是空格



正确答案非常简单，就是说你在考研机试的时候，你使用的时候呢？你只要在1处这个百分号d呢和百分号c之间呢，你再加一个空格就解决了这个问题啊。

啊，这个是错误情况，你要解决它，只要在1处这里呢，加一个空格，那就可以了。

因为你只要在1处这里加一个空格，这个时候它在匹配的时候，我们输入100的时候，2处这个空格呢，就会被1处你这里的格式空格搞掉。

然后呢？百分号c呢？就会去匹配这个a啊，这就是策略

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819100835258.png)

🌟 

<u>*只要是百分号c前面加个空格就行了，其他的不用管啊，就这么简单就搞定了，当然如果这个百分号c在最开头的时候，那就不需要了啊。*</u>



```c++
#include <stdio.h>

int main() {
    int i = 10; //这里赋值不赋值都可以，因为本来就是往i里存入内容
    char c;
    scanf("%d", &i);//注意，一定要取地址
    printf("i=%d\n", i);

    fflush(stdin);
    /*
     * 执行时输入20,然后回车,显示结果如下图所示,
     * 为什么第二个scanf函数不会被阻塞呢?
     * 其实是因为第二个 scanf函数读取了缓冲区中的"\n'，
     * 即 scanf("%c",&c)实现了读取，打印其实输出了换行，所以不会阻塞。
     * */
    scanf("%c", &c);
    printf("c=%c\n", c);

    /*
     * 如上面的例子所示，我们向标准输入缓冲区中放入的字符为'20\n'，输入'\n'（回车) 后，
     * scanf函数才开始匹配,
     * scanf函数中的%d匹配整型数20,
     * 然后放入变量i中,接着进行打印输出,
     * 这时\n'仍然在标准输入缓冲区(stdin)内，
     * 如果第二个scanf函数为scanf("%d",&i),那么依然会发生阻塞,
     * 因为scanf函数在读取整型数、浮点数、字符串%d %f %s(后面介绍数组时讲解字符串)时,会忽略\n (回车符)、空格符等字符(忽略是指scanf函数执行时会首先删除这些字符,然后再阻塞)
     * ,scanf函数匹配一个字符时,会在缓冲区删除对应的字符.因为在执行scanf("%c",&c)语句时，不会忽略任何字符，所以 scanf("%c",&c)读取了还在缓冲区中残留的\n'.
     * */


    return 0;
}
```



```c++
/*
是的，scanf("%s", c); 会读取字符串，但它会在遇到空格、换行符（'\n'）、制表符等空白字符时停止读取，因此它只会读取到第一个空格或换行符为止的字符序列。如果您想读取包含空格和换行符的整行输入，可以考虑使用 fgets 函数，它可以读取一整行文本，包括空格和换行符。例如
*/

```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819103525861.png)



![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010173513196.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010173553598.png)

###### %d和%c后面加个空格就好了

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231010173642992.png)

# -------一个视频结束的分割线-------

## OJ online judge

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819103803118.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240819104120338.png)

# -------一个视频结束的分割线-------









### 运算符

#### 算术运算符及算术表达式

```c++
#include <stdio.h>

/*
 *
 * 算术运算符包含+、-、*、/和%，当一个表达式中同时出现这5种运算符时,
 * 先进行乘(*)、除(/)、取余（%),取余也称取模,后进行加（+) 、减（-),
 * 也就是乘、除、取余运算符的优先级高于加、减运算符
 * 除%运算符外,其余几种运算符既适用于浮点型数又适用于整型数
 * 当操作符/的两个操作数都是整型数时,它执行整除运算
 * 在其他情况下执行浮点型数除法
 * %为取模运算符,它接收两个整型操作数,将左操作数除以右操作数,但它的返回值是余数而不是商
 * 由算术运算符组成的式子称为算术表达式，表达式一定有一个值。通过下面代码实例我们来掌握一下算术运算符*/

int main() {
    int result = 4 + 5 * 2 - 6 / 3 + 10 % 3;
    printf("result=%d\n", result);
    return 0;
}
```

#### 关系运算符与关系表达式

关系表达式的值只有真和假 关系运算符>、<、==、>=、<=、!=

3>4为假,因此整体值为0，而关系表达式5>2为真,因此整体值为1

关系运算符的优先级低于算术运算符

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820092856647.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820093007300.png)

#### 运算符优先级表

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231011165742751.png)

! <u>大于</u> 算术运算符包含+、-、*、/和% <u>大于</u> 关系运算符>、<、==、>=、<=、!= <u>大于</u> && <u>大于</u> || <u>大于</u> =

#### 逻辑运算符与逻辑表达式

与或非 && || !

![image-20240820094750347](/Users/yuebinghui/Documents/program/github/note/images/image-20240820094750347.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820100233289.png)

#### 赋值运算符

=

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820095559511.png)

![image-20240820095628419](/Users/yuebinghui/Documents/program/github/note/images/image-20240820095628419.png)

#### 求字节运算符 sizeof

很多同学会认为sizeof是一个函数,这种理解是错误的，实际sizeof是一个运算符,不像其他运算符是一个符号，sizeof是字母组成的,用于求常量或变量所占用的空间大小,请看下例：

```c++
// sizeof是一个运算符，不是一个函数 用于求常量或者变量所占用的空间大小
#include <stdio.h>

int main() {
    int num; // 整型是4
    printf("num size is %d", sizeof(num));

    return 0;
}
```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820101004279.png)

# -------一个视频结束的分割线-------

### 关系表达式和逻辑表达式

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820101440019.png)

### if-else

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820101836359.png)



### 循环

#### while循环

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820102444020.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820102827436.png)

#### for循环

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231011180932661.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820103616134.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820103623672.png)

这俩这么写都会死循环

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231011181724608.png)

#### continue语句

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820104039349.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820104219196.png)

#### break语句

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820104449974.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820104524093.png)

###### while，循环中1加到10遇到的问题，自增的代码的顺序问题，放在运算前后是不一样的

```c++
#include <stdio.h>

int main() {

    int i = 1, previous = 0, normal = 0;
    int count = 0;

    while (i <= 10) {
        count++;

        /*
        * 这里执行的是 1+2+3+4+5+6+7+8+9+10 的操作 因为i一开始是1
         * 然后加运算后自增，所以正常
         *
         * 这里的i最多可以获取到10，因为11就进入不了这轮判断了
        * */
        normal += i;
        i += 1;
        /*
        * 这里执行的是 2+3+4+5+6+7+8+9+10+11 的操作 因为i一开始是2
         * 自增后才会进行加运算
         * 导致会拿到 i 为11的值然后进行运算
         *
         * 但是这里的i可以拿到11
        * */
        previous += i;

        printf("%d %d\n", normal, previous);
    }
    printf("count %d\n", count);


    return 0;
}

```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240820104926682.png)

#### 没做出来的算法题🌟

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231011185318670.png)

```c++
#include <stdio.h>

int main() {

    int a, b = 0, c, tmp;
    scanf("%d", &a);
    c = a;

    while (a) {
        tmp = a % 10;
        a = a / 10;

        b = b * 10 + tmp;

    }
    if (b == c) {
        printf("yes\n");
    } else {
        printf("no\n");
    }


    return 0;
}
```

# -------一个视频结束的分割线-------

### 数组的定义

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821093428090.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013134647187.png)

### 一维数组在内存中的存储

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821094607278.png)

#### 打断点，查看内存视图中的值

我才可以在这里打个断点啊，就像我们之前单步调试的时候。
好，这时候呢，我们现在这里面还没有这个变量，我这个时候呢，
我点一下我们这个。这个弯折的这个按钮啊，我就叫它折弯按钮好点一下呢，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821095136400.png)

它就到下一步了，你可以看到这里是不是有a了，你可以看到这里是不是有这个a了？好，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821095241412.png)

我们来看一下它的内存的一个分布，其实它在内存当中呢？它这个。第一个元素呢？并不是叫a1，
它的第一个元素呢？实际是叫a0的啊，也就是说这个第一个元素你可以看到，
在这里可以点加号啊。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821095222952.png)

我访问第一个元素呢是a0，你可以看到a0元素的值才是等于一的啊，我为了大家清晰呢，这里初始化。是一到十，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821095330876.png)

然后我们来看一下它的内存视图，内存视图的时候需要在这里呢，输入取地址a你就可以看到

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821095353423.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821095848310.png)

#### 高/低地址

就是我们再给大家调试一下啊，靠后的我们称之为高地址。靠前的呢，我们称之为低地址。
你可以看到前面这个地址呢，实际是f0是吧？

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821100446681.png)

然后这个最后这这些地址，你看这就f10了啊，这边是16进制啊，地址我们的16进制，
你看f10这里是偏大的嘛？

上面是小的，下面是大的啊，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821100538053.png)

有点像我们教室里边，你前面就是第一排，

然后这个最后这这些地址，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013135543182.png)

```c++
#include <stdio.h>

int main() {


    // int a [10] = {}
      // 数组的定义格式为： 类型说明符 数组名 [常量表达式] 定义数组时需要指定数组中元素的个数

      // 例子：
    int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
      // 数组占的内容大小是数组长度 乘以 每个元素的字节数 比如数组里存了 10个int 那就是4*10=40


    int b[10] = {1, 2, 3, 4, 5};
      // 也可以只给部分赋值 后面5个会默认补0

    int c[10] = {0};
      // 如果要给一个元素全部是0

    int d[] = {1, 2, 3, 4, 5, 6};
      // 也可以不指定数组长度，会自动指定，但是考研不建议，因为判卷老师要数你的数组有几位


    return 0;
}
```

# -------一个视频结束的分割线-------

#### 数组的越界访问

```c++
#include <stdio.h>

int main() {
    int a[5] = {1, 2, 3, 4, 5}; // 这是数组a变量
    int b[5] = {6, 7, 8, 9, 10};// 这是数组b变量

    b[8] = 21; // 数组越界访问
    // 本来b只有数组只有5位，b[8]在内存中是没有位置，通过越界访问导致侵占了数组a[0]的值
    // 从代码来看 数组 a[0] 应该是1

    // 可以通过debugger 单步调试 来查看内存中的变化
    printf("a[0]=%d", a[0]); // 但是这里打印出来的是 21
    return 0;
}
```

```c++
#include <stdio.h>

int main() {

    int a[5] = {1, 2, 3, 4, 5}; //定义数组时必须长度固定
    int b[5] = {6, 7, 8, 9, 10};
    printf("前a[1]=%d\n", a[1]);
    printf("前a[2]=%d\n", a[2]);

    b[9] = 99;//越界访问
    b[10] = 100;//越界访问

    printf("后a[1]=%d\n", a[1]);//越界访问会造成数据异常
    printf("后a[2]=%d\n", a[2]);//越界访问会造成数据异常


    return 0;
}
```



#### 数组的传递 🌟

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821102524470.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821102657856.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240821102718110.png)

```c++
#include <stdio.h>

// 数组名字传递到子函数后，子函数的形参接收到的是数组的起始地址，因此不能把数组的长度传递给子函数
void print(int a[], int length) { // 这里a[] 数组方括号里不需要输入数组有几位
    int i;
    // for (i = 0; i < sizeof(a) / sizeof(int); i++) { // 这里是有问题的，因为传递的a是指针，指针是8位，所以只会遍历两次
    for (i = 0; i < length; i++) { // 所以这里是传入了数组的length来判断的,但是这个形参是写死的实参传入的
        printf("%5d", a[i]);
    }
    a[3] = 222; // 这里是可以通过指针改数组的值的
    printf("\n");
}

// 主函数
int main() {
    // 数组的传递
    int a[5] = {1, 2, 3, 4, 5};

    // 调试按钮
    // 步过 当前函数一步一步往下走
    // 步入 debugger 到某行代码，但该行代码还未执行时，该行代码是子函数调用，想进入该子函数时使用
    print(a, 5);
    printf("%d\n", a[3]); // 这里打印其实已经是222了
    print(a, 5);


    return 0;
}
```

# -------一个视频结束的分割线-------

### 字符数组初始化及传递

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013142419719.png)

```c++
#include <stdio.h>

void print(char a[]) {

    int i = 0;
    while (a[i]) {
        printf("%c", a[i]); // 访问越界 乱码了
        i++;
    }
    printf("\n");
}

int main() {

    char c[5] = {'h', 'e', 'l', 'l', 'o'};
    char d[5] = "how";

    printf("%s\n", c);  // 字符必须留一个'\0'的位置 不然会乱码
    printf("%s\n", d);

    print(c); // 字符必须留一个'\0'的位置 不然会乱码
    print(d);

    return 0;
}
```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013143247969.png)

```c++
#include <stdio.h>

int main() {
// int i;
// scanf("%i", &i); // 在终端输入空格会忽略空格，只读取空格前的数据
// printf("%i\n", i);

// float f;
// scanf("%f", &f); // 在终端输入空格会忽略空格，只读取空格前的数据
// printf("%.2f\n", f);

    char c[10]; // 10时需要定义的
//    scanf("%s", c); // scanf读取字符串操作，会自动往字符数组中放结束符 字符数组名c中存储了数组的起始地址，因此不需要取地址
//    printf("%s\n", c);
//
    // 由于会忽略空格，所以可以存两个变量来操作
    char d[10];
    scanf("%s%s", c,d);
    printf("%s%s\n", c, d);

    return 0;
}

```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013143648139.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013145443301.png)

# -------一个视频结束的分割线-------

#### 字符数组

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013150606688.png)



```c++
#include <stdio.h>


int main() {
    // 这里8个字符必须输入9，因为字符串末尾需要留一个\0的位置
//    char c[9] = {'i', 'a', 'm', 'h', 'a', 'p', 'p', 'y'};
//    char c[9] = "iamhappy"; // 使用这种方式来初始化字符串数组
//    printf("%s\n", c); // 使用%s来输出一个字符串，直接把字符数组名放到c的位置输出
    char c1[8] = {'i', 'a', 'm', 'h', 'a', 'p', 'p', 'y'};
//    char c2[8] = "iamhappy";
    printf("%s\n", c1);
// printf("%s\n",c2);
    // 不管你使用上面哪种字符串赋值方式，一旦你c1[8] 输入的字符串长度小于等于你存入的字符，通过%s输出就会乱码
    return 0;
}
```

```c++
// 模拟%s
#include <stdio.h>

void print(char charArr[]) {
    int i = 0;
    while (charArr[i]) { // 走到结束符时，结束循环，因为结束符'\0'的值时0
        printf("%c", charArr[i]);
        i++;
    }
    printf("\n");
}

int main() {
    // 字符输出乱码时，要看看定义的字符长度是不是不够了，导致存不下结束符'\0'
    char charArr[11] = "I love you";
    print(charArr);
// printf("%s\n", charArr);
    return 0;
}
```

##### gets 获取字符数组 puts 打印字符数组 

```c++
#include <stdio.h>

// gets不安全，会访问越界， 栈空间和堆空间都会访问越界
void print() {
    char c[20] = "";
// fgets(c, (sizeof c / sizeof c[0]), stdin);
    scanf("%s", c);
//    gets(c); // scanf是遇到了空格就会停止读取 gets是遇到\n才回停止读取 gets中放入我们字符数组的数组名即可
    puts(c); // puts 等价于 printf("%s\n",c); puts内放的参数是字符数组名
// printf("%s", c);
}

int main() {
    print();


    return 0;
}
```

##### 数组方法 strlen strcat strcpy strcmp

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822093042688.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822094154349.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822094217241.png)

```c++
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

int mystrlength(char c[]) {
    int i = 0;
    while (c[i]) { // 通过找到结束符来结束循环 找到后值为0 条件不满足所以进入不了 语句块 不会++
        i++;
    }
    return i;
}

void print() {
    char c[20];
    char d[20] = "world";
    int length;
  
      bool ccc = '\0'; // 假值
    bool cccc = '\n'; // 正值
  
    gets(c);
  //    fgets(c, sizeof c / sizeof c[0], stdin); // fgets会读到\n 如果你用fgets读，比如你输入1234，你就会发现长度为5，因为你读到了\n，把\n也算在内了
    printf("c=%s\n", c);
// length = strlen(c); // sting.h头文件的统计字符串的长度
    length = mystrlength(c); // 自己封装的统计字符串的长度
    printf("%d\n", length);

    strcat(c, d); //c 必须放变量名 把d的内容拼接到的后面
    printf("d=%s\n", d);

    puts(c);

    strcpy(d, c);//d 必须放变量名

    printf("c=%s\n", c);
    printf("d=%s\n", d);

//
    c[0] = 'y'; // strcpy切断了引用，不会相互影响
    printf("c=%s\n", c);
    printf("d=%s\n", d);
//
    printf("c?d=%d\n", strcmp(c, "woainiworld"));
    // 第一个参数 大于 第二个参数 时返回正数
    // 相等 时返回0
    // 小于 时返回负数
//
//
    printf("my length=%d", length);


}

int main() {
    print();
    return 0;
}


```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822095207465.png)

##### OJ作业，找数组里2有几个

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013153555948.png)

```c++
#include <stdio.h>
#include <string.h>

int main() {
    int len;
    int count = 0;
    scanf("%d", &len);

    int intArr[100];
    for (int i = 0; i < len; i++) {
        scanf("%d", &intArr[i]); // scanf记得取地址
    }
  //  通过数组的总长度，处于一个int的size多少，就得出了这个数组有多少项
    for (int i = 0; i < sizeof(intArr) / sizeof(int); i++) {
        if (intArr[i] == 2) {
            count++;
        }
    }
    printf("%d\n", count);


    return 0;
}
```



![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013153804564.png)

##### OJ作业，字符数组调换顺序

```c++
#include <stdio.h>
#include <string.h>

int main() {

    char c[100];
    gets(c);
//    puts(c);

    char tmp[100]={}; //如果没有这个赋值{}，tmp里可能会有脏数据导致

//    strcpy() 复制
//    strlen()
//    strcmp 比较
//    strcat 拼接

    for (int i = strlen(c) - 1, j = 0; i >= 0; i--, j++) {
        tmp[j] = c[i];
    }
//    puts(tmp);

    int result = strcmp(c, tmp);
    if (result < 0) {
        printf("%d\n", -1);
    } else if (result > 0) {
        printf("%d\n", 1);
    }else{
        printf("%d\n", 0);
    }


    return 0;
}
```

# -------一个视频结束的分割线-------



### 指针

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013160625375.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013160837458.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822104251377.png)

如果已经执行了这个语句，那咱们执行这个啥含义啊，有的同学就想到，那我如果先取值再取地址是啥含义呢？

好，那我们来解释一下，那首先呢，我们如果说你已经做了这样的一个操作是吧？
那接下来呢，你这个时候呢，你去执行。先取值。那取值以后呢？
实际拿到的这个整体其实和你拿i是等价的啊，你只不过这种是间接访问，

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822104428892.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822104420273.png)

你这个时候呢，再去拿一个&取地址。1处那它俩就抵消了，

也就是说单目运算符*和i_pointer结合就相当于拿到了i的值，
你这时候再取地址呢，就是又拿到了i的地址，
而本身i_pointer这里边就存了i的地址，

所以呢？&*i_pointer这个整体表达式所得到的值呢和i_pointer是一样的啊，
如果你发现有人这么写了，或者你自己这么写了，那是犯傻了。&*i_pointer和i_pointer它是等价的啊，
也就是说你直接写一个这个&*i_pointer和写i_pointer这个的是是一样的，没区别的啊，

这是大家注意的，不不会有人去这么写的，把这两个连写到一起的。

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822104818223.png)



好，那反推呢？那\*&a这个也是没有意义的，\*&a就是a
因为&a是对a取地址，那么&a就是个地址，然后*是取值，那么\*&a就是对&a这个地址取值，那么就a

![image-20240822105056837](/Users/yuebinghui/Documents/program/github/note/images/image-20240822105056837.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240822105413908.png)

```c
/*
	指针好比藏宝图，你至少要知道藏宝图指向什么地址才有用吧，空藏宝图有鸡儿用？
	一旦用指针必须要知道指针指向哪里，用指针一般要用malloc来申请堆内存
*/
#include <stdio.h>
#include <string.h>

// 指针
// 取地址运算符 &
// 取值操作符 *
int main() {
    // 定义指针变量记得把*挨着变量名
    int *a, b, c; // 否则容易误解abc都是指针变量，其实只有a是
//指针与指针变量是两个概念,一个变量的地址称为该变量的“指针”。
    // 指针和地址 (类似&i) 是等价的
    // 指针变量就是用来存（指针/地址）的
    int i = 5;

    // 定义了一个指针变量，i_pointer就是指针变量名
    // 指针变量的初始化是某个变量取地址来赋值 即类似&i，不能随便写个值
    // 指针变量的定义格式如下：
    // 基类型 *指针变量名
    // 一个变量➕*的，用来存地址的，就叫它指针变量
    int *i_pointer;
    i_pointer = &i;
    // ⚠️指针变量名是i_pointer，而不是*i_pointer，*i_pointer这个是取值了
    // 假如61fe1c是i变量的起始地址(这个地址没存内存，只是编号)
    // 那么上面 i_pointer = &i 就是取到i变量的地址存给了指针变量
    // 每个字节都有地址，(这个地址没存内存，只是编号)
    // 说某个变量的地址时，讲的都是它的起始地址

    printf("i=%d\n", i);
    printf("*i_pointer=%d\n", *i_pointer);

    // sizeof(i_pointer)=8字节是指程序是64位的，如果程序是32位的就是4个字节（考研往往强调程序是32位的）
    // 指针变量的本质就是为了做间接访问

    printf("%d", *&i);// = i
    printf("%d", *&*i_pointer);// =i --- &*i_pointer =  i_pointer
    return 0;
}
```

#### 直接访问与间接访问

指针变量的本质就是为了做间接访问

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013162515860.png)

#### 指针的传递

![image-20231013163655424](/Users/yuebinghui/Documents/program/github/note/images/image-20231013163655424.png)

##### 值传递

![image-20231013163709540](/Users/yuebinghui/Documents/program/github/note/images/image-20231013163709540.png)

![image-20231013163721111](/Users/yuebinghui/Documents/program/github/note/images/image-20231013163721111.png)

```c++
#include <stdio.h>
#include <string.h>

// 在子函数内去改变主函数中某个变量的值
void change(int *j) {
    *j = 5; // *j等价于变量i 相当于访问i变量赋值
}

// 指针的传递
int main() {
    int i = 10;
    printf("before change i=%d\n", i);
    change(&i); // C语言的函数调用是值传递，实参赋值给形参，j=&i
    printf("after change i=%d\n", i);
    return 0;
}
// 这种是改不了值的
//void change(int j) {
// j = 5;
//}
//
//// 指针的传递
//int main() {
// int i = 10;
// printf("before change i=%d\n", i);
// change(i);
// printf("after change i=%d\n", i);
// return 0;
//}
```

#### 指针的偏移

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013164700770.png)

例1.1

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823092713900.png)

```c++
#include <stdio.h>
#include <string.h>

#define Len 5


// 指针的偏移
int main() {
    int a[Len] = {1, 2, 3, 4, 5};

    int *p;
    int *q;
    /*
     * 数组不可以和整型、浮点型、字符型去类比
     * 数组名里本身包含了变量的起始地址，所以无需&取地址
     * */
    q = a;
    p = &a[4];// 指针变量P指向了数组的最后一个元素

  //第一次循环的时候-1这个东西应该访问越界了吧？？
    for (int i = -1; i < Len; i++) {
        printf("%3d",i);

        printf("%3d", *(q + i));
        printf("%3d\n", *(p - i));
        /*
         * float *p; p的加减也是偏移4个字节
         * 指针变量+1后，偏移的长度是其基类型的长度，也就是偏移sizeof(int)，这样通过*(p+1)就可以得到元素a[1]
         * 基类型是多少字节，*p+几 几就是基类型的字节数
         *
         * 指针的偏移就是对pointer进行加减
         * 加就是向前偏移
         * 减就是向后偏移
         * */
    }

    printf("%3d", *(q)); // 这两个等同相当于没有偏移地址
    printf("%3d", *(q + 0)); // 这两个等同相当于没有偏移地址
    printf("%3d", *(q + 1));
    printf("%3d", *(q + 2));
    printf("%3d", *(q + 3));
    printf("%3d", *(q + 4));

    return 0;
}
```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231013165641559.png)

#### 数组指针变量

```c++
#include <stdio.h>
#include <string.h>

#define hundred 100

/*
 * 函数形参，数组只有指针变量一说，没有数组变量一说
 * 形参那里 char *c 和 char c[]是等价的 指针sizeof永远是8个字节
 * */
//void change(char *c) {// 指针
void change(char c[]) {// 指针
    *c = 'W';
    c[3] = 'A'; // *(c + 3) = 'A'; 这俩是完全等价的
    *(c + 6) = 'N';
}

// 指针与一维数组

int main() {
    char c[hundred] = "wo ai ni";
    /*
     * 数组名作为实参传递给子函数时，是弱化为指针的
     *
     * 因为函数是值传递，所以不能把类型传递给函数，只可以传值，数组里存的是一个指针值
     * 数组名里存的是这个数组的起始地址
     * */
    change(c);
    puts(c);


    return 0;
}
```

# -------一个视频结束的分割线-------

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823095915370.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823100050093.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823100128577.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823100151735.png)

#### 指针与malloc动态内存申请

```c++
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // malloc 使用的头文件

// 指针与malloc动态内存申请
int main() {
    /*
     * C语言的数组长度固定是因为其定义的整型、浮点型、字符型变量、数组变量都在栈空间中,
     * 而栈空间的大小在编译时是确定的。
     * 如果使用的空间大小不确定，那么就要使用堆空间。
     *
     * 存字符比如输入10个字符，需要11个位置，因为要存结束符
     *
     * Void *代表无类型指针
     * */
    int size; // size表示我们要申请多大字节的空间
    char *p; // void* 类型的指针式不可以偏移的，因此不会定义无类型指针
    scanf("%d", &size); // 输入要申请的空间大小
    /*
     * malloc返回的是起始地址
     * */
    // 要强制类型转换和定义的变量一致的类型
    p = (char *) malloc(size); // malloc 返回的void* 代表无类型指针
    p[0] = 'w';
    p[1] = 'o';
    p[2] = ' ';
    p[3] = 'a';
    *(p + 4) = 'i';
    p[5] = ' ';
    p[6] = 'n';
    p[7] = 'i';
    p[8] = '!';
    p[9] = '\0';
// strcpy(p,"wo ai ni");
    puts(p);
    // 用完堆内存地址要记得还
    // 释放申请的空间时，给的地址，必须是最初malloc返回给我们的地址
    free(p); // 释放申请空间
// 堆空间，使用完后记得free
    return 0;
}
```

#### 栈与堆的差异

```c++
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

# define hundred 100

char *get_p() {
// char *string = "wo ai ni 1234567890"; // 这个写法是错误的，你特么人家指针变量你存字符干鸡毛
    char string[100] = "woaini";
    char *p;
    p = string;
    puts(p);
    return p;
}

char *get_malloc_stack() {
    char string[100] = "woaini"; // 把这个赋值给p,然后该作用域外输出，还是乱码，可能因为这个变量内存已经别清空了把

    char *p = (char *) malloc(100); // 堆空间在整个进程中一直有效，不因为函数结束，而消亡

    strcpy(p, "woaini");

    return p;
}


// 栈与堆的差异
int main() {

    char *s;
    s = get_p();
    puts(s);

    s = get_malloc_stack();
    // 函数内的变量p是没了，但是s接到了那个引用，所以可以从堆空间取
    puts(s);
    free(s); // 只有free时，堆空间才会释放
    return 0;
}
```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823102209306.png)

# -------一个视频结束的分割线-------

### 函数

#### 函数定义

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823104357906.png)

![image-20230828172050351](/Users/yuebinghui/Documents/program/github/note/images/image-20230828172050351.png)

如果b 调用a函数，b称为调用函数，a称为被调函数

函数在栈空间，malloc在堆空间，全局变量在数据段

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823104456053.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823104536272.png)

#### 全局变量和局部变量

和js一样

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240824153244204.png)

#### 函数递归

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240823105325262.png)

```c++
/*
	  和javascript一样，其实还是不太懂，老师说多刷题
    还有两个点
    1. 找公式 🌰：n * f(n - 1)
    2. 找结束条件 if(n ==1){ return 1 }
    3. 结束条件肯定在return 公式的上面
*/
int total;
int recursion(int i) {
    if (i == 1) {
        return 1;
    }
    total = i * recursion(i - 1);
    printf("i=%d total=%d\n", i, total);
    return total;
}

int step(int i) {
    if (i == 1 || i == 2) {
        return i;
    }

    return step(i - 1) + step(i - 2);
}Ï
```

# -------一个视频结束的分割线-------

### 结构体

#### 结构体的定义

#### 结构体的初始化

#### 结构体数组

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240824154210335.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240824154549560.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240824154621139.png)



![](/Users/yuebinghui/Documents/program/github/note/images/image-20231014165048837.png)

```c++
#include <stdio.h>

// 定义结构体
struct student {
    int num;
    char name[20]; // 这里赋值是""双引号 输出为%s
    char sex; // 记得这里赋值是''单引号 输出为%c
    int age;
    float score;
    char address[30];
};

// 🌟
int main() {
    // 初始化操作 相当于一个对象
    struct student students = {
            0,
            "int",
            'I',
            0,
            0,
            "Int"
    };

    printf("%d %s %c %d %f %s\n",
           students.num,
           students.name,
           students.sex,
           students.age,
           students.score,
           students.address
    );
    // 这里%s后空一个空格是因为如果%s这里是%d，然后读取完数字后，标准输入缓冲区里还剩\n
    // 但是%c又不会忽略空格和\n，导致读取了这个\n，导致本意想让它读取的内容它没有读取
    // 相当于它只读取了一个\n
    //1 int I 0 0.000000 Int
//    scanf("%d%s %c%d%f%s",
//          &students.num,
//          students.name,
//          &students.sex,
//          &students.age,
//          &students.score,
//          students.address
//    );
//    printf("%d %s %c %d %f %s\n",
//           students.num,
//           students.name,
//           students.sex,
//           students.age,
//           students.score,
//           students.address
//    );
//    printf("-----------------------------\n");
//    // 相当于一个长度位3的对象数组
//
//    fflush(stdin);
//
    struct student studentArr[3]; // 定义结构体数组变量
    for (int i = 0; i < 3; i++) {
//10 ybh n 26 330.000000 研究生
//11 ybh n 26 330.000000 研究生
//12 ybh n 26 330.000000 研究生
        scanf("%d %s %c %d %f %s",
              &studentArr[i].num,
              studentArr[i].name,
              &studentArr[i].sex,
              &studentArr[i].age,
              &studentArr[i].score,
              studentArr[i].address
        );

    }
//
    for (int i = 0; i < 3; i++) {
        printf("%d %s %c %d %f %s\n",
               studentArr[i].num,
               studentArr[i].name,
               studentArr[i].sex,
               studentArr[i].age,
               studentArr[i].score,
               studentArr[i].address
        );
    }

}
```

#### 结构体的对齐（计算结构体大小）

```c++
#include <stdio.h>

struct student_type1 {
// char a[1];
// int score1;
// double score2;
    char name[20];
    int age;
    int num;
    char sex;
    float score;
    char addr[30];
};

int main() {

    // 结构体对齐：为什么要结构体对齐，就是为了cpu高效的去取内存上的数据

// char 1
// short 2
// int 4
// float 4
// double 8
// 指针 8

/*
 * 结构体大小必须是其最大成员的整数倍
 * 最大成员不包括数组，只包括int char float之类的
 * */

// 当结构体里只有一个的时候就是对于基类型的sizeof
// 当有两个时，以大的为准然后*2就好
/*
 * 当有三个的时候
 * 当三个都是同一类型是，直接sizeof✖️3就好，比如 char char char 就是三个字节
 * 如果基类型大的不在中间，剩下两个➕起来
 * 小于等于基类型最大的那个，那么就最大基类型字节数*2
 * 大于基类型最大的那个，那么就最大基类型字节数*3
 * 如果基类型大的在中间,不需要➕，直接就最大基类型字节数*3
 * */

    struct student_type1 s1 = {1, 1};
    struct student_type1 s2; // 变量不赋值也是占空间的
    printf("s1 sizeof=%d\n", sizeof(s1));
    return 0;
}
```

# -------一个视频结束的分割线-------

#### 结构体指针变量

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231014171748218.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20240824162257069.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231014173304362.png)

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231014173942564.png)

```c++
#include <stdio.h>

struct student {
    int num;
    char name[20];
    char sex;
};

// 结构体指针和结构体变量非常重要🌟
// 结构体指针的练习
int main() {
    struct student s = {1001, "wangle", 'M'};
    struct student sArr[3] = {11, "wangle", 'M', 22, "wangle", 'M', 33, "wangle", 'M',};
    // 一个结构体变量的指针就是该变量所占据的内存段的起始地址。
    struct student *p; // 定义了一个结构体指针变量
// p = &s;
    // (*p).num 因为.运算符的优先级比*高，所以要加()
// printf("%d %s%c", (*p).num, p->name, p->sex);

    p = sArr; // 等价于 &sArr[0]
    p += 1; // 指针的偏移
    p += 1;
    // 考研初试一定要写 p->name 不要写(*p).name
    printf("%d %s%c", (*p).num, p->name, p->sex);
    return 0;
}
```

#### typedef 起别名

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231014172226024.png)

```c++
#include <stdio.h>

typedef int INGETER; // 这种方式其实是代替了 int 那一步，后续变量名还是要自己起的

// typedef 考研初试必用 起别名
typedef struct {
    char name[20];
    char sex;
    short age;
} stu, *pstu; // 这里代替了 struct student 这一步，后续变量名还是要自己起的

int main() {
    stu s1 = {"yuebinghui", 'M', 26};

    stu arr[2] = {"yuebinghui", 'M', 28, "yuebinghui", 'M', 29};

    pstu pstu1 = &s1; // 结构体指针变量 取地址

    pstu pstu2 = arr; // 结构体指针变量

    INGETER num = 10;

    printf("%s %c %d\n", s1.name, s1.sex, s1.age);
    printf("%s %c %d\n", (*pstu1).name, pstu1->sex, pstu1->age);


    printf("%s %c %d\n", (*pstu2).name, pstu2->sex, pstu2->age);
    pstu2 = arr + 1;
    printf("%s %c %d\n", (*pstu2).name, pstu2->sex, pstu2->age);
    // 写一个0初始化，所有的成员都是0，包括数组内的每项
    return 0;
}
```

# -------一个视频结束的分割线-------

### C++的引用

```c++
#include <stdio.h>

// c++ 形参中写&，要称为引用
// 当你在子函数中要修改主函数中变量的值，就用引用，不需要修改，就不用 int &i
void modify_num(int &i) {
    i += 1;
}

int main() {
    int i = 10;
    // 在子函数内修改主函数普通变量的值
    modify_num(i);

    printf("%d\n", i);
    return 0;
}

// c 的写法
//void modify_num(int *i) {
// *i += 1;
//}
//
//
//int main() {
// int i = 10;
// // 在子函数内修改主函数普通变量的值
// modify_num(&i);
//
//
// printf("%d\n", i);
// return 0;
//}
```

```c++
#include <stdio.h>

// 就是我们是否要在子函数内部修改传入的主函数变量的值，如果需要修改就加引用，如果不需要就不加
void modify_p(int *&p, int *q) { // 引用必须和变量名紧邻
    p = q;
}

// 子函数内修改主函数的一级指针变量🌟🌟🌟
int main() {
    int *p = NULL;
    int i = 10;
    int *q = &i;

    modify_p(p, q);

    printf("%d\n", *p);
    return 0; // 进程已结束，退出代码不为0，那么代表进程结束异常
}

// c代码改写上面得，使得不用引用也可以
//void modify_p(int **p, int *q) { // 引用必须和变量名紧邻
// *p = q;
//}
//
//int main() {
// int *p = NULL;
// int i = 10;
// int *q = &i;
//
// modify_p(&p, q);
//
// printf("%d\n", *p);
// return 0; // 进程已结束，退出代码不为0，那么代表进程结束异常
//}
```

![](/Users/yuebinghui/Documents/program/github/note/images/image-20231014175725669.png)











