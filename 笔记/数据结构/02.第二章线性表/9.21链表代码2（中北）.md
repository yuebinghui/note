##### 11. ğŸŒŸæŒ‰é€’å¢æ¬¡åºè¾“å‡ºå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨å’Œå„ç»“ç‚¹çš„æ•°æ®å…ƒç´ 

ä¸‹é¢çš„è§†é¢‘ï¼Œæ‰§è¡Œäº†ä¸€è½®whileå¾ªç¯ï¼Œåœ¨87 88è¡Œé‡ç½®æŒ‡é’ˆåå°±æ²¡å†å½•å±äº†ï¼Œå¯ä»¥è‡ªå·±ç”»ç”»

<u>å› ä¸ºè¿™é‡Œç›¸å½“äºæ‰¾åˆ°æœ€å°çš„ç»“ç‚¹åè¾“å‡ºååˆ é™¤ï¼Œæ‰€ä»¥è¦æœ‰ä¸¤å±‚å¾ªç¯çš„ï¼Œå¤–å±‚éå†æ•´ä¸ªLé“¾è¡¨ï¼Œå†…å±‚æ‰¾æœ€å°èŠ‚ç‚¹çš„å‰é©±ç»“ç‚¹ï¼Œç„¶ååˆ é™¤</u>

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-05 16.40.16.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

void min_delete(LinkList &L) {
    LNode *pre = L, *p = L->next, *q; // preä¸ºæœ€å°ç»“ç‚¹çš„å‰é©±ç»“ç‚¹çš„æŒ‡é’ˆ
    while (L->next != NULL) { // å¾ªç¯åˆ°ä»…å‰©å¤´ç»“ç‚¹
        while (p->next != NULL) { // å°±æ˜¯pæŒ‡é’ˆæŒ‡åˆ°æœ€åä¸€ä¸ªç»“ç‚¹å°±ä¸æ‰§è¡Œä¸‹é¢çš„è¯­å¥äº†
            // pçš„ä¸‹ä¸€ä¸ªç»“ç‚¹çš„æ•°æ® å’Œ preçš„ä¸‹ä¸€ä¸ªç»“ç‚¹çš„æ•°æ®æ¯”è¾ƒ
            // æ¯”pæ¯”preè¿˜å°ï¼Œä½ på°±æ˜¯æ›´å°çš„ï¼Œæ”¾å…¥preï¼Œæ ‡è®°æœ€å°ç»“ç‚¹çš„å‰é©±
            if (p->next->data < pre->next->data) {
                pre = p; // è®°ä½å½“å‰æœ€å°ç»“ç‚¹çš„å‰é©±ç»“ç‚¹
            }
            p = p->next;
        }
        printf("pre->next->data=%d\n", pre->next->data); // è¾“å‡ºæœ€å°å€¼ç»“ç‚¹çš„æ•°æ®
        q = pre->next; // åˆ é™¤å€¼æœ€å°çš„ç»“ç‚¹ï¼Œé‡Šæ”¾ç»“ç‚¹ç©ºé—´
        pre->next = q->next;
        free(q);

        // é‡ç½®pre å’Œ pçš„æŒ‡é’ˆï¼Œå¾ªç¯æ‰§è¡Œä¸Šé¢ä»£ç 
        pre = L;
        p = L->next;
    }
    free(L); // é‡Šæ”¾å¤´ç»“ç‚¹
}

int main() {
    int A1[] = {25, 10, 7, 15, 30};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
//    print(L2);

    min_delete(L1);
    // print(L1); // è¿™é‡Œä¸å¯ä»¥è°ƒç”¨è¿™ä¸ª é“¾è¡¨L1å·²ç»åœ¨min_deleteè¢«é‡Šæ”¾ï¼Œä½†åœ¨print(L1)è¯­å¥ä¸­ä»ç„¶å°è¯•è®¿é—®å·²ç»é‡Šæ”¾çš„å†…å­˜ã€‚

//    print(L3);


    return 0;
}
```

##### 12. ğŸŒŸå°†ä¸€ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨A åˆ†è§£æˆä¸¤ä¸ªå¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨Aå’ŒBï¼Œä½¿å¾—Aè¡¨ä¸­å«æœ‰åŸè¡¨ä¸­åºå·ä¸ºå¥‡æ•°çš„å…ƒç´ ï¼Œè€ŒBè¡¨ä¸­å«æœ‰åŸè¡¨ä¸­åºå·ä¸ºå¶æ•°çš„å…ƒç´ ï¼Œä¸”ä¿æŒå…¶ç›¸å¯¹é¡ºåºä¸å˜.

<u>è¿™é“é¢˜é‡Œï¼Œå¯ä»¥æ³¨æ„ä¸‹å°¾æ’æ³•çš„å¥½å¤„ï¼Œåªéœ€è¦æŠŠæœ€åä¸€ä¸ªç»“ç‚¹æŒ‡é’ˆæŒ‡å‘NULLå°±å¥½äº†</u>
<u>å¤´æ’æ³•çš„è¯ï¼Œéœ€è¦æ¯æ¬¡å¤„ç†å½“å‰ç»“ç‚¹çš„nextèµ‹å€¼ä¸ºå‰ä¸€ä¸ªç»“ç‚¹çš„nextï¼Œç„¶åå†æŠŠå‰ä¸€ä¸ªç»“ç‚¹çš„nexté“¾æ¥ä¸ºå½“å‰ç»“ç‚¹</u>

å…¶å®æ–¹æ³•1çš„æ€è·¯ä¼šæ¯”è¾ƒç®€å•ï¼Œä»£ç ä¹Ÿæ•´æ´ï¼Œå› ä¸ºç›¸å½“äºå»ºç«‹äº†ä¸¤ä¸ªå¤´ç»“ç‚¹ï¼Œè®©pæŒ‡å‘å¤´ç»“ç‚¹åçš„ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œç„¶åéå†æ•´ä¸ªpé“¾è¡¨ï¼ŒæŒ‰è§„ç« æ’å…¥L1ï¼ŒL2å°±å¥½äº†ï¼Œä¹Ÿä¸éœ€è¦æ–­é“¾ï¼Œç›´æ¥åæ’å°±å¥½äº†ï¼Œæœ€åç»™L1ï¼ŒL2çš„å¯¹å°¾ç»“ç‚¹èµ‹å€¼NULL

æ–¹æ³•2çš„è¯ï¼Œæ˜¯å»ºç«‹äº†ä¸ªL2çš„é“¾è¡¨ä»¥åŠæŒ‡å‘å°¾èŠ‚ç‚¹çš„rï¼Œä½†æ˜¯è¿˜éœ€è¦pre æ¥è®°å½•å‰é©±ç»“ç‚¹ï¼Œ

å°±æ˜¯å¯ä»¥æœ‰å¤šç§æƒ…å†µï¼Œ
æ¯”å¦‚Aé‡Œä¸ºåºå·ä¸ºå¶ï¼ŒBé‡Œä¸ºåºå·ä¸ºå¥‡
æ¯”å¦‚Aé‡Œä¸ºåºå·ä¸ºå¥‡ï¼ŒBé‡Œä¸ºåºå·ä¸ºå¶
æ¯”å¦‚Aé‡Œä¸ºå€¼ä¸ºå¶ï¼ŒBé‡Œä¸ºå€¼ä¸ºå¥‡
æ¯”å¦‚Aé‡Œä¸ºå€¼ä¸ºå¥‡ï¼ŒBé‡Œä¸ºå€¼ä¸ºå¶

åºå·å°±ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œç¬¬äºŒä¸ªç»“ç‚¹
ç”¨iå–ä½™æ¥åˆ¤æ–­ï¼Œåºå·æ˜¯å¥‡æ•°è¿˜æ˜¯å¶æ•°ï¼Œ![image-20241007153424972](/Users/yuebinghui/Documents/program/github/note/images/image-20241007153424972.png)

ç”¨å½“å‰ç»“ç‚¹çš„å€¼å–ä½™ï¼Œåˆ¤æ–­æ˜¯å¥‡æ•°è¿˜æ˜¯å¶æ•°![image-20241007153602127](/Users/yuebinghui/Documents/program/github/note/images/image-20241007153602127.png)

å¦‚æœæ˜¯æ ¹æ®å€¼çš„å¥‡æ•°å¶æ•°æ¥åˆ†çš„è¯ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦iäº†ï¼Œç›´æ¥æŠŠif åˆ¤æ–­æ”¹æˆåˆ¤æ–­p->dataçš„å¥‡å¶æ€§å°±å¥½äº†

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-07 16.16.16.mov"></video>

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-07 16.12.15.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}


LinkList separate_create(LinkList &L1) {
    int i = 0; // è®°å½•è¡¨Aä¸­ç»“ç‚¹çš„åºå·
    LinkList L2 = (LNode *) malloc(sizeof(LNode)); // åˆ›å»ºL2çš„å¤´ç»“ç‚¹
    L2->next = NULL; // L2è¡¨çš„åˆå§‹åŒ–
    LNode *L1r, *L2r; // å°¾æ’æ³•éœ€è¦çš„æŒ‡é’ˆï¼Œç”¨æ¥æŒ‡å‘è¡¨å°¾çš„æœ€åä¸€ä¸ªç»“ç‚¹
    LNode *p; // p ä¸ºå·¥ä½œæŒ‡é’ˆ æŒ‡å‘ç¬¬ä¸€ä¸ªç»“ç‚¹
    L1r = L1;
    L2r = L2;

    p = L1->next; // pä¸ºé“¾è¡¨çš„å·¥ä½œæŒ‡é’ˆï¼ŒæŒ‡å‘å¾…åˆ†è§£çš„ç¬¬ä¸€ä¸ªç»“ç‚¹
    L1->next = NULL; // ç½®L1è¡¨ä¸ºç©º

    while (p != NULL) {
        i++;
        if (i % 2 == 0) { // å¦‚æœåºå·æ˜¯å¶ï¼Œå°±è®©ç»“ç‚¹æ”¾åˆ°L2è¡¨çš„åé¢
            L2r->next = p; // åœ¨L2è¡¨è¡¨å°¾æ’å…¥æ–°ç»“ç‚¹
            L2r = p; // L2ræŒ‡å‘é˜Ÿå°¾
        } else { // // å¦‚æœåºå·æ˜¯å¥‡ï¼Œå°±è®©ç»“ç‚¹æ”¾åˆ°L1è¡¨çš„åé¢
            L1r->next = p;// åœ¨L1è¡¨è¡¨å°¾æ’å…¥æ–°ç»“ç‚¹
            L1r = p;// L1ræŒ‡å‘é˜Ÿå°¾
        }
        p = p->next; // åç§»ä¸€ä¸ªç»“ç‚¹ï¼Œé‡å¤ä¸Šé¢çš„æ“ä½œï¼Œç›´åˆ°æŒ‡é’ˆæŒ‡å‘NULL
    }
    // è¡¨çš„æœ€åä¸€ä¸ªç»“ç‚¹æŒ‡å‘NULL
    L1r->next = NULL;
    L2r->next = NULL;
    return L2;
}

// æ–¹æ³•2 ğŸŒŸ
// æ€è·¯ï¼šæˆ‘è¿™ä¸ªå»ºç«‹äº†ä¸€ä¸ªL2ï¼Œç„¶åç§»åŠ¨på½“æŒ‡å‘ åºå·ä¸ºå¶æ•°çš„æ—¶å€™ï¼Œ
// å°±åœ¨Lä¸Šæ“ä½œå°±å¥½äº†ï¼Œç”¨preæŒ‡å‘pçš„å‰ä¸€ä¸ªç»“ç‚¹ï¼Œè¿™æ ·å¯ä»¥pre->next = p->next;ï¼Œå°±æŠŠåºå·ä¸ºå¶çš„ç»“ç‚¹åˆ†å‡ºæ¥
// ç„¶åæŠŠè¿™ä¸ªç»“ç‚¹å°¾æ’æ³•æ”¾å…¥L2ä¸­

// å½“åºå·ä¸ºå¥‡æ•°çš„æ—¶å€™ï¼Œå°±è®©pre å’Œ pæŒ‡é’ˆåç§»å°±å¥½äº†
LinkList detach(LinkList &L) {
    LinkList L2 = (LNode *) malloc(sizeof(LNode));
    L2->next = NULL;
    LNode *r = L2;

    LNode *p = L->next;
    LNode *pre = L;

    int i = 0;
    while (p != NULL) {
//        if (p->data % 2 == 1) {
        if (i % 2 == 0) {
            pre->next = p->next;

            // ğŸ‘‡ğŸ»L2é“¾è¡¨çš„æ“ä½œ
            p->next = L2->next;
            r->next = p;
            r = p;
            // ğŸ‘†ğŸ»L2é“¾è¡¨çš„æ“ä½œ

            p = pre->next;
        } else {
            pre = p;
            p = p->next;
        }

        i++;
    }

    r->next = NULL;
    return L2;
}

int main() {
    int A1[] = {1, 2, 40, 50, 60};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    LinkList L2 = separate_create(L1);
    print(L1);
    print(L2);

//    print(L3);


    return 0;
}
```

##### 13. ğŸŒŸè®¾A={a1,b1,a2,b2, ... ab,bn}ï¼Œå°†Aæ‹†åˆ†æˆä¸¤ä¸ªå•é“¾è¡¨ï¼ŒA={a1,a2...an} b={b1,b2...bn}

è¿™é‡Œå’Œæˆ‘12é¢˜é‡Œçš„æ–¹æ³•2ä¸­çš„æ€è·¯å¾ˆåƒï¼Œ
åŒç†è¿™é‡Œä¹Ÿå¯ä»¥æŒ‰12é¢˜é‡Œçš„æ–¹æ³•1æ¥å†™ï¼Œå°±æ˜¯æŒ‰åºå·çš„è¿™ç§

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-07 16.49.14.mov"></video>

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-07 16.57.10.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

LinkList separate_create(LinkList &L1) {
    LinkList L2 = (LNode *) malloc(sizeof(LNode)); // åˆ›å»ºL2çš„å¤´ç»“ç‚¹
    L2->next = NULL; // L2è¡¨çš„åˆå§‹åŒ–
    LNode *p = L1->next; // p ä¸ºå·¥ä½œæŒ‡é’ˆ æŒ‡å‘ç¬¬ä¸€ä¸ªç»“ç‚¹
    LNode *q; // qæŒ‡å‘pçš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œé˜²æ­¢æ–­é“¾ç”¨çš„
    LNode *L1r = L1;
    LNode *L2r = L2;

    while (p != NULL) {
        L1r->next = p; // å› ä¸ºé“¾è¡¨ç¬¬ä¸€ä½æ˜¯L1çš„è¡¨ï¼Œæ‰€ä»¥å…ˆæ”¾L1çš„
        L1r = p; // L1ræ˜¯å°¾æ’æ³•çš„å¿…å¤‡æŒ‡é’ˆï¼Œæ°¸è¿œæŒ‡å‘è¡¨å°¾
        p = p->next; // åç§»ä¸€ä½å·¥ä½œæŒ‡é’ˆ
        if (p != NULL) { // å¦‚æœpè¿˜æ˜¯ç»“ç‚¹ï¼Œä¸æ˜¯NULLï¼Œå°±å‡†å¤‡é“¾æ¥L2çš„ç»“ç‚¹
            q = p->next; // å°±è®©qæŒ‡å‘pçš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œé˜²æ­¢æ–­é“¾
            p->next = L2r->next; // è®©på½“å‰ç»“ç‚¹æŒ‡å‘L2çš„next
            L2r->next = p; // è®©L2rçš„æœ€åä¸€ä½ç»“ç‚¹é“¾æ¥å½“å‰ç»“ç‚¹
            L2r = p;// L2ræ˜¯å°¾æ’æ³•çš„å¿…å¤‡æŒ‡é’ˆï¼Œæ°¸è¿œæŒ‡å‘è¡¨å°¾
            p = q; // åç§»ä¸€ä½å·¥ä½œæŒ‡é’ˆ
        }
    }
    L1r->next = NULL;
    return L2;
}

int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    LinkList L2 = separate_create(L1);
    print(L1);
    print(L2);

//    print(L3);


    return 0;
}
```

##### 14. åˆ é™¤å•é“¾è¡¨ä¸­æ•°å€¼ç›¸åŒçš„å…ƒç´ ï¼ˆé‡å¤å…ƒç´ ï¼‰æœ‰åº

å¦‚æœé¢˜ç›®æ²¡è¯´æ˜¯å¦æœ‰å¤´ç»“ç‚¹ï¼Œé»˜è®¤æœ‰

æ–¹æ³•2
<u>pre å’Œ påç§»ï¼Œ</u>
<u>å¦‚æœé‡åˆ°ç›¸åŒçš„ï¼Œç»™påé¢çš„é‚£ä¸ªç»“ç‚¹èµ‹å€¼ä¸ºqï¼Œè®©p->nextæŒ‡å‘q->nextï¼Œç„¶ååˆ é™¤q</u>
<u>æ¯æ¬¡å¾ªç¯éƒ½æ˜¯pre=p p=p->next</u>



æœ‰åºçš„æ“ä½œè§†é¢‘

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-07 18.41.54.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

//æ–¹æ³•2
void delete_same2(LinkList &L) {
    LNode *p = L->next;
    LNode *pre = L;
    LNode *q;

    while (p) {
        if (pre->next->data == p->next->data) {
            q = p->next;
            p->next = q->next;
            free(q);

        } 
        pre = p;
        p = p->next;
    }
}

void delete_same(LinkList &L) {
    LNode *p = L->next, *q;  // pæ˜¯å·¥ä½œæŒ‡é’ˆï¼Œå¤´ç»“ç‚¹åçš„ç¬¬ä¸€ä¸ªç»“ç‚¹
    if (p == NULL)return; // å¦‚æœå·²ç»æ²¡æœ‰ç»“ç‚¹äº†ï¼Œé‚£ä¹ˆå°±ä¸åšæ“ä½œ
    while (p->next != NULL) { // å¦‚æœpæŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªæ˜¯NULLï¼Œè¯´æ˜æ­¤æ—¶å·²ç»æœ‰åºäº†ï¼Œä¸éœ€è¦å’ŒNULLæ¯”äº†
        q = p->next;  // å¦‚æœpæœ‰åä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆæ ‡è®°ä¸ºq
        if (p->data == q->data) { // å¦‚æœpå’Œqç›¸ç­‰çš„è¯ï¼Œ
            p->next = q->next; // é‚£ä¹ˆå°±è¦è®©pæŒ‡å‘qçš„ä¸‹ä¸€ä¸ªç»“ç‚¹
            free(q); // ç„¶ååˆ é™¤q
        } else { // å¦‚æœpå’Œqä¸ç›¸ç­‰çš„è¯ï¼Œ
            p = p->next; // å°±è®©påç§»ä¸€ä½
        }
    }

}

int main() {
    int A1[] = {1, 4, 4, 5, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    delete_same(L1);
    print(L1);

//    print(L3);


    return 0;
}
```

æ— åºçš„æ“ä½œè§†é¢‘

å¦‚æœæ— åºå‘¢
å°±æ˜¯å‡å¦‚pæŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆæˆ‘æ˜¯ä¸æ˜¯éœ€è¦å¦ä¸€ä¸ªæŒ‡é’ˆæŠŠpåé¢çš„æ‰€æœ‰å…ƒç´ éå†ä¸€é
å…ˆè®©qæŒ‡å‘pçš„nextï¼Œç„¶ååˆ¤æ–­på’Œqæ˜¯å¦ç›¸åŒ

![image-20241007181822015](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181822015.png)

å¦‚æœä¸ç”¨ï¼Œé‚£ä¹ˆæˆ‘è®©qç»§ç»­å¾€åèµ°

![image-20241007181847331](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181847331.png)

å¦‚æœä¸€æ ·äº†ï¼Œé‚£ä¹ˆæˆ‘å°±æŠŠï¼Œæ­¤æ—¶çš„qç»™freeæ‰

![image-20241007181915935](/Users/yuebinghui/Documents/program/github/note/images/image-20241007181915935.png)

å¦‚æœä½ è¦æŠŠq freeæ‰ï¼Œæ˜¯ä¸æ˜¯å‰é¢éœ€è¦åŠ ä¸€ä¸ªå‰é©±äº†
å› ä¸ºå¦‚æœæˆ‘å…ˆåˆ é™¤5ï¼Œé‚£ä¹ˆæˆ‘éœ€è¦å…ˆæ‰¾åˆ°5çš„å‰é©±ï¼Œå¦‚æœä¸å…ˆæ ‡è®°ï¼Œæˆ‘å°±æ²¡æ³•æ‰¾5çš„å‰é©±

![image-20241007182006742](/Users/yuebinghui/Documents/program/github/note/images/image-20241007182006742.png)


Pæ˜¯ç¬¬ä¸€æ¬¡çš„æ—¶å€™ï¼Œå°±æ‹¿è¿™ä¸ªQä¾¿åˆ©æ•´ä¸ªåˆ—è¡¨ï¼Œç„¶åPå†å¾€åç§»ä¸€æ¬¡ï¼Œç„¶åå†æ‹¿Qéå†æ•´ä¸ªåˆ—è¡¨ã€‚

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-07 20.12.01.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

void delete_same(LinkList &L) {
    LNode *p = L->next;  // pæ˜¯å·¥ä½œæŒ‡é’ˆï¼Œå¤´ç»“ç‚¹åçš„ç¬¬ä¸€ä¸ªç»“ç‚¹
    LNode *q; // qç»“ç‚¹æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œç”¨æ¥æ¯”è¾ƒå¤§å°
    LNode *pre; // ç”¨æ¥æŒ‡å‘è¦åˆ é™¤ç»“ç‚¹çš„å‰é©±ç»“ç‚¹
    if (p == NULL)return;

    while (p && p->next != NULL) { // å› ä¸ºç¬¬92è¡Œçš„ p=p->nextå¯èƒ½è®©pä¸ºNULLï¼Œæ‰€ä»¥åŠ ä¸ªåˆ¤æ–­p &&
        q = p->next; // qæŒ‡å‘pçš„åç»§ç»“ç‚¹
        pre = p; // preæŒ‡å‘qçš„å‰é©±
        while (q != NULL) { // éå†påé¢çš„æ‰€æœ‰å…ƒç´ 
            if (p->data == q->data) { // p å’Œ q æ¯”ï¼Œå¦‚æœç›¸ç­‰äº†
                pre->next = q->next; // åˆ q
                free(q);
                q = p->next; //
            } else { // p å’Œ q æ¯”ï¼Œä¸ç›¸ç­‰ï¼Œå…ˆåŠ¨å‰é©±ï¼Œå†åŠ¨q
                pre = q;
                q = q->next;
            }
        }
        p = p->next; // éå†ä¸‹ä¸€ä¸ªé“¾è¡¨å…ƒç´ 
    }
}


int main() {
    int A1[] = {1, 4, 4, 2, 2, 3, 3, 7, 8, 8, 7, 5};
    LinkList L1;
    TailInsertList(L1, A1, 12);
//
//    int A2[] = {11, 22, 33};
//    LinkList L2;
//    TailInsertList(L2, A2, 3);
//
//    int A3[] = {40, 50, 60};
//    LinkList L3;
//    TailInsertList(L3, A3, 3);


    print(L1);
    delete_same(L1);
    print(L1);


//    print(L3);


    return 0;
}
```

##### 15. ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„åˆå¹¶

å¾ˆç®€ç­”å°±ä¸å½•è§†é¢‘äº†

![image-20241007205316768](/Users/yuebinghui/Documents/program/github/note/images/image-20241007205316768.png)

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}


// æˆ‘è¿™ç§æ˜¯ç›´æ¥æŠŠL1å’ŒL2æ‹†æˆäº†L3
void merge2(LinkList L1, LinkList L2, LinkList &L3) {
    LNode *p = L1->next;
    LNode *q = L2->next;
    LNode *r;
    r = L3;

    while (p && q) {
        if (p->data < q->data) {
            r->next = p;
            r = p;
            p = p->next;
        } else {
            r->next = q;
            r = q;
            q = q->next;
        }
    }

    if (q) p = q;
    while (p) {
        r->next = p;
        r = p;
        p = p->next;
    }
    r->next = NULL;


}



void merge(LinkList L1, LinkList L2, LinkList &L3) {
    LNode *p = L1->next;
    LNode *q = L2->next;
    LNode *r, *s;
    L3->next = NULL;
    r = L3; // å°¾æ’æ³•å¿…å¤‡æŒ‡é’ˆ

    while (p != NULL && q != NULL) { // æŸä¸€ä¸ªä¸ºé“¾è¡¨éå†å®Œæˆæ—¶ï¼Œç»“æŸå¾ªç¯
        s = (LNode *) malloc(sizeof(LNode));

        if (p->data < q->data) { // ä¸¤ä¸ªè¡¨å½“å‰æ‰€æŒ‡çš„æ•°æ®æ¯”å¤§å°ï¼Œè°å°è°å…ˆå­˜å…¥s
            s->data = p->data;
            p = p->next; // åç§»ä¸€ä½
        } else {
            s->data = q->data;
            q = q->next; // åç§»ä¸€ä½
        }

        // ç„¶åå°¾æ’æ³•
        r->next = s;
        r = s;
    }
    // å¿…å®šæœ‰ä¸€ä¸ªé“¾è¡¨å…ˆéå†å®Œæˆ
    // å¦‚æœqæ²¡æœ‰éå†å®Œï¼Œé‚£ä¹ˆpè‚¯å®šéå†å®Œäº†ï¼Œè®©p=qï¼Œä¸‹é¢ä»på¼€å§‹ç»§ç»­éå†
    // å¦‚æœqéå†å®Œäº†ï¼Œè¯´æ˜pæ²¡éå†å®Œï¼Œé‚£ä¹ˆè¿™ä¸ªifè¯­å¥å¿½ç•¥
    if (q != NULL) p = q;
    // ä»på¼€å§‹éå†ï¼Œä½™ä¸‹æ²¡æœ‰éå†çš„å…ƒç´ ï¼Œå¡å…¥L3
    while (p != NULL) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = p->data;
        r->next = s;
        r = s;
        p = p->next;
    }
    r->next = NULL;
}


int main() {
    int A1[] = {1, 3, 5};
    LinkList L1;
    TailInsertList(L1, A1, 3);
//
    int A2[] = {2, 4};
    LinkList L2;
    TailInsertList(L2, A2, 2);

    int A3[] = {};
    LinkList L3;
    TailInsertList(L3, A3, 0);


    print(L1);
    merge(L1, L2, L3);
    print(L3);


//    print(L3);


    return 0;
}
```

##### 16. è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œåˆ¤æ–­ä¸€ä¸ªå•é“¾è¡¨ä¸­å„ä¸ªç»“ç‚¹å€¼æ˜¯å¦æœ‰åº

ä¹Ÿç®€å•ï¼Œä¸å½•å±äº†

è¿™é‡Œçš„æ„æ€æ˜¯p p->next flagåŒæ—¶ä¸ºçœŸï¼Œwhileå¾ªç¯æ‰ä¼šç»§ç»­è¿è¡Œ

![image-20241007205847881](/Users/yuebinghui/Documents/program/github/note/images/image-20241007205847881.png)

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}

bool is_sort(LinkList L1, char flag) {
    LNode *p = L1->next;

    if (flag == 'p') {
        while (p->next) {
            if (p->data > p->next->data) {
                return false;
            }
            p = p->next;
        }
        return true;
    }

    if (flag == 'n') {
        while (p->next) {
            if (p->data < p->next->data) {
                return false;
            }
            p = p->next;
        }
        return true;
    }
    return true;
}

// å½“å‚æ•° c="a" æ—¶è¡¨ç¤ºé“¾è¡¨ä¸ºå‡åºï¼Œå½“å‚æ•°c="d"æ—¶è¡¨ç¤ºé“¾è¡¨ä¸ºé™åº
int is_sorted(LinkList L, char c) {
    int flag = 1; // é»˜è®¤æœ‰åºçš„
    LNode *p = L->next; // æŒ‡å‘å¤´ç»“ç‚¹åçš„ç¬¬ä¸€ä¸ªç»“ç‚¹

    // è¿™é‡Œçš„ä¸¤ä¸ªif æ¡ä»¶éƒ½æ˜¯æ²¡æœ‰ç­‰å·çš„ï¼Œæ‰€ä»¥ 1 2 2 3å°±åˆ¤æ–­ä¸ºæ— åºäº†ï¼Œ
    // å¦‚æœæƒ³è¦è®© 1 2 2 3ä¹Ÿæ˜¯æœ‰åºé‚£ä¹ˆï¼Œ
    // å˜æˆè¿™æ ·å°±å¥½äº† p->data <= p->next->data

    switch (c) {
        case 'a': // çœ‹ä½ æ˜¯å¦æ˜¯å‡åº
            while (p && p->next && flag) { // å¦‚æœå½“å‰æœ‰ç»“ç‚¹ï¼Œå¹¶ä¸”å½“å‰ç»“ç‚¹çš„ä¸‹ä¸ªç»“ç‚¹ä¹Ÿå­˜åœ¨ï¼Œå¹¶ä¸”flagä¸ºçœŸ è¿›å…¥ä»£ç å—
                if (p->data < p->next->data) { // å¦‚æœç»“ç‚¹å°äºä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè¯´æ˜å‡åº
                    p = p->next; // åç§»ä¸€ä½
                } else { // åä¹‹ï¼Œæ ‡è®°ä¸ºæ— åº
                    flag = 0;
                }
            }

            break;

        case 'd': // çœ‹ä½ æ˜¯å¦æ˜¯é™åº
            while (p && p->next && flag) { // å¦‚æœå½“å‰æœ‰ç»“ç‚¹ï¼Œå¹¶ä¸”å½“å‰ç»“ç‚¹çš„ä¸‹ä¸ªç»“ç‚¹ä¹Ÿå­˜åœ¨ï¼Œå¹¶ä¸”flagä¸ºçœŸ è¿›å…¥ä»£ç å—
                if (p->data > p->next->data) { // å¦‚æœç»“ç‚¹å¤§äºä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè¯´æ˜é™åº
                    p = p->next; // åç§»ä¸€ä½
                } else { // åä¹‹ï¼Œæ ‡è®°ä¸ºæ— åº
                    flag = 0;
                }
            }
            break;
    }
    return flag;
}


int main() {
    int A1[] = {5, 3, 3, 2, 1};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {2, 4};
//    LinkList L2;
//    TailInsertList(L2, A2, 2);
//
//    int A3[] = {};
//    LinkList L3;
//    TailInsertList(L3, A3, 0);

    print(L1);
    int flag = is_sorted(L1, 'd');
    printf("%d\n", flag);
//    print(L3);


//    print(L3);


    return 0;
}
```

##### 17. ğŸŒŸ åˆ é™¤æœ‰åºå•é“¾è¡¨ä¸­æ‰€æœ‰å€¼å¤§äºxè€Œå°äºyçš„ç»“ç‚¹

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-08 10.35.15.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}


// åˆ é™¤æœ‰åºå•é“¾è¡¨ä¸­æ‰€æœ‰å€¼å¤§äºxè€Œå°äºyçš„ç»“ç‚¹
void delete_x_y(LinkList &L, ElemType x, ElemType y) {
    LNode *pre = L;
    LNode *p = L->next;
    LNode *q;
    while (p && p->data <= x) { // æ‰¾åˆ°ç¬¬1ä¸ªå¤§äºxçš„ç»“ç‚¹çš„ä½ç½®ï¼Œå› ä¸ºæ­¤æ—¶preæ‰€æŒ‡çš„å°±æ˜¯è¦åˆ é™¤ç»“ç‚¹çš„å‰é©±
        pre = p; // å‰é©±å…ˆåŠ¨
        p = p->next; // ç„¶åå†åç§»ï¼Œä¸ç„¶å‰é©±å°±ä¸¢å¤±äº†
    }
    while (p && p->data < y) { // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºyçš„ç»“ç‚¹çš„ä½ç½®
        p = p->next;
    }

    q = pre->next; // qæŒ‡å‘äº†è¦åˆ é™¤çš„ç»“ç‚¹
    pre->next = p; // å°†è¦åˆ é™¤ç»“ç‚¹çš„å‰é©±ç»“ç‚¹é“¾æ¥åˆ°pï¼Œæ­¤æ—¶é“¾è¡¨å·²ç»å»é™¤äº†æ‰€æœ‰å¤§äºxè€Œå°äºyçš„ç»“ç‚¹
    pre = q->next; // è®©preæŒ‡å‘è¦åˆ é™¤ç»“ç‚¹çš„ä¸‹ä¸€ä¸ª

    // å¦‚æœqæ˜¯å½“æ—¶è¦åˆ é™¤çš„å…ƒç´ ï¼Œpæ˜¯ ç¬¬ä¸€ä¸ªå¤§äºç­‰äºyçš„ç»“ç‚¹çš„ä½ç½®
    // æ‰€ä»¥åªè¦q å’Œ pä¸ç­‰å°±ä¸€ç›´åˆ é™¤qï¼Œç›´åˆ°på’ŒqæŒ‡å‘åŒä¸€ä¸ªä½ç½®ï¼Œè¯´æ˜på‰é¢çš„è¦åˆ é™¤å…ƒç´ å°±éƒ½åˆ é™¤å®Œäº†
    while (q != p) {
        free(q); // åˆ é™¤q
        q = pre; // åç§»ä¸€ä½qæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸‹ä¸€ä¸ªè¦åˆ é™¤çš„å…ƒç´ 
        pre = pre->next; // preåç§»
    }
}


int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {2, 4};
//    LinkList L2;
//    TailInsertList(L2, A2, 2);
//
//    int A3[] = {};
//    LinkList L3;
//    TailInsertList(L3, A3, 0);


    print(L1);
    delete_x_y(L1, 1, 5);
    print(L1);


//    print(L3);


    return 0;
}
```

##### 18. åœ¨ä¸€ä¸ªå•é“¾è¡¨ä¸­å€¼ä¸ºyçš„ç»“ç‚¹å‰é¢æ’å…¥ä¸€ä¸ªå€¼ä¸ºxçš„ç»“ç‚¹

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-08 10.54.05.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L) {
    int A[] = {1, 4, 3, 3, 4, 5,};
    int size = sizeof(A) / sizeof(int);

    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}


// åœ¨ä¸€ä¸ªå•é“¾è¡¨ä¸­å€¼ä¸ºyçš„ç»“ç‚¹å‰é¢æ’å…¥ä¸€ä¸ªå€¼ä¸ºxçš„ç»“ç‚¹
bool delete_x_y(LinkList &L, ElemType y, ElemType x) {
    LNode *p;
    LNode *pre;
    p = L->next;
    pre = L;
    while (p && p->data != y) { // å½“p->data = yæ—¶åœæ­¢æŸ¥æ‰¾
        pre = p;
        p = p->next;
    }
    if (!p) return false;

    LNode *s = (LNode *) malloc(sizeof(LNode));
    s->data = x;
    s->next = pre->next;
    pre->next = s;
    return true;
}


int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);
//
//    int A2[] = {2, 4};
//    LinkList L2;
//    TailInsertList(L2, A2, 2);
//
//    int A3[] = {};
//    LinkList L3;
//    TailInsertList(L3, A3, 0);


    print(L1);
    delete_x_y(L1, 2, 15);
    print(L1);


//    print(L3);


    return 0;
}
```

##### 19. ğŸŒŸæ±‚å•é“¾è¡¨ä¸­çš„ä¸ªæ•°

æ³¨æ„å¾ªç¯é‡Œ p!=NULL å’Œ p->next!=NULL çš„åŒºåˆ« åè€…å½“ç„¶ä¼šå°‘å¾ªç¯ä¸€æ¬¡

```c++
#include "func.h"

#define ElemType int

typedef struct LNode {
    ElemType data;
    struct LNode *next;
} LNode, *LinkList;

// å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void print(LinkList L) {
    while (L->next != NULL) {
        L = L->next;
        printf("%d\n", L->data);
    }
    printf("\n");
}

void TailInsertList(LinkList &L, int A[], int size) {
    L = (LNode *) malloc(sizeof(LNode));
    LNode *s, *r;
    r = L;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        r->next = s;
        r = s;
    }

    r->next = NULL;
}

// ä¸å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨å»ºç«‹
void no_head_print(LinkList L) {
    while (L != NULL) {
        printf("%d\n", L->data);
        L = L->next;
    }
    printf("\n");
}

void no_head_TailInsertList(LinkList &L, int A[], int size) {
    LNode *s, *r;

    for (int i = 0; i < size; ++i) {
        s = (LNode *) malloc(sizeof(LNode));
        s->data = A[i];
        if (i == 0) {
            L = s;
            r = L;
        } else {
            r->next = s;
            r = s;
        }

    }
    r->next = NULL;
}

int Length(LinkList L) {
    int i = 0;
    while (L->next != NULL) {
        L = L->next;
        i++;
    }
    return i;
}



int count(LinkList L, int haveHead) {
    int count = 0; // ä»0å¼€å§‹æ•°æ•°ï¼Œå¯¹ç€å‘¢

    LNode *p = L; // é»˜è®¤æ²¡æœ‰å¤´ç»“ç‚¹
    if (haveHead) { // å¦‚æœæœ‰å¤´ç»“ç‚¹
        p = L->next;
    }

  // å¦‚æœæœ‰pç»“ç‚¹ï¼Œé‚£ä¹ˆå°±è¯´æ˜æœ‰ä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆå°±åŠ 1ï¼Œæœ‰ä¸€ä¸ªå°±åŠ ä¸€ä¸ª
    while (p) { 
        count++;
        p = p->next;
    }
    return count;
}


int main() {
    int A1[] = {1, 2, 3, 4, 5};
    LinkList L1;
    TailInsertList(L1, A1, 5);

//    int A1[] = {1, 2, 3, 4, 5};
//    LinkList L1;
//    no_head_TailInsertList(L1, A1, 5);
//
//    int A2[] = {2, 4};
//    LinkList L2;
//    TailInsertList(L2, A2, 2);
//
//    int A3[] = {};
//    LinkList L3;
//    TailInsertList(L3, A3, 0);


//    no_head_print(L1);
    int sum = count(L1, 1);
    printf("sum=%d\n", sum);

    print(L1);


//    print(L3);


    return 0;
}
```

# åŒé“¾è¡¨

![image-20241008122329325](/Users/yuebinghui/Documents/program/github/note/images/image-20241008122329325.png)

## 1.åŒé“¾è¡¨çš„æ’å…¥æ“ä½œ

![image-20241008133300222](/Users/yuebinghui/Documents/program/github/note/images/image-20241008133300222.png)

## 2.åŒé“¾è¡¨çš„åˆ é™¤æ“ä½œ

![image-20241008122424686](/Users/yuebinghui/Documents/program/github/note/images/image-20241008122424686.png)

##### 20. åœ¨åŒé“¾è¡¨ä¸­å€¼ä¸ºyçš„ç»“ç‚¹å‰æ’å…¥å€¼ä¸ºxçš„ç»“ç‚¹

<video src="/Users/yuebinghui/Documents/program/github/note/ç¬”è®°/æ•°æ®ç»“æ„/ä»£ç æ­¥éª¤è§†é¢‘/å±å¹•å½•åˆ¶2024-10-08 14.09.42.mov"></video>

```c++
#include "func.h"

#define ElemType int

typedef struct DLNode {
    ElemType data;
    DLNode *prior, *next;
} DLNode, *DLinklist;

bool InitDLinklist(DLinklist &DL) {
    DL = (DLNode *) malloc(sizeof(DLNode));
    DL->prior = NULL;
    DL->next = NULL;
    return true;
}

void print(DLinklist DL) {
    DL = DL->next;
    while (DL) {
        printf("%d\n", DL->data);
        DL = DL->next;
    }
    printf("\n");
}

bool tail_insert_list(DLinklist &DL, ElemType A[], int size) {
    DLNode *r = DL;

    for (int i = 0; i < size; ++i) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = A[i];

        s->next = r->next; //è®©å½“å‰ç»“ç‚¹çš„nextæŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹çš„next
        if (r->next) {
            r->next->prior = s;
        }
        s->prior = r; //è®©å½“å‰ç»“ç‚¹çš„æŒ‡é’ˆprioræŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
        r->next = s; // è®©å‰ä¸€ä¸ªç»“ç‚¹nextæŒ‡å‘å½“å‰ç»“ç‚¹
        r = s;
    }
    return true;
}

bool insert_x(DLinklist &DL, ElemType y, ElemType x) {
    DLNode *p = DL->next;
    while (p && p->data != y) {
        p = p->next;
    }

    // å› ä¸ºæ­¤æ—¶çš„pæŒ‡å‘çš„æ˜¯ï¼Œå…ƒç´ yï¼Œè€Œæˆ‘ä»¬è¦åœ¨yçš„å‰é¢å»åšæ’å…¥æ“ä½œï¼Œæˆ‘ä»¬æ˜¯åœ¨pç»“ç‚¹å‰æ’
    // ç‹é“ä¹¦çš„æ’å…¥æ“ä½œæ˜¯åœ¨pç»“ç‚¹çš„åé¢æ’å…¥ï¼Œæ‰€ä»¥è¦æ³¨æ„ä»£ç é¡ºåº
    if (p) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = x;

        // ä¸å¯ä»¥å…ˆåŠ¨pç»“ç‚¹çš„æŒ‡é’ˆï¼Œå› ä¸ºå¦‚æœå…ˆç»™pç»“ç‚¹çš„æŒ‡é’ˆèµ‹å€¼å°±ä¼šä½¿å¾—ä¸€ä¼šç»™sèµ‹å€¼çš„æ—¶å€™å‡ºé—®é¢˜
        // å…ˆæŠŠsç»“ç‚¹çš„next å’Œ priorèµ‹å€¼å¥½å†æ›´æ”¹pçš„æŒ‡é’ˆ
        s->next = p;
        s->prior = p->prior;

        p->prior->next = s;
        p->prior = s;
    }

    return true;
}

int main() {

    DLinklist DL;
    InitDLinklist(DL);
    ElemType A[] = {1, 2, 3, 4, 5};
    tail_insert_list(DL, A, 5);

    print(DL);
    insert_x(DL, 3, 10);
    print(DL);


    return 0;
}
```

##### 21. åˆ é™¤å¸¦å¤´ç»“ç‚¹çš„åŒé“¾è¡¨Lçš„ç¬¬iä¸ªå…ƒç´ 

```c++
#include "func.h"

#define ElemType int

typedef struct DLNode {
    ElemType data;
    DLNode *prior, *next;
} DLNode, *DLinklist;

bool InitDLinklist(DLinklist &DL) {
    DL = (DLNode *) malloc(sizeof(DLNode));
    DL->prior = NULL;
    DL->next = NULL;
    return true;
}

void print(DLinklist DL) {
    DL = DL->next;
    while (DL) {
        printf("%d\n", DL->data);
        DL = DL->next;
    }
    printf("\n");
}

bool tail_insert_list(DLinklist &DL, ElemType A[], int size) {
    DLNode *r = DL;

    for (int i = 0; i < size; ++i) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = A[i];

        s->next = r->next; //è®©å½“å‰ç»“ç‚¹çš„nextæŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹çš„next
        if (r->next) {
            r->next->prior = s;
        }
        s->prior = r; //è®©å½“å‰ç»“ç‚¹çš„æŒ‡é’ˆprioræŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
        r->next = s; // è®©å‰ä¸€ä¸ªç»“ç‚¹nextæŒ‡å‘å½“å‰ç»“ç‚¹
        r = s;
    }
    return true;
}

// è¿”å›ç¬¬iä¸ªä½ç½®çš„ç»“ç‚¹
DLNode *GetElem(DLinklist DL, int i) {
    DLNode *p = DL->next;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}

bool delete_i(DLinklist &DL, int i) {
    DLNode *p;
    if (i < 1) return false; // iå€¼ä¸åˆæ³•
    p = GetElem(DL, i);
    if (!p) return false;
    if (p->prior) {
        p->prior->next = p->next;
    }
    if (p->next) {
        p->next->prior = p->prior;
    }
    free(p);
    return true;
}

int main() {

    DLinklist DL;
    InitDLinklist(DL);
    ElemType A[] = {1, 2, 3, 4, 5};
    tail_insert_list(DL, A, 5);

    print(DL);
    delete_i(DL, 5);
    print(DL);


    return 0;
}
```

##### 22. ä»å³å¾€å·¦æ‰“å°ä¸€ä¸ªåŒé“¾è¡¨ä¸­å„ä¸ªç»“ç‚¹çš„å€¼

```c++
#include "func.h"

#define ElemType int

typedef struct DLNode {
    ElemType data;
    DLNode *prior, *next;
} DLNode, *DLinklist;

bool InitDLinklist(DLinklist &DL) {
    DL = (DLNode *) malloc(sizeof(DLNode));
    DL->prior = NULL;
    DL->next = NULL;
    return true;
}

void print(DLinklist DL) {
    DL = DL->next;
    while (DL) {
        printf("%d\n", DL->data);
        DL = DL->next;
    }
    printf("\n");
}

bool tail_insert_list(DLinklist &DL, ElemType A[], int size) {
    DLNode *r = DL;

    for (int i = 0; i < size; ++i) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = A[i];

        s->next = r->next; //è®©å½“å‰ç»“ç‚¹çš„nextæŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹çš„next
        if (r->next) {
            r->next->prior = s;
        }
        s->prior = r; //è®©å½“å‰ç»“ç‚¹çš„æŒ‡é’ˆprioræŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
        r->next = s; // è®©å‰ä¸€ä¸ªç»“ç‚¹nextæŒ‡å‘å½“å‰ç»“ç‚¹
        r = s;
    }
    return true;
}

// è¿”å›ç¬¬iä¸ªä½ç½®çš„ç»“ç‚¹
DLNode *GetElem(DLinklist DL, int i) {
    DLNode *p = DL->next;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}

bool print_right_to_left(DLinklist &DL) {
    DLNode *p = DL->next;
    // éå†åˆ°æœ€åä¸€ä¸ªç»“ç‚¹åœæ­¢
    while (p->next) {
        p = p->next;
    }

    // ä»æœ€åä¸€ä¸ªç»“ç‚¹å¾€å‰éå†ï¼Œå¹¶æ‰“å°å½“å‰ç»“ç‚¹å€¼
    // åœ¨å¤´ç»“ç‚¹åœæ­¢
    while (p->prior) {
        printf("p->data=%d\n", p->data);
        p = p->prior;
    }

    return true;

}

int main() {

    DLinklist DL;
    InitDLinklist(DL);
    ElemType A[] = {1, 2, 3, 4, 5};
    tail_insert_list(DL, A, 5);

    print(DL);
    print_right_to_left(DL);
    print(DL);


    return 0;
}
```

##### 23. è®¾è®¡ç®—æ³•ï¼Œå°†åŒé“¾è¡¨æ”¹ä¸ºå¾ªç¯åŒé“¾è¡¨

```c++
#include "func.h"

#define ElemType int

typedef struct DLNode {
    ElemType data;
    DLNode *prior, *next;
} DLNode, *DLinklist;

bool InitDLinklist(DLinklist &DL) {
    DL = (DLNode *) malloc(sizeof(DLNode));
    DL->prior = NULL;
    DL->next = NULL;
    return true;
}

void print(DLinklist DL) {
    DL = DL->next;
    while (DL) {
        printf("%d\n", DL->data);
        DL = DL->next;
    }
    printf("\n");
}

bool tail_insert_list(DLinklist &DL, ElemType A[], int size) {
    DLNode *r = DL;

    for (int i = 0; i < size; ++i) {
        DLNode *s = (DLNode *) malloc(sizeof(DLNode));
        s->data = A[i];

        s->next = r->next; //è®©å½“å‰ç»“ç‚¹çš„nextæŒ‡é’ˆæŒ‡å‘å‰ä¸€ä¸ªç»“ç‚¹çš„next
        if (r->next) {
            r->next->prior = s;
        }
        s->prior = r; //è®©å½“å‰ç»“ç‚¹çš„æŒ‡é’ˆprioræŒ‡å‘å‰ä¸€ä¸ªèŠ‚ç‚¹
        r->next = s; // è®©å‰ä¸€ä¸ªç»“ç‚¹nextæŒ‡å‘å½“å‰ç»“ç‚¹
        r = s;
    }
    return true;
}

// è¿”å›ç¬¬iä¸ªä½ç½®çš„ç»“ç‚¹
DLNode *GetElem(DLinklist DL, int i) {
    DLNode *p = DL->next;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    return p;
}

// è®¾è®¡ç®—æ³•ï¼Œå°†åŒé“¾è¡¨æ”¹ä¸ºå¾ªç¯åŒé“¾è¡¨
bool change(DLinklist &DL) {
    DLNode *p = DL->next;
    while (p->next) {
        p = p->next;
    }
    printf("p=%d\n", p->data);

    p->next = DL;
    DL->prior = p;
    return true;
}

int main() {

    DLinklist DL;
    InitDLinklist(DL);
    ElemType A[] = {1, 2, 3, 4, 5};
    tail_insert_list(DL, A, 5);

//    print(DL);
    change(DL);
//    print(DL); //è¿™é‡Œæ‰“å¼€å°±æ­»å¾ªç¯äº†ï¼Œå› ä¸ºæ²¡æœ‰åˆ¤å®šç»ˆæ­¢æ¡ä»¶ï¼Œå› ä¸ºè¿™ä¸ªé“¾è¡¨æ˜¯ä¸ªç¯


    return 0;
}
```
