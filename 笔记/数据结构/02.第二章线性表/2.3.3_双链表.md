各位同学大家好，在这个小节中我们会学习双链表相关的内容，那之前的小节中我们学习了单链表，在单链表当中由于每一个节点只包含。指向它的后继结点的指针，所以如果给定一个结点p的话，那么想要找到它的前驱结点是很麻烦的，那双链表呢？就是在单链表的基础上再增加一个指针域。这个指针prior是指向这个结点的前驱节点，那prior这个单词的意思是先前的还有一个很有趣的意思，叫南修道院副院长。好，那我们的一个双链表当中的节点，我们把它命名为d node这的d，其实指的是double。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923204156443.png" alt="image-20240923204156443" style="zoom:50%;" />

好，那来看一下怎么从无到有创建一个双链表，那这个地方我们讨论的是带头结点的情况，首先这个地方声明了一个指向头结点的指针L。然后调用双链表的这个初始化函数，这句代码会申请一片空间用来存放头结点。并且让指针L指向这个头结点，然后接下来需要把这个头结点的前向指针和后向指针都设为null。这个头结点之前肯定不会再有其他的结点了，所以这个头结点的prior指针域肯定是永远都指向n的。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923204737110.png" alt="image-20240923204737110" style="zoom:50%;" />

好，那这个地方我们做了类似于单链表那样的啊，类型的重命名，那这儿和单链表那边类似，有的地方使用d link list是想强调这个东西，
它是一个链表。而有的地方，我们使用d node新是想强调这个东西，它是一个节点。好，那这块内容我们在单链表的定义那一小节中重点强调过，所以这个地方就不再展开。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923204809156.png" alt="image-20240923204809156" style="zoom:50%;" />

好，那对于带头结点的这种双链表来说，如果要判断它是否为空的话，是不是只需要判断这个头结点的next指针是？是否等于none就可以了，如果等于none的话，说明这个表此时暂时还没有存入任何数据元素。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923204836956.png" alt="image-20240923204836956" style="zoom:50%;" />

好，
那接下来看一下双链表的插入怎么实现我们的课本当中给出了这样的几行代码，也就是说要在p结点之后插入s这个结点。好第一步会把s结点的next指针指向p结点的下一个结点，也就是这个样子，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205040730.png" alt="image-20240923205040730" style="zoom:50%;" />

第二步会把p结点的后继结点它的前向指针。指向此次新插入的s，这个结点也就是这个样子，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205119453.png" alt="image-20240923205119453" style="zoom:50%;" />

第三步把s结点的前向指针指向p结点也就是这样。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205204411.png" alt="image-20240923205204411" style="zoom:50%;" />

第四步，再把p结点的后向指针指向s结点，也就是这样，这就完成了p结点的后插操作，在它的后面插入s结点。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205229183.png" alt="image-20240923205229183" style="zoom:50%;" />

不过呢，如果这个p结点，
它刚好是双链表的最后一个结点的话，那第二句执行是不是会出现问题啊？因为p的next是n嘛，所以这一句肯定会有一个空指针的错误。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205255012.png" alt="image-20240923205255012" style="zoom:50%;" />

因此，这段代码其实我们可以把它写的更严谨一点，这儿加一个if语句来处理p结点，没有后继结点的这种情况好，那来看一下，假设现在p结点是最后一个结点。那第一句代码会让s结点的next指针指向p结点的next指针相同的位置，也就是同样是指向null。然后第二句先判断p结点，此时还有没有后继结点，如果它没有后继结点的话，
那当然就不需要再修改它后继结点的前项指针。因此，在这种情况下，if条件不满足，会跳到之后一句执行

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205430909.png" alt="image-20240923205430909" style="zoom:50%;" />

让s结点的前向指针。指向p结点。第四句再把p结点的后向指针指向新插入的s结点，那加了这句代码之后是不是后插操作就没有问题了？

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205550062.png" alt="image-20240923205550062" style="zoom:50%;" />

那大家自己写代码的时候需要注意修改这些指针的一个啊，语句的顺序修改指针的这些语句，如果语序不合理的话，那么有可能会导致一些错误。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205616532.png" alt="image-20240923205616532" style="zoom:50%;" />



比如说如果我们写代码的时候没注意把四这一句写在了前面，先执行四再执行一的话，那么首先四这一句会让p结点的next指针指向此次的新结点s。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205747050.png" alt="image-20240923205747050" style="zoom:50%;" />

接下来执行第一句会让s结点的next指针和p结点的next指针指向同一个位置，也就是会指向s结点它自己。那这种情况肯定是错误的，所以大家自己写代码的时候修改这些指针的时候啊，需要注意一下，特别是跨考的同学。

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923205858155.png" alt="image-20240923205858155" style="zoom:50%;" />

好，那这个地方我们介绍双链表的插入，其实指的是后插操作对吧？就是在p结点之后。插入s这个节点，其实只要搞定了后插操作，那么按位去插入，或者一个节点的前插操作，这些都很容易实现。
如果我们想要按位序插入一个新的节点的话，那么我们是不是只需要从头节点开始找到某一个位序的前去节点，然后对这个前去节点执行？后插操作就可以了，

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240923210118499.png" alt="image-20240923210118499" style="zoom:50%;" />

而如果我们想要在某一个节点前面进行一个前插操作的话，那么由于双链表的这种特性，我们可以很方便的找到给定节点的前。前驱节点，然后再对它的前驱节点执行后插操作，这样的话我们就可以实现所谓的前插操作，也就是其他的这些插入操作，其实最终都可以转换成用这个后插来实现。好，接下来看怎么实现双链表的删除，假设我们此次要删除的是指定结点p的后极结点q结点。
第一句代码会让p结点的next指针指向q结点的next指针相同的位置，也就是指向q的后极结点。第二句代码会把q结点的后继结点的前向指针指向p结点，也就是这个样子。第三句代码在释放q结点，这样的话就完成了对q结点的删除，不过和刚才一样，这个代码也是有一点点问题的，如果此次要删除的结点q刚好是双链表的最后一个结点的话。那么，第二句代码同样是会出现一个空指针的错误。所以我们可以增加一些条件判断，用来提升这个代码的健壮性好。假设此次我们要删除的是给定结点p的后继，结点的话，
那么首先。这儿会声明，一个q指针让q指针指向p的后极结点，如果q=null的话，那说明p结点是没有后极结点的。这种情况下，返回FALSE。好，那接下来首先是让p结点的next指针指向q结点的next指针相同的位置，也就是这样子。再往后，我们需要先判断一下q结点还有没有后继结点，如果q结点有后继结点的话，那么我们才会尝试修改它后继结点的前向指针。那像这种情况q结点之后已经没有其他结点了，
所以这个if的条件不满足，因此就会直接把q结点释放掉。好，那实现了这个删除操作之后，如果我们想要销毁一个双链表的话，那我们是不是可以用一个while循环每一次都删除这个头结点的后继结点？依次把这些结点占用的空间给释放掉，直到头结点之后再无其他结点，也就是说这个表变空了。最后再把这个头结点占的空间也给释放掉，然后让头指针指向，那这样的话，我们是不是就可以销毁一个双链表？好，最后来看一下双链表的遍历怎么实现，
其实很简单，就是这样一个while循环，每一次循环让p指针指向下一个结点。然后在这个循环的内部，可以对此次p指针指向的节点做相应的处理，比如说要打印出这个节点的数值啊之类的。那前向变力是不是也一样的？给你一个指定的结点p，然后每一次你让这个p指针往前移一位。然后在这个while循环里对结点p做相应的处理就可以了。好，那如果你在这个循环里边，只想处理那些数据结点，并不想处理头结点的话，那只需要把这个while循环的条件给改一下就行了。
如果说p结点的前项指针已经等于null的话，那么说明此时p结点指向的就已经是头结点了。这样的话，while循环条件不满足，也就不会对当前p结点指向的这个头结点进行处理。好，那只要知道怎么遍历一个双链表，那本质上按位查找，按置查找这些操作核心代码就是这样一个便利，对吧？如果你要实现按位查找的话，那么在这循环里边，你只需要累加一个计数器用于记录，此时我指向的是哪个位序的元素就可以了？而如果你要按值查找的话，
在这个循环里边是不是你只需要对当前指向的这个结点进行一个值的对比就可以？好，那由于双链表，它并没有随机存取的特性，所以这种查找操作时间复杂度就是on这个量级。因为你只能用这种循环的方式，一个一个对比，依次往后找好，那这个小节的内容很简单，其实对双链表的这些操作的实现和单链表本质上没有太大的区别。只不过双链表，它就是多了一个前向的指针嘛，所以大家在写代码的时候，只需要注意这些指针它怎么修改，然后不要出错就可以了。
然后当我们实现插入和删除相关的代码的时候，大家可能要注意一下，如果此次插入的是最后一个位置或者被删除的节点是最后一个节点的话。那严格一点来说，书上给的那个代码逻辑是有一点点bug的。那基础不好的同学也需要注意便利操作，它的循环应该怎么实现怎么写。好的，那以上就是这个小节的全部内容。