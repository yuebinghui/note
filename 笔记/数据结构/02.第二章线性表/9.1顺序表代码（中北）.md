概念也要看看，不过后面看把，要记忆的

学姐有王道电子书，可以要下

学习一个题目，最好要会画出它的手动过程，这样你记忆代码逻辑根号记忆

记住length是顺序表当前有多少个元素 
maxsize是顺序表可以放多少个元素

第二章所有的代码都要掌握，会写

第二章都会考到，第二章不管考哪个学校都是重点，学姐的第二章里有一部分王道的课后题

链表一直看到35页结束（稍微看一下，不懂标记出来，上课问，实在看不懂就不看了）

顺序表每一个都讲过了

国庆最好多上一点课，上课完尽快消化

王道的选择题往后考考，其实学姐的题部分也是王道的题，加上学姐找的其他资料

# 线性表

## 线性表的顺序表示-顺序表

###### 顺序表的初始化和插入

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    return true;
}

// i是位序 从1开始
// 数组下标从0开始
// 比如MaxSize 是10
// 比如要插入的i是3

bool InsertList(SqList &L, int i, ElemType e) {
    // 这里小于1是因为位序从1开始，不能比1小
    /*
        i > L.length+1 是因为比如我数组有5个元素，L.length为5，我索引是 0 1 2 3 4
        比如插入一个100，位序是8，那么如果没有 i > L.length+1 这个条件，就会把100插入到索引为7的位置
        值   1 2 3 4 5 空 空 100 空 空
        索引 0 1 2 3 4 5  6  7   8  9
        就会造成这样的空隙
        所以当一共有5个元素，此时索引是0~4，
        那么你位序最多插入的就是<=L.length的位置，即1 2 3 4 5
        也就是位序大于5就会产生空隙了，就不能插入
     */
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    // 我数组已经满了，就不插入元素了
    if (L.length >= MaxSize) {
        return false;
    }
    // j=L.length 就是第一次执行的时候，先把索引为L.length的位置里放入索引为L.length-1的元素
    for (int j = L.length; j >= i; j--) {
        // 就是把前一个元素数据放到后一个元素里
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    // 插入一个元素后length++
    L.length++;
    return true;
}

int main() {
    SqList L;
    InitList(L);


    return 0;
}
```

###### 1. 将两个有序顺序表合并为一个新的有序顺序表，并由函数值返回结果

就是函数返回类型那里，除了常见的int float bool 还可以返回自己自定义的struct结构类型数据

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927141858410.png" alt="image-20240927141858410" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// 将两个有序顺序表合并为一个新的有序顺序表，并由函数值返回结果
bool Merge(SqList L1, SqList L2, SqList &L3) {
    // 两个表相加的长度不可以大于 L3的最大长度，放不下
    if (L1.length + L2.length > L3.maxSize) {                        
        return false;
    }
    // i是L1的索引 j是L2的索引 k是L3的索引
    int i = 0, j = 0, k = 0;

    // 1️⃣遍历L1 和 L2，从0到length，就是遍历整个L1或者L2 哪个表Length短就先遍历完
    while (i < L1.length && j < L2.length) {
        // 拿L1和L2的第一个元素去作比较，哪个小哪个先放入L3
        if (L1.data[i] <= L2.data[j]) {
            // 先把L1的第i个元素放到L3的k的索引上，然后k++ i++
            L3.data[k++] = L1.data[i++];
        } else {
            // 先把L2的第j个元素放到L3的k的索引上，然后k++ j++
            L3.data[k++] = L2.data[j++];
        }
    }

    /*
     检查看L1是否没有遍历完成，没有的话，就把L1剩下的数据，都依次放到L3中
     下面的两个while循环只会执行其中一个，因为1️⃣处那里的条件就是以L1或者L2其中一个遍历完成为结束条件的
     */
    while (i < L1.length) {
        L3.data[k++] = L1.data[i++];
    }
    // 检查看L2是否没有遍历完成，没有的话，就把L2剩下的数据，都依次放到L3中
    while (j < L2.length) {
        L3.data[k++] = L2.data[j++];
    }
    // 最后把k赋值给L3的length
    L3.length = k;
    return true;
}

int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1, j = 1, k = 1; i <= 10; ++i) {
        if (i % 2 == 1) {
            InsertList(L1, j++, i);
        } else {
            InsertList(L2, k++, i);
        }
    }

//    print(L1);

//    print(L2);

    Merge(L1, L2, L3);
    print(L3);


    return 0;
}
```

建立3个索引,i j k 遍历两个L1 L2 顺序表，遍历过程中i 和 j 两个元素的每项元素作比较，如果哪个小哪个先放入到L3中，再把i 或者 j 的索引后移，k也后移，当i或者j的某个顺序表遍历完成的时候，说明已经i或者j的某一个顺序表中的元素已经全部放入到L3中，剩下的那个表中的元素就全部是比L3中大的元素了，然后再遍历i 或者j的元素，全部塞入L3中

不懂就自己画图理解

<video src="/Users/yuebinghui/Desktop/屏幕录制2024-09-30 18.51.01.mov"></video>



###### 2. 将顺序表L1中的数据分类，奇数放到L2中，偶数放到L3中

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 将顺序表L1中的数据分类，奇数放到L2中，偶数放到L3中
bool split(SqList L1, SqList &L2, SqList &L3) {
    int i, j, k;
    i = j = k = 0;

    // 遍历L1这个顺序表
    for (; i < L1.length; ++i) {
        //判断当L1的元素是奇数的时候
        if (L1.data[i] % 2 == 1) {
            // 赋值给L2并且让L2的索引++，后加加
            L2.data[j++] = L1.data[i];
        } else {
            // 如果是偶数，赋值给L3并且让L3的索引++，后加加
            L3.data[k++] = L1.data[i];
        }
    }

    L2.length = j;
    L3.length = k;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }

//    print(L1);
    split(L1, L2, L3);
//    print(L2);

    print(L2);
    print(L3);


    return 0;
}
```

遍历L1这个顺序表，遍历的过程中判断是奇数还是偶数，奇数放入L2，偶数放入L1

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240927151502394.png" alt="image-20240927151502394" style="zoom:30%;" />

###### 3. L1，L2分别存放两个整数集合，实现L1与L2的交集存放在L3中

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;


void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

bool InitList(SqList &L) {
    L.length = 0;
    return true;
}

bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1)return false;
    if (L.length == MaxSize)return false;

    for (int j = L.length; j >= i; --j) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

// 方法1 循环执行次数最多，因为双层循环都执行了
//void intersection(SqList L1, SqList L2, SqList &L3, int &count) {
//    int i, j, k;
//    i = k = 0;
//    // 遍历L1这个顺序表
//    for (; i < L1.length; i++) {
//        for (j = 0; j < L2.length; j++) {
//            if (L1.data[i] == L2.data[j]) {
//                L3.data[k++] = L1.data[i];
//            }
//            count++;
//        }
//    }
//    L3.length = k;
//}

// 方法2 找到内层的一样的值就会停下，比方法1少
//void intersection(SqList L1, SqList L2, SqList &L3, int &count) {
//    int i, j, k;
//    i = k = 0;
//
//    // 遍历L1这个顺序表
//    for (; i < L1.length; i++) {
//        // 重置j 不然在一次while循环进入条件的遍历后，j的值会j++ 加上去，当i=2进来的时候没有重置j为0会有问题
//        j = 0;
//        // 遍历L2这个顺序表 并且 找L2里与L1相等的元素，如果不等就j++，直到找到相等的，或者遍历完整个L2顺序表
//        while (j < L2.length && L1.data[i] != L2.data[j]) {
//            j++;
//            count++;
//        }
//        // 看上面的while循环是不满足 && 左右哪边的条件，如果是不满足右边的条件跳出循环的，说明有交集，就要赋值给L3
//        if (j < L2.length) {
//            L3.data[k++] = L1.data[i];
//        }
//    }
//    L3.length = k;
//}


// 方法3 j就不重置0了，因为j如果加1了说明你已经放到L3了，那么我就看你下一个j是不是与i一样，一样就放入，
bool intersection(SqList L1, SqList L2, SqList &L3, int &count) {
    int i, j, k;
    i = 0;
    k = 0;
    j = 0;

    while (i < L1.length) {
        while (j < L2.length && L1.data[i] == L2.data[j]) {
            L3.data[k++] = L2.data[j];
            j++;
            count++;
        }
        i++;
    }
    L3.length = k;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);
    SqList L2;
    InitList(L2);
    SqList L3;
    InitList(L3);

    int arr1[4] = {1, 9, 3, 7};
    int size1 = sizeof(arr1) / sizeof(ElemType);
    printf("size1=%d\n", size1);
    for (int i = 0; i < size1; ++i) {
        InsertList(L1, i + 1, arr1[i]);
    }
//
    int arr2[3] = {3, 7, 5};
    int size2 = sizeof(arr2) / sizeof(ElemType);
    for (int i = 0; i < size2; ++i) {
        InsertList(L2, i + 1, arr2[i]);
    }

    int count = 0;
    intersection(L1, L2, L3, count);
    printf("count=%d\n", count);
//    Print(L1);
//    Print(L2);
    Print(L3);

    return 0;
}
```

方法1，双层循环遍历，拿出比如外层循环一个元素和内层循环的元素一一比较，如果相等就放入L3
方法2，感觉很笨，也是双层循环，内层里用k去找相等的，找到就停下来，然后再用一个条件去判断是否遍历完了整个表，如果遍历完了整个表说明没有相等的，如果没有遍历完说明有相等的需要赋值，（这里其实可以和方法1一样直接找到相等的就赋值就好了，就会省下一个if条件）

###### 4. 将顺序表L中所有奇数调整到表的左边，所有的偶数调整到表右边

从左往右找，找到不是奇数就停了，
从右往左找，找不到不是偶数就停了，
然后两个交换位置



结束条件有两种情况，第一种是i==j，不满足条件就跳出循环了，另一种是i>j这种情况，这两种情况都是结束

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928183811355.png" alt="image-20240928183811355" style="zoom:50%;" />



1处：
因为左边放的是奇数嘛，所以我找到偶数就停了
因为右边放的是偶数吗，所以我找到奇数就停了
然后把此时i 和 j 的索引的数据元素交换位置
然后换完后，我就i++ j++一下

然后再次循环，执行1处的步骤

视频里有点问题，最后实际是 j=3 i=4

<video src="/Users/yuebinghui/Desktop/屏幕录制2024-09-30 20.41.28.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 方法2
void adjustOddEven(SqList L) {
    int i, j;
    ElemType x;
    i = 0;
    j = L.length - 1;
    while (i < j) {
        if (i < j && L.data[i] % 2 == 1) {
            i++;
        }
        if (i < j && L.data[j] % 2 == 0) {
            j--;
        }

        if (i < j) {
            x = L.data[i];
            L.data[i++] = L.data[j];
            L.data[j--] = x;
        }
    }
    printf("i=%d j=%d\n", i, j);
}

// 将顺序表L中所有奇数调整到表的左边，所有的偶数调整到表右边
void change(SqList &L) {
    int i, j; // 两个索引分别指向顺序表头尾
    ElemType x; // 用来临时存放数据的元素
    i = 0; // i指向顺序表头部
    j = L.length - 1; // j指向顺序表尾部

    do { // 先执行代码，再判断条件 当不满足i<j时停止循环
        while (i < j && L.data[i] % 2 == 1) { // 当前位置是奇数就继续看下一个位置，在偶数的时候停下
            i++;
        }
        while (i < j && L.data[j] % 2 == 0) { // 当前位置是偶数就继续看下一个位置，在奇数的时候停下
            j--;
        }
        /*
            i<j说明i是偶数，j是奇数，所以交换位置
            二者相等，的话同一个数字不需要换
         */
        if (i < j) {
            x = L.data[i];
            L.data[i++] = L.data[j];
            L.data[j--] = x;
        }
    } while (i < j);


}

int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

//    print(L1);
    change(L1);
    print(L1);

//    print(L2);

//    print(L3);
    return 0;
}
```



###### 5. 顺序表就地逆置

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928190955656.png" alt="image-20240928190955656" style="zoom:40%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 顺序表就地逆置
void Reverse(SqList &L) {
    int i, j; // 定义两个标记
    i = 0; // 指向表头
    j = L.length - 1; // 指向表尾
    ElemType x;
    while (i < j) { // 如果i++ j--两个慢慢靠近，j=i或者i>j停下
        x = L.data[i];
        L.data[i++] = L.data[j];
        L.data[j--] = x;
    }
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

    Print(L1);
    Reverse(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 6. 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1)

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928192831811.png" alt="image-20240928192831811" style="zoom:30%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O(1);
void Reverse(SqList &L) {
    ElemType temp; // 暂存数据
    for (int i = 0; i < L.length / 2; ++i) { // 将数组对半掰开，只遍历一半 两两互换
        temp = L.data[i];
        L.data[i] = L.data[L.length - 1 - i];
        L.data[L.length - 1 - i] = temp;
    }
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    for (int i = 1; i <= 10; ++i) {
        InsertList(L1, i, i);
    }
    for (int i = 1; i <= 10; ++i) {
        InsertList(L2, i, i + 5);
    }

    Print(L1);
    Reverse(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 7. 对于长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，该算法删除线性表中所有值为x的数据元素

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928200845984.png" alt="image-20240928200845984" style="zoom:50%;" />

<video src="/Users/yuebinghui/Desktop/屏幕录制2024-10-01 19.51.48.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 对于长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，改算法删除线性表中所有值为x的数据元素
void Delete_x(SqList &L, ElemType x) {
    int i, k;
    i = k = 0;
    // i删除前叫原表，k删除后叫新表，但其实都是在一个表里操作的，索引不同
    for (; i < L.length; ++i) {
        // 遍历原表，如果不等于x，就把不等于x的数存到索引为k的表里，就是换了个索引，还是在用一个表里
        // 如果匹配到x了，这个循环什么操作都不做
        if (L.data[i] != x) {
            //因为是在同一个表中操作的，所以空间复杂度就是O(1)，只不过是把原来的索引i变成了k
            L.data[k++] = L.data[i];
        }
    }
    L.length = k; //给顺序表赋值新表表长
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    int arr[10] = {1, 8, 3, 4, 5, 8, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_x(L1, 8);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```



###### 7.1 7.0的第二种解法

原表索引为i
k记录有多少个x元素
新表里存的是没有x元素的个数，所以就是L.length - k

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928203935481.png" alt="image-20240928203935481" style="zoom:50%;" />

<video src="/Users/yuebinghui/Desktop/屏幕录制2024-10-01 20.09.42.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 对于长度为n的顺序表L，编写一个时间复杂度为O(n)，空间复杂度为O(1)的算法，改算法删除线性表中所有值为x的数据元素
// 解法2
void Delete_x(SqList &L, ElemType x) {
    int i, k;
    i = k = 0;

    while (i < L.length) {
        if (L.data[i] == x) {
            k++; // k记录等于x的元素的个数
        } else {
            L.data[i - k] = L.data[i]; //当前元素前移k个位置
        }
        i++;
    }
    L.length -= k; // 顺序表长度减去k
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

    int arr[10] = {1, 8, 3, 4, 5, 8, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_x(L1, 8);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 8. 从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同

我让i=0，j=1，我要看i和j所指的元素是否相同，如果相同就删除一个，不同就往后走

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240928204443301.png" alt="image-20240928204443301" style="zoom:50%;" />

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同
bool Delete_same(SqList &L) {
    if (L.length == 0) {
        return false;
    }
    int i, j; // i存储第一个不相同的元素，j作为工作指针
    for (i = 0, j = 1; j < L.length; j++) {
        // 如果i和j的值不相等了，就让i指针先往后移动一位，然后存入j的值
        // 如果i和j的值相等，那么就让j往后走，直到遇到不等的，再让i指针先往后移动一位，然后存入j的值
        if (L.data[i] != L.data[j]) { // 查找下一个与上一个元素不同的值
            L.data[++i] = L.data[j];
        }
    }
    L.length = i + 1;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_same(L1);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 9. 从顺序表中删除其值在给定值s与t之间（要求s<t，包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行

就是s与t，比如我要删除值为2~7中间的所有元素，包含2和7，那么s就是2，t就是7

<video src="/Users/yuebinghui/Desktop/屏幕录制2024-09-29 15.46.35.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 从顺序表中删除其值在给定值s与t之间（要求s<t，包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行
bool Delete_s_t(SqList &L, ElemType s, ElemType t) {
    if (L.length == 0 || s >= t) {
        return false;
    }
    int i, k;
    i = k = 0;
    for (; i < L.length; i++) {
        if (L.data[i] >= s && L.data[i] <= t) { // 如果你L.data[i]在这个范围内我就不要你
            k++;
        } else { // 不在这个范围内的i项我才赋值给你 i-k
            L.data[i - k] = L.data[i]; // 当前元素，往前移动k个位置，因为我忽略了k个元素
        }
    }
    L.length -= k;// k是多少，说明有多少个在[s,t]区间内的元素，也说明删除了k个
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_s_t(L1, 2, 7);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 10. 从有序顺序表中删除其值在给定值s与t之间（要求s<t，包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行

我找到这个区间后，光把这个区间删除就好了



<video src="/Users/yuebinghui/Desktop/屏幕录制2024-09-29 16.52.49.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 闭区间即包含s t
// 从有序顺序表中删除其值在给定值s与t之间（要求s<t，包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行
bool Delete_s_t(SqList &L, ElemType s, ElemType t) {
    if (L.length == 0 || s >= t) {
        return false;
    }
    int i, j;
    // 找到第一个大于等于s的元素 因为要去掉[s,t]内的元素
    // 所以一会要覆盖掉这个等于s的元素
    for (i = 0; i < L.length && L.data[i] < s; i++);
    if (i >= L.length) return false;// 说明都比s小，不用删除
    // 找到第一个大于t的元素，要找到大于的元素
    // 因为下面要把[s,t]范围外的元素放到新表里
    for (j = i; j < L.length && L.data[j] <= t; j++);

    for (; j < L.length;) {
        L.data[i] = L.data[j];
        j++;
        i++;
    }
    L.length = i;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[7] = {1, 2, 3, 4, 5, 6, 7};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_s_t(L1, 3, 5);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

上面是闭区间
下面是开区间

<video src="/Users/yuebinghui/Desktop/屏幕录制2024-09-29 17.03.58.mov"></video>

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}

// 开区间即不包含s t
// 从有序顺序表中删除其值在给定值s与t之间（要求s<t，不包含s t）的所有元素，若s或t不合理或顺序表为空，则退出运行
bool Delete_s_t(SqList &L, ElemType s, ElemType t) {
    if (L.length == 0 || s >= t) {
        return false;
    }
    int i, j;
    // 找到第一个大于s的元素 因为要去掉(s,t)不包括s t的元素
    for (i = 0; i < L.length && L.data[i] <= s; i++);
    if (i >= L.length) return false;// 说明都小于等于s，不用删除
    // 找到第一个大于等于t的元素，要找到大于等于的元素
    // 因为下面要把(s,t)的元素放到新表里
    for (j = i; j < L.length && L.data[j] < t; j++);

    for (; j < L.length;) {
        L.data[i] = L.data[j];
        j++;
        i++;
    }
    L.length = i;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[7] = {1, 2, 3, 4, 5, 6, 7};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Delete_s_t(L1, 3, 5);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 11. 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值，空出的位置由最后一个元素填补，若顺序表为空，则显示出错误信息并退出运行

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值，空出的位置由最后一个元素填补，若顺序表为空，则显示出错误信息并退出运行
bool Delete_min(SqList &L, ElemType &value) {
    if (L.length == 0) {
        return false;
    }
    value = L.data[0]; // 假定顺序表里第一个元素是最小值
    int pos = 0;
    int i;
    for (i = 1; i < L.length; i++) { // i从1开始，然后拿依次拿工作指针i和最小值去比
        if (L.data[i] < value) { //如果当前项比value还小
            value = L.data[i]; //那么赋值给value
            pos = i; //索引也记录下来
        }
    }
    L.data[pos] = L.data[L.length - 1]; //最后把最后一个元素赋值给最小值
    L.length--; //然后删除一位，长度减一
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[7] = {7, 9, 15, 6, 21, 3, 8};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    ElemType value;
    Delete_min(L1, value);
    printf("value=%d\n", value);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 12. 已知在一维数组A[m+n]中，依次存放两个线性表(a1,a2,a3,...,am)和(b1,b2,b3,...,bn)，试编写一个函数，将数组中两个顺序表的位置互换，即 将(b1,b2,b3,...,bn)放在(a1,a2,a3,...,am)的前面

i其实就是我整体数组或者说是左边或者右边的，开始去便利它

mid-left的意思就是，中间减去左边，因为我要1个1个要遍历到中间嘛

我整体这个和左边这个都是从0开始的，和之前讲的某个题是一样的

<img src="/Users/yuebinghui/Documents/program/github/note/images/image-20240929201526186.png" alt="image-20240929201526186" style="zoom:50%;" />

但是我右边的话，右边的值不等于0，所以从left开始到mid减left

右边这个虽然我i是从0开始的，但是其实，实际是从n开始的，因为左边那部分是从b1~bn-1
所以我右边这个数组下标是从n开始的，所以要到mid-left截止，反正这块你自己看下代码就明白了

不行就画图走一遍就懂了

```c++
#include "func.h"

#define ElemType int

void PrintArr(int A[], int size) {
    for (int i = 0; i < size; ++i) {
        printf("%d\n", A[i]);
    }
    printf("\n");
}


// 已知在一维数组A[m+n]中，依次存放两个线性表(a1,a2,a3,...,am)和(b1,b2,b3,...,bn)，试编写一个函数，
// 将数组中两个顺序表的位置互换，即 将(b1,b2,b3,...,bn)放在(a1,a2,a3,...,am)的前面
bool Reverse(int A[], int left, int right, int arraySize) {
    if (left >= right || right >= arraySize) {
        return false;
    }
    int mid = (left + right) / 2; // 计算中间索引，用于确定需要交换的元素范围的一半。
    for (int i = 0; i <= mid - left; ++i) { // 循环遍历从left到mid的元素，并与从right到mid的元素进行交换。
        int temp = A[left + i]; // 临时存储当前left位置的元素。
        A[left + i] = A[right - i]; // 将right位置的元素赋值给left位置。
        A[right - i] = temp; // 将临时存储的left位置的元素赋值给right位置。
    }
    return true;
}
void Exchange(int A[], int m, int n, int arraySize) {
    Reverse(A, 0, m + n - 1, arraySize); // 反转整个数组。
    Reverse(A, 0, n - 1, arraySize); // 反转前n个元素。
    Reverse(A, n, m + n - 1, arraySize); // 反转后m个元素。
}
int main() {
    int A[] = {1, 2, 3, 4, 5, 6};
    int arraySize = sizeof(A) / sizeof(A[0]);
    PrintArr(A, arraySize);

    int m = 2; // 前两个元素
    int n = 4; // 后四个元素
    Exchange(A, m, n, arraySize);

    PrintArr(A, arraySize);
    return 0;
}
```

###### 13. 已知一个顺序表中的各结点值是从小到大有序的，插入一个值为x的结点，使顺序表中的结点仍然是从小到大排序

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// 已知一个顺序表中的各结点值是从小到大有序的，插入一个值为x的结点，使顺序表中的结点仍然是从小到大排序
bool Insert_x(SqList &L, ElemType x) {
    if (L.length >= MaxSize)return false; // 如果链表满了不插入
    int j = L.length - 1; // 指向表尾 
    while (j >= 0 && L.data[j] > x) { // 如果当前数据比x大，那么就后移当前数据
        L.data[j + 1] = L.data[j]; // 后移一位当前数据
        j--; // 索引往前一步
    }
    L.data[j + 1] = x; // 给空出来的位置插入元素
    L.length++;
    return true;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[5] = {7, 9, 16, 21, 23};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    Insert_x(L1, 14);
    Print(L1);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

###### 14. 求顺序表中值为x的结点的个数

```c++
#include "func.h"

#define ElemType int
#define MaxSize 10

typedef struct {
    ElemType data[MaxSize];
    int length;
    int maxSize;
} SqList;

bool InitList(SqList &L) {
    L.length = 0;
    L.maxSize = MaxSize;
    return true;
}


bool InsertList(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false;
    }
    if (L.length >= MaxSize) {
        return false;
    }
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

void Print(SqList L) {
    for (int i = 0; i < L.length; ++i) {
        printf("%d\n", L.data[i]);
    }
    printf("\n");
}


// 求顺序表中值为x的结点的个数
int count_x(SqList &L, ElemType x) {
    int c = 0;
    for (int i = 0; i < L.length; ++i) {
        if (L.data[i] == x) {
            c++;
        }
    }
    return c;
}


int main() {
    SqList L1;
    InitList(L1);

    SqList L2;
    InitList(L2);

    SqList L3;
    InitList(L3);

//    int arr[10] = {1, 2, 2, 3, 3, 4, 4, 5, 5, 6};
    int arr[5] = {7, 7, 16, 7, 23};
    int size = sizeof(arr) / sizeof(ElemType);

    for (int i = 0; i < size; ++i) {
        InsertList(L1, i + 1, arr[i]);
    }
//    for (int i = 1; i <= 10; ++i) {
//        InsertList(L2, i, i + 5);
//    }

    Print(L1);
    int c = count_x(L1, 7);
//    Print(L1);

    printf("c=%d\n", c);

//    Print(L2);

//    Print(L3);
    return 0;
}
```

## 线性表的链式表示-链表